#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - ARTEMIS // Kamailio Proxy for Users
#        vozip+ivozprovider@irontec.com
#
#########################################################################################################

####### Defines #########

#!define TRUNKS_SIP_PORT 5060
#!define SIP_PORT 5060
#!define SIPS_PORT 5061
#!define RPC_PORT 8000
#!define WS_PORT 10080
#!define WSS_PORT 10081

#
# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# FTL_NATS: Tags the transaction as behind NAT. It uses nat_uac_test(18) as NAT-detection mechanism
# 18: 2 + 16
# 2 - the "received" test is used: address in the "Via" header is compared against source IP address of signaling
# 16 - Test if the source port is different from the port in the "Via" header

#!define FLT_NATS 1

# FLB_NATB: Tags the branch as behind NAT.
# Is is set in 2 cases:
# 1. REGISTER behind NAT (received IP:PORT are saved in usrloc table)
# 2. Within-dialog request with nat=yes in Route header (added by this proxy in Record-route of initial transaction)

#!define FLB_NATB 2

# FLB_NATSIPPING: Enables SIP-pinging using OPTIONS for UACs registered behind NAT (see case 1 FLB_NATB)
#!define FLB_NATSIPPING 3

# DLG_FLAG
#!define DLG_FLAG 4

# ACC Flags
#!define FLT_ACC 5
#!define FLT_ACCMISSED 6
#!define FLT_ACCFAILED 7

# Marked for branches involving wss
#!define FLB_WEBSOCKETS 8

# - options
#!define WITH_ANTIFLOOD
#!define WITH_REALTIME

#!define DBURL "mysql://[kamailio]/ivozprovider"

# Maximum call duration: 3 hours
#!define MAX_DIALOG_TIMEOUT 10800

####### Runtime cfg values (kamcmd cfg.list) #########

# Enable/disable debug logs
dolog.websocket = 1 desc "If 1, debug WS connection upgrade"

####### Global Parameters #########

listen=udp:IP:SIP_PORT
listen=tcp:IP:SIP_PORT
listen=tls:IP:SIPS_PORT
listen=tcp:IP:RPC_PORT
listen=tcp:IP:WS_PORT
listen=tls:IP:WSS_PORT

tcp_accept_no_cl=yes # Needed for WS

import_file "multisocket.cfg"

# -- Debug level
# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# If debug level of message is lower than current debug parameter, it gets printed
# Current value: 2 (INFO and higher)
#
# This setting can me modified/seen live running:
# kamcmd-proxyusers cfg.seti core debug X
# kamcmd-proxyusers cfg.get core debug

debug=1
memdbg=4
memlog=5

log_stderror=no
fork=yes
version_table="kam_version"

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5
tcp_max_connections=8192

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec IvozProvider v2.18"
user_agent_header="User-Agent: Irontec IvozProvider v2.18"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "usrloc.so"
loadmodule    "registrar.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "nathelper.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "permissions.so"
loadmodule    "sqlops.so"
loadmodule    "cfg_rpc.so"
loadmodule    "dialog.so"
loadmodule    "acc.so"
loadmodule    "dmq.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "auth.so"
loadmodule    "domain.so"
loadmodule    "xmlops.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "corex.so"
loadmodule    "rtpengine.so"
loadmodule    "websocket.so"
loadmodule    "xhttp.so"
loadmodule    "jsonrpcs.so"
loadmodule    "json.so"
loadmodule    "jansson.so"
loadmodule    "pua.so"
loadmodule    "pua_dialoginfo.so"
loadmodule    "presence.so"
loadmodule    "presence_xml.so"
loadmodule    "presence_dialoginfo.so"
loadmodule    "ipops.so"
loadmodule    "dialplan.so"
loadmodule    "diversion.so"
loadmodule    "cfgutils.so"
loadmodule    "uac.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

#!ifdef WITH_REALTIME
loadmodule    "ndb_redis.so"
#!endif

import_file "geoip.cfg"

# DMQ
modparam("dmq", "server_address", "sip:users.ivozprovider.local:5060")
modparam("dmq", "notification_address", "sip:trunks.ivozprovider.local:5060")
modparam("dmq", "ping_interval", 3600)

# RTPENGINE
modparam("rtpengine", "db_url", DBURL)
modparam("rtpengine", "table_name", "kam_rtpengine")
modparam("rtpengine", "setid_avp", "$avp(setid)")
modparam("rtpengine", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpengine", "setid_default", 0)
modparam("rtpengine", "mos_average_pv", "$avp(mos_average)")
modparam("rtpengine", "mos_average_packetloss_pv", "$avp(mos_average_packetloss)")
modparam("rtpengine", "mos_average_jitter_pv", "$avp(mos_average_jitter)")
modparam("rtpengine", "mos_average_roundtrip_pv", "$avp(mos_average_roundtrip)")
modparam("rtpengine", "mos_A_label_pv", "$avp(mos_A_label)")
modparam("rtpengine", "mos_average_A_pv", "$avp(mos_average_A)")
modparam("rtpengine", "mos_average_packetloss_A_pv", "$avp(mos_average_packetloss_A)")
modparam("rtpengine", "mos_average_jitter_A_pv", "$avp(mos_average_jitter_A)")
modparam("rtpengine", "mos_average_roundtrip_A_pv", "$avp(mos_average_roundtrip_A)")
modparam("rtpengine", "mos_B_label_pv", "$avp(mos_B_label)")
modparam("rtpengine", "mos_average_B_pv", "$avp(mos_average_B)")
modparam("rtpengine", "mos_average_packetloss_B_pv", "$avp(mos_average_packetloss_B)")
modparam("rtpengine", "mos_average_jitter_B_pv", "$avp(mos_average_jitter_B)")
modparam("rtpengine", "mos_average_roundtrip_B_pv", "$avp(mos_average_roundtrip_B)")

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_DSSOCKET)")
modparam("dispatcher", "attrs_avp", "$avp(DSATTRS)")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 2)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@users.ivozprovider.local")
modparam("dispatcher", "hash_pvar", "$avp(hash)")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxyusers_ctl")

# TLS
modparam("tls", "config", "/etc/kamailio/proxyusers/tls.cfg")
modparam("tls", "tls_log", 2)

# JSONRPCS
modparam("jsonrpcs", "transport", 1)

# USRLOC
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "timer_interval", 30)
modparam("usrloc|tm", "xavp_contact", "ulattrs")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# NAT
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")

# REGISTER
modparam("registrar", "min_expires", 900)
modparam("registrar", "max_contacts", 10)
modparam("registrar", "use_path", 1)
modparam("registrar", "path_mode", 2)
modparam("registrar", "default_q", 1000)

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_users_address") # Allowed networks per non-wholesale clients
modparam("permissions", "trusted_table", "kam_trusted") # Wholesale IPs
modparam("permissions", "db_mode", 1)
modparam("permissions", "grp_col", "companyId")
modparam("permissions", "max_subnets", 4096)
modparam("permissions", "peer_tag_avp", "$avp(wholesaleId)")

# ACC
# -- transactions to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "report_cancels", 1)
modparam("acc", "report_ack", 1)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 1)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs; callid=$ci; cidhash=$dlg_var(cidhash)")

# -- cdr accounting to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 0)
modparam("acc", "cdrs_table", "kam_users_cdrs")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_skip", "nocdr")
modparam("acc", "cdr_extra_nullable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);referrer=$dlg_var(referrer);referee=$dlg_var(referee);direction=$dlg_var(direction);userId=$dlg_var(userId);friendId=$dlg_var(friendId)")

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "callsPerAor; outgoingCallsPerAor")
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "default_timeout", MAX_DIALOG_TIMEOUT)
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n") # Added to requests generated locally by the module (e.g. BYE)
modparam("dialog", "detect_spirals", 0)

# TM
modparam("tm", "fr_timer", 5000)
modparam("tm", "contacts_avp", "tm_contacts")
modparam("tm", "contact_flows_avp", "tm_contact_flows")
modparam("tm", "local_cancel_reason", 200)
modparam("tm", "auto_inv_100_reason", "Trying")

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 100)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif

# dialogs htable contains aleg, bleg and applicationserver per dialog
modparam("htable", "htable", "dialogs=>size=10;autoexpire=10800")
modparam("htable", "htable", "dmq=>size=8;autoexpire=10800;dmqreplicate=1;")
modparam("htable", "htable", "srcban=>size=8;autoexpire=43200")
modparam("htable", "htable", "badauthcnt=>size=8;autoexpire=43200")
modparam("htable", "htable", "aors=>size=10")
modparam("htable", "enable_dmq", 1)

# SANITY
modparam("sanity", "autodrop", 0)

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://[kamailio]/ivozprovider")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_users_domain")
modparam("domain", "domain_attrs_table", "kam_users_domain_attrs")
modparam("domain", "register_myself", 1)

# PRESENCE
modparam("presence", "db_url", DBURL)
modparam("presence", "presentity_table", "kam_users_presentity")
modparam("presence", "active_watchers_table", "kam_users_active_watchers")
modparam("presence", "watchers_table", "kam_users_watchers")
modparam("presence", "min_expires", 1800)
modparam("presence", "max_expires", 3600)
modparam("presence", "db_update_period", 100)
modparam("presence", "subs_db_mode", 2)
modparam("presence", "db_table_lock_type", 0)
modparam("presence", "clean_period", 15)

# PRESENCE XML
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "xcap_table", "kam_users_xcap")
modparam("presence_xml", "force_active", 1)

# PRESENCE DIALOGINFO
modparam("presence_dialoginfo", "force_single_dialog", 1)
modparam("presence_dialoginfo", "force_dummy_dialog", 1)

# PUA
modparam("pua", "db_url", DBURL)
modparam("pua", "db_table", "kam_users_pua")
modparam("pua", "db_mode", 0)
modparam("pua", "update_period", 100)
modparam("pua", "db_table_lock_write", 0)
modparam("pua", "outbound_proxy", "sip:users.ivozprovider.local")

# PUA_DIALOGINFO
# -- needed for call-pickup
modparam("pua_dialoginfo", "include_callid", 1)
modparam("pua_dialoginfo", "include_tags", 1)
modparam("pua_dialoginfo", "include_localremote", 1)
modparam("pua_dialoginfo", "caller_confirmed", 0)
modparam("pua_dialoginfo", "use_pubruri_avps", 1)
modparam("pua_dialoginfo", "pubruri_caller_avp", "$avp(pubruri_caller)")
modparam("pua_dialoginfo", "pubruri_callee_avp", "$avp(pubruri_callee)")
modparam("pua_dialoginfo", "pubruri_caller_dlg_var", "pubruri_caller")
modparam("pua_dialoginfo", "pubruri_callee_dlg_var", "pubruri_callee")

# DIALPLAN
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "table_name", "kam_dialplan")
modparam("dialplan", "attrs_pvar", "$avp(s:appliedrule)")

# UAC
modparam("uac", "restore_mode","auto")
modparam("uac", "restore_dlg", 1)

#!ifdef WITH_REALTIME
# REDIS
modparam("ndb_redis", "server", "name=realtime;sentinel_group=mymaster;sentinel_master=1;sentinel=data.ivozprovider.local:26379")
modparam("ndb_redis", "init_without_redis", 1)
#!endif

####### Routing Logic ########

request_route {
    route(REQINIT);

    route(IS_FROM_INSIDE);

    route(CIDHASH);

    if (is_method("KDMQ") && $var(is_from_inside)) {
        dmq_handle_message();
        exit;
    }

    if (is_method("OPTIONS")) {
        force_rport();
        route(ANTIFLOOD);
        send_reply("200", "I'm here!");
        exit;
    }

    xnotice("[$dlg_var(cidhash)] Request: $rm $ru from $fu ($cs $rm - $proto:$si:$sp) [$ci]\n");

    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RTPENGINE);
            route(RELAY);
        }

        xwarn("[$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        route(ANTIFLOOD);
        exit;
    }

    # Manage retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    ### only initial requests (no To tag)

    # Wholesale request?
    if(allow_trusted($si, 'any') && $avp(wholesaleId) != $null) {
        xinfo("[$dlg_var(cidhash)] Initial request from wholesale 'c$avp(wholesaleId)'\n");
    }

    # Discard unsupported methods
    route(FILTER_METHODS);

    # Remove preloaded route headers
    remove_hf("Route");

    # Handle PUA generated PUBLISH
    route(LOCAL_PUBLISH);

    # Checks prior to authentication
    route(PREAUTH);

    # Get request endpoint
    route(GET_ENDPOINT);

    # Manage authentication
    route(AUTH);

    # Get request endpoint
    route(GET_INFO_FROM_ENDPOINT);

    # Filter by source address for outbound non-INVITE requests
    if (!is_method("INVITE")) route(FILTER_BY_SRC_ADDR);

    # Handle REGISTER
    route(REGISTER);

    # Handle NOTIFY, SUBSCRIBE and PUBLISH
    route(PRESENCE);

    # -- From now on, everything is for INVITEs --

    # Antiflooding for new calls establishments
    route(ANTIFLOOD);

    # Set caller and callee to generate PUBLISH
    route(GENERATE_PUBLISH);

    # Track dialog
    if (!is_known_dlg() || $si == $var(trunksAddress) || src_ip == myself) {
        dlg_manage();
    }

    # Calculate cidhash if not set
    route(CIDHASH);

    # Inspect new request
    route(CLASSIFY);

    # Add record-route to INVITE requests
    record_route();

    route(GET_CALL_INFO);

    # Get codec capabilities for call
    route(GET_CODEC_INFO);

    # Route by source
    if ($var(is_from_inside)) {
        route(REPLACES);
        route(PARSE_X_HEADERS);
        route(MAXCALLS_USER);
        route(SAVE_CONTACT);
        route(LOOKUP);
    } else {
        route(FILTER_BY_SRC_ADDR);
        route(ADAPT_RURI_IN);
        route(ADAPT_DIVERSION);
        route(ADAPT_CALLER);
        #!ifdef WITH_MULTISOCKET
        if ($Ri != $sel(cfg_get.address.main)) {
            # force_send_socket to main address (UAC talking to non-main address $dlg_var(extra_socket)
            $fs = "udp:" + $sel(cfg_get.address.main) + ":5060";
            $dlg_var(extra_socket) = $Ri;
        }
        #!endif
        if ($dlg_var(type) == 'wholesale' || $dlg_var(type) == 'retail') {
            route(DISPATCH_TO_TRUNKS);
        } else {
            route(DISPATCH_TO_AS);
        }
    }

    if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    route(ACCOUNTING);
    route(RELAY);
}

# This route sets $var(is_from_inside): 1 / 0
#   - 1: request/response comes from the inside
#   - 0: request/response comes from the outside world
route[IS_FROM_INSIDE] {
    if (ds_is_from_list("1") || $si == $var(trunksAddress)) {
        $var(is_from_inside) = 1; # as / trunks
    } else {
        $var(is_from_inside) = 0; # uacs
    }
}

route[FILTER_METHODS] {
    if (!is_method("INVITE|REGISTER|SUBSCRIBE|PUBLISH|NOTIFY")) {
        xwarn("[$dlg_var(cidhash)] FILTER-METHODS: $rm not supported\n");
        route(ANTIFLOOD);
        send_reply("501", "Not Implemented");
        exit;
    }

    if ($avp(wholesaleId) != $null && !is_method("INVITE")) {
        xwarn("[$dlg_var(cidhash)] CHECK-WHOLESALE: $rm not supported for wholesale client\n");
        route(ANTIFLOOD);
        send_reply("501", "Not Implemented");
        exit;
    }
}

# Sets dlg_var(cidhash)
route[CIDHASH] {
    if ($dlg_var(cidhash) == $null)
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});
}

route[ADAPT_RURI_OUT] {
    if ($var(ddi_in) != 'yes') return;

    # Use callee as destination instead of username
    xinfo("[$dlg_var(cidhash)] ADAPT-RURI-OUT: Set callee as destination ($rU -> $dlg_var(callee))\n");
    $rU = $dlg_var(callee);

    $var(number) = $rU;
    route(IS_INTERNAL);
    if ($avp(is_internal) != '1') {
        # Adapt external number
        $var(transformation) = $dlg_var(tr_callee_out);
        route(APPLY_TRANSFORMATION);
        $rU = $var(transformated);
    }

    # Make To and R-URI equal to avoid problems with endpoints routing to To username
    uac_replace_to("sip:" + $rU +"@" + $td);
}

route[ADAPT_RURI_IN] {
# Only in initial INVITE requests from subscribers

    $var(number) = $rU;
    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        return;
    }

    # External call, look for route/DDI prefixes
    if ($dlg_var(type) == 'wholesale' || $dlg_var(type) == 'retail') {
        route(GET_ROUTING_TAG);
    } else if ($dlg_var(type) == 'vpbx' && $dlg_var(userId) != $null) {
        # Only users can force DDI using a prefix (through Outgoing DDI Rules)
        route(GET_DDI_PREFIX);
    }

    $var(number) = $rU;
    $var(transformation) = $dlg_var(tr_callee_in);
    route(APPLY_TRANSFORMATION);
    $rU = $var(transformated);
}

# Iterates through $drb, sets $var(prefix) and $var(prefixId) if R-URI matches prefix and strips it
route[SEARCH_AND_STRIP_PREFIX] {
    $var(prefix) = "";
    if ($dbr(rb=>rows) > 0) {
        $var(i) = 0;
        while($var(i) < $dbr(rb=>rows)) {
            $var(currentPrefix) = $dbr(rb=>[$var(i),0]);
            if ($(rU{s.substr,0,$(var(currentPrefix){s.len})}) == $var(currentPrefix)) {
                $var(prefix) = $var(currentPrefix);
                $var(prefixId) = $dbr(rb=>[$var(i),1]);
                break;
            }
            $var(i) = $var(i) + 1;
        }
    }
    sql_result_free("rb");

    # Strip from R-URI if routing tag matched
    if ($var(prefix) != "") {
        $rU = $(rU{s.strip, $(var(prefix){s.len})});
    }
}

# Detects routing tag, sets header with tag and id and strips it from r-uri
route[GET_ROUTING_TAG] {
    sql_query("cb", "SELECT tag, RT.id FROM RoutingTags RT INNER JOIN CompaniesRelRoutingTags CRRT ON CRRT.routingTagId = RT.id WHERE CRRT.companyId = '$dlg_var(companyId)'", "rb");
    route(SEARCH_AND_STRIP_PREFIX);

    # Prevent multiple routing tag usage
    if ($rU =~ "#") {
        xwarn("[$dlg_var(cidhash)] GET-ROUTING-TAG: Destination cannot contain '#' after stripping routing tag\n");
        send_reply("404", "Invalid destination");
        exit;
    }

    # Add headers if routing tag matched
    if ($var(prefix) != "") {
        xinfo("[$dlg_var(cidhash)] GET-ROUTING-TAG: Detected tag '$var(prefix)' (id: $var(prefixId)), new destination: $rU\n");
        append_hf("X-Info-RoutingTagId: $var(prefixId)\r\n");
        append_hf("X-Info-RoutingTag: $var(prefix)\r\n");
    }
}

# Detects ddi prefix, sets header with prefix and strips it from r-uri
route[GET_DDI_PREFIX] {
    sql_query("cb", "SELECT ODRP.prefix, ODRP.id FROM OutgoingDDIRulesPatterns ODRP INNER JOIN OutgoingDDIRules ODR ON ODR.id = ODRP.outgoingDDIRuleId INNER JOIN Companies C ON C.id = ODR.companyId INNER JOIN Users U ON U.companyId = C.id WHERE ODR.id = COALESCE(U.outgoingDDIRuleId, C.outgoingDDIRuleId) AND U.id ='$dlg_var(userId)' AND ODRP.type = 'prefix' ORDER BY priority", "rb");
    route(SEARCH_AND_STRIP_PREFIX);

    # Add headers if ddi prefix matched
    if ($var(prefix) != "") {
        xinfo("[$dlg_var(cidhash)] GET-DDI-PREFIX: Detected ddi prefix '$var(prefix)', new destination: $rU\n");
        append_hf("X-Info-DDI-Prefix: $var(prefix)\r\n");
    }
}

route[ADAPT_REFERTO] {
# Only in within-dialog REFER requests from subscribers
    if(!is_method("REFER")) return;
    if($dlg_var(type) != 'vpbx') return;

    if (search_hf("Refer-To", "Replaces", "a")) {
        xinfo("[$dlg_var(cidhash)] ADAPT-REFERTO: Replaces found in Refer-To, return\n");
        return;
    }

    $var(number) = $(rt{uri.user});

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        return;
    }

    $var(transformation) = $dlg_var(tr_callee_in);

    route(APPLY_TRANSFORMATION);
    $var(newreferto) = '<sip:' + $var(transformated) + '@' + $(rt{uri.host}) + '>';
    remove_hf("Refer-To");
    append_hf("Refer-To: $var(newreferto)\r\n");
}

route[ADAPT_CALLER] {
    # First of all: do I have to mangle caller?
    if (!$var(is_from_inside)) {
        if ($dlg_var(type) == "retail" && !is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
            if (is_request() && !has_totag()) {
                route(GET_FALLBACK_DDI);
                $dlg_var(caller) = $var(fallback_ddi);
                $var(transformated) = $var(fallback_ddi);
                route(SET_PAI);
            }
            return;
        }

        if ($dlg_var(type) == "residential" && !is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
            return;
        }

        if ($dlg_var(type) == 'vpbx') {
            if ($dlg_var(userId) != $null) {
                remove_hf("P-Asserted-Identity");
                remove_hf("Remote-Party-ID");
                return;
            } else if ($dlg_var(friendId) != $null) {
                if (!is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
                    return;
                }
            }
        }
    } else {
        if ($dlg_var(type) == "vpbx" && !is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
            return;
        }
    }

    route(GET_CALLER); # Greps caller and sets it in $var(number)

    if (is_request() && !has_totag()) {
        if ($var(is_from_inside) || src_ip == myself) {
            # Save caller in e164 for accounting
            $dlg_var(caller) = $var(number);
        }
    }

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        return;
    }

    if ($var(is_from_inside)) {
        $var(transformation) = $dlg_var(tr_caller_out);
    } else {
        $var(transformation) = $dlg_var(tr_caller_in);
    }

    route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)

    if ($var(is_from_inside)) {
        route(SET_PAI);
    } else {
        if (is_request() && !has_totag()) {
            if ($dlg_var(type) == "retail" && $dlg_var(valid_clid) != 'yes') {
                route(VALIDATE_CLID_NUMBER);
                if ($dlg_var(valid_clid) == "no") {
                    route(GET_FALLBACK_DDI);
                    $var(transformated) = $var(fallback_ddi);
                }
            }

            # Save caller in e164 for accounting
            $dlg_var(caller) = $var(transformated);
        }
        route(SET_CALLER);
    }
}

# Sets fallback DDI in $var(fallback_ddi)
route[GET_FALLBACK_DDI] {
    sql_xquery("cb", "SELECT D.id, DDIE164 FROM RetailAccounts RA INNER JOIN Companies C ON C.id = RA.companyId INNER JOIN DDIs D ON D.id = COALESCE(RA.outgoingDdiId, C.outgoingDdiId) WHERE RA.id = $dlg_var(retailAccountId)", "ra");

    $var(fallback_ddi) = $xavp(ra=>DDIE164);
    if (!$var(fallback_ddi)) {
        xwarn("[$dlg_var(cidhash)] GET-FALLBACK-DDI: No fallback DDI for retail account $dlg_var(retailAccountId)\n");
        send_reply("403", "Forbidden (invalid CLID)");
        exit;
    }

    xwarn("[$dlg_var(cidhash)] GET-FALLBACK-DDI: Force $var(fallback_ddi) for retail account $dlg_var(retailAccountId)\n");
    append_hf("X-Info-DdiId: $xavp(ra=>id)\r\n");
}

# Sets caller in $var(number) seeking in PAI/RPID/From (in this order)
route[GET_CALLER] {
    # Where is my caller? PAI/RPID/From?
    if (is_present_hf("P-Asserted-Identity")) {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: PAI present: $(ai{uri.user})\n");
        $var(number) = $(ai{uri.user});
    } else if (is_present_hf("Remote-Party-ID")) {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: RPID present: $(re{uri.user})\n");
        $var(number) = $(re{uri.user});
    } else {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: Nor PAI nor RPID present, only From ($fU)! :(\n");
        $var(number) = $fU;
    }
}

# Sets $var(transformated) in existing origin headers (From + PAI + RPID)
route[SET_CALLER] {
    # Mangle From only for initial requests from wholesale clients without PAI nor RPID
    if (is_request() && !has_totag()) {
        if ($dlg_var(type) == 'wholesale' && !is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
            if ($fU != $var(transformated)) {
                $var(newfromuri) = 'sip:' + $var(transformated) + '@' + $fd;
                uac_replace_from("","$var(newfromuri)");
            }
        }
    }

    if (is_present_hf("P-Asserted-Identity")) {
        if ($(ai{uri.user}) != $var(transformated)) { # If new value differs from previous, change
            remove_hf("P-Asserted-Identity");
            append_hf("P-Asserted-Identity: <sip:$var(transformated)@$(ai{uri.host})>\r\n");
        }
    }

    if (is_present_hf("Remote-Party-ID")) {
        if ($(re{uri.user}) != $var(transformated)) { # If new value differs from previous, change
            remove_hf("Remote-Party-ID");
            append_hf("Remote-Party-ID: <sip:$var(transformated)@$(re{uri.host})>\r\n");
        }
    }
}

# Sets $var(transformated) in new PAI or existing PAI (modifies From in initial requests too)
route[SET_PAI] {
    if (is_request() && !has_totag() && $avp(intervpbx) != 'yes') {
        if ($(avp(friendFromUser){s.len}) > 0 && $var(is_from_inside)) {
            $var(newfromuser) = $avp(friendFromUser);
        } else {
            $var(newfromuser) = $var(transformated);
        }

        if ($fU != $var(newfromuser)) {
            $var(newfromuri) = 'sip:' + $var(newfromuser) + '@' + $fd;
            uac_replace_from("$var(newfromuri)");
        }
    }

    if (is_present_hf("Remote-Party-ID")) remove_hf("Remote-Party-ID");

    if (is_present_hf("P-Asserted-Identity")) {
        $var(newpai) = 'sip:' + $var(transformated) + '@' + $(ai{uri.host});
        remove_hf("P-Asserted-Identity");
    } else {
        $var(newpai) = 'sip:' + $var(transformated) + '@' + $fd;
    }

    $var(displayName) = "";
    if (is_present_hf("P-Asserted-Identity")) {
        $var(displayName) = $(hdr(P-Asserted-Identity){nameaddr.name});
    }

    append_hf("P-Asserted-Identity: $var(displayName)<$var(newpai)>\r\n");

    return;
}

route[ADAPT_CONTACT] {
# Only in 3XX replies to INVITEs from subscribers
    if (!is_present_hf("Contact")) return;

    if ($var(is_from_inside)) {
        xerr("[$dlg_var(cidhash)] ADAPT-CONTACT: 3XX reply from AS, this shouldn't happen\n");
        return;
    }

    $var(number) = @contact.uri.user;

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        return;
    }

    $var(transformation) = $dlg_var(tr_callee_in);
    route(APPLY_TRANSFORMATION);
    $var(newcontact) = '<sip:' + $var(transformated) + '@' + @contact.uri.host + '>';
    remove_hf("Contact");
    append_hf("Contact: $var(newcontact)\r\n");
}

route[ADAPT_DIVERSION] {
# In all initial INVITE requests
    if (!is_present_hf("Diversion")) return;

    if (!$var(is_from_inside) && $dlg_var(type) != 'wholesale') {
        if ($dlg_var(userId) != $null) {
            xwarn("[$dlg_var(cidhash)] ADAPT-DIVERSION: Remove Diversion header in user call\n");
            remove_hf("Diversion");
            return;
        } else {
            # Diversion without PAI/RPID from friend/retail/residential
            if (!is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
                xwarn("[$dlg_var(cidhash)] ADAPT-DIVERSION: Remove Diversion as no PAI/RPID header found\n");
                remove_hf("Diversion");
                return;
            }
        }
    }

    # Only adapt first Diversion header
    $var(number) = $(di{uri.user});
    if ($var(number) == $null) {
        xinfo("[$dlg_var(cidhash)] ADAPT-DIVERSION: No number extracted, return\n");
        return;
    }

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        $dlg_var(diversion) = $var(number);
        return;
    }

    $avp(reason) = @hf_value.diversion[0].param['reason'];
    if ($avp(reason) == $null) {
        xinfo("[$dlg_var(cidhash)] ADAPT-DIVERSION: No reason extracted, set 'deflection'\n");
        $avp(reason) = 'deflection';
    }

    if ($var(is_from_inside)) {
        $var(transformation) = $dlg_var(tr_caller_out);
    } else {
        $var(transformation) = $dlg_var(tr_caller_in);
    }

    route(APPLY_TRANSFORMATION);
    if (!$var(is_from_inside) && $dlg_var(type) != 'wholesale') {
        # Check if Diversion is valid before proceeding
        route(VALIDATE_CLID_NUMBER);
        if ($dlg_var(valid_clid) == "no") {
            xwarn("[$dlg_var(cidhash)] ADAPT-DIVERSION: Remove Diversion headers as $var(number) is not valid for retail account $dlg_var(retailAccountId)\n");
            remove_hf("Diversion");
            return;
        }
    }
    remove_hf_value("Diversion[0]");
    add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $(di{uri.host}));
    $dlg_var(diversion) = $var(transformated);
}

# Sets $dlg_var(valid_clid) to "yes" if $var(transformated) is valid for $dlg_var(companyId), to "no" otherwise
route[VALIDATE_CLID_NUMBER] {
    sql_query("cb", "SELECT id, DDIE164 FROM DDIs WHERE companyId='$dlg_var(companyId)' AND DDIE164='$var(transformated)'", "rc");

    if ($dbr(rc=>rows) > 0) {
        xinfo("[$dlg_var(cidhash)] VALIDATE-CLID-NUMBER: $var(transformated) is VALID for company $dlg_var(companyId)\n");
        $dlg_var(valid_clid) = "yes";
        append_hf("X-Info-DdiId: $dbr(rc=>[0,0])\r\n");
    } else {
        xwarn("[$dlg_var(cidhash)] VALIDATE-CLID-NUMBER: $var(transformated) is NOT VALID for company $dlg_var(companyId)\n");
        $dlg_var(valid_clid) = "no";
    }

    sql_result_free("rc");
}

# Apply $var(transformation) transformations (if set) to $var(number)
# Sets result in $var(transformated)
route[APPLY_TRANSFORMATION] {
    $var(transformated) = $var(number);
    $avp(appliedrule) = $null;

    dp_translate("$(var(transformation){s.int})", "$var(number)/$var(transformated)");

    # If no rule applied, re-set value
    if ($avp(appliedrule) == $null)
        $var(transformated) = $var(number);

    if (is_request() && !has_totag()) {
        xnotice("[$dlg_var(cidhash)] APPLY-TRANSFORMATION: '$var(number)' -> '$var(transformated)' (applied rule: '$avp(appliedrule)')\n");
    } else {
        xinfo("[$dlg_var(cidhash)] APPLY-TRANSFORMATION: '$var(number)' -> '$var(transformated)' (applied rule: '$avp(appliedrule)')\n");
    }
}

route[REQINIT] {
    #!ifdef WITH_ANTIFLOOD
    # Banned addresses
    if($sht(ipban=>$si) != $null) {
        xinfo("REQINIT: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
        exit;
    }
    #!endif

    # Banned sources
    if ($sht(srcban=>$fU@$fd::$si) != $null) {
        route(ANTIFLOOD);
        send_reply("403", "Forbidden [BS]");
        exit;
    }

    # Easy dropping for scanners
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent|pplsip" || search("sipvicious")) {
        xwarn("REQINIT: Dropping scanner request ----> $rm from $si\n");
        route(ANTIFLOOD);
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("5607", "7")) {
        xwarn("REQINIT: Dropping malformed SIP message from $si:$sp\n");
        route(ANTIFLOOD);
        exit;
    }

    # SQL injection control
    if($fd != $null && $fd =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)") {
        xwarn("REQINIT: Someone from $si is doing an sql injection attack, drop");
        route(ANTIFLOOD);
        exit;
    }

    if($fU != $null && $fU =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)") {
        xwarn("REQINIT: Someone from $si is doing an sql injection attack, drop");
        route(ANTIFLOOD);
        exit;
    }

    if($tU != $null && $tU =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)") {
        xwarn("REQINIT: Someone from $si is doing an sql injection attack, drop");
        route(ANTIFLOOD);
        exit;
    }

    if($td != $null && $td =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)") {
        xwarn("REQINIT: Someone from $si is doing an sql injection attack, drop");
        route(ANTIFLOOD);
        exit;
    }

    if($rU != $null && $rU =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)") {
        xwarn("REQINIT: Someone from $si is doing an sql injection attack, drop");
        route(ANTIFLOOD);
        exit;
    }

    if($rd != $null && $rd =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)") {
        xwarn("REQINIT: Someone from $si is doing an sql injection attack, drop");
        route(ANTIFLOOD);
        exit;
    }

    if($au != $null && $au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)") {
        xwarn("REQINIT: Someone from $si is doing an sql injection attack, drop");
        route(ANTIFLOOD);
        exit;
    }

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        xwarn("REQINIT: Too many hops for SIP message from $si:$sp\n");
        route(ANTIFLOOD);
        send_reply("483","Too Many Hops");
        exit;
    }
}

route[GENERATE_PUBLISH] {
    if ($avp(endpointType) != 'Terminals') return; # Skip logic for non terminal calls

    if ($var(is_from_inside)) {
        # Set X-Info-Callee as 'callee' instead of user in To header
        $avp(pubruri_callee)= "sip:" + $hdr(X-Info-Callee) + "@" + $fd;
    } else {
        # Set user extension as 'caller' instead of user in From header
        $avp(pubruri_caller)= "sip:" + $avp(extension) + "@" + $fd;

        $dlg_var(caller) = $avp(extension); # Set accounting dlg_var too
    }
}

route[MAXCALLS_USER] {
    if (!$dlg_var(maxcallsUser)){
        xinfo("[$dlg_var(cidhash)] MAXCALLS-USER: '$tU@$td' has no call-limit, proceed\n");
        return;
    }

    get_profile_size("callsPerAor", "$tU@$td", "$var(currentCalls)");
    xinfo("[$dlg_var(cidhash)] MAXCALLS-USER: '$tU@$td' has $var(currentCalls) out of $dlg_var(maxcallsUser) active calls\n");

    if ($var(currentCalls) >= $dlg_var(maxcallsUser)) {
        xwarn("[$dlg_var(cidhash)] MAXCALLS-USER: '$tU@$td' has $var(currentCalls) out of $dlg_var(maxcallsUser) active calls, reject call\n");
        send_reply("486", "Maxcalls exceeded");
        exit;
    }
}

route[REPLACES] {
    # Save CallID <-> AS relationship
    $sht(dialogs=>$ci::applicationserver) = 'sip:' + $si + ':6060';

    if (! is_present_hf("Replaces")) return;

    # AS sending an INVITE with REPLACE header, guess which AS is the proper destination
    xinfo("[$dlg_var(cidhash)] REPLACES: AS sending a INVITE with Replaces header, forward to proper AS\n");

    # Extract CallId from Replaces header
    $var(replace_uri) = $(hdr(Replaces){s.select,0,;});
    xinfo("[$dlg_var(cidhash)] REPLACES: Which AS is handling $(hdr(Replaces){s.select,0,;})?\n");

    if ($sht(dialogs=>$var(replace_uri)::applicationserver) != $null) {
        $du = $sht(dialogs=>$var(replace_uri)::applicationserver);
        xinfo("[$dlg_var(cidhash)] REPLACES: Forward to '$du'\n");
        $fu = 'sip:replacer@users.ivozprovider.local'; # Change From header too
        route(RELAY);
    } else {
        xwarn("[$dlg_var(cidhash)] REPLACES: CallID not found, 500\n");
        send_reply("500", "CallID not found");
        exit;
    }
    # Note: this dialog won't be inserted into kam_acc_cdrs (INSERT fails) and that's OK
}

route[DISPATCH_TO_TRUNKS] {
    $du = "sip:trunks.ivozprovider.local:" + TRUNKS_SIP_PORT;

    # Add X-Info-Headers for trunks
    insert_hf("X-Info-BrandId: $dlg_var(brandId)\r\n");
    insert_hf("X-Info-CompanyId: $dlg_var(companyId)\r\n");
    insert_hf("X-Info-Type: $dlg_var(type)\r\n");

    if ($dlg_var(type) == "retail") {
        insert_hf("X-Info-RetailAccountId: $dlg_var(retailAccountId)\r\n");

        # Check if recordings are enabled for DDI
        sql_xquery("cb", "SELECT recordCalls FROM DDIs WHERE DDIE164='$dlg_var(caller)' AND brandId='$dlg_var(brandId)'", "ra");
        if ($xavp(ra=>recordCalls) == 'all' || $xavp(ra=>recordCalls) == 'outbound') {
            xinfo("[$dlg_var(cidhash)] DISPATCH-TO-TRUNKS: Set X-Info-Record for $dlg_var(caller)\n");
            insert_hf("X-Info-Record: yes\r\n");
        }

        # Add header so that faxes are routed using fax routes
        if ($avp(t38Passthrough) == 'yes') {
            insert_hf("X-Info-Special: fax\r\n");
        }
    }
}

route[DISPATCH_TO_AS] {
    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Static routing to specific AS?
    if ($avp(distributeMethod) == 'static') {
        $du = "sip:" + $avp(asAddress) + ":6060";
        xinfo("[$dlg_var(cidhash)] DISPATCH-TO-AS: Company has static routing enabled\n");
    } else {
        if ($avp(distributeMethod) == 'hash') {
            $avp(hash) = $dlg_var(companyId);
            # hash over $avp(hash)
            $var(alg) = 7;
        } else {
            # round robin dispatching on ASs (distributeMethod == 'rr')
            xinfo("[$dlg_var(cidhash)] DISPATCH-TO-AS: dispatch to any AS (round robin)\n");
            $var(alg) = 4;
        }

        if(!ds_select_dst("1", "$var(alg)")) {
            xerr("[$dlg_var(cidhash)] DISPATCH-TO-AS: No destination found\n");
            send_reply("404", "No destination");
            exit;
        } else {
            t_on_failure("MANAGE_FAILURE_AS");
        }
    }

    xinfo("[$dlg_var(cidhash)] DISPATCH-TO-AS: going to <$ru> via <$du>\n");

    # Save CallID <-> AS relationship
    $sht(dialogs=>$ci::applicationserver) = $du;
}

route[LOOKUP] {
    if ($dlg_var(retail_callfwd) == 'inconditional') {
        route(PREPARE_RETAIL_CFW);
        return;
    }

    route(STATIC_LOCATION);
    if ($var(static_location)) return;

    lookup("kam_users_location");
    switch ($?) {
        case -1:
            xwarn("[$dlg_var(cidhash)] LOOKUP: Contact not found for $ru, 404\n");
            if ($dlg_var(retail_callfwd) == 'userNotRegistered') {
                route(PREPARE_RETAIL_CFW);
                return;
            }
            send_reply("404", "Not Found");
            exit;
        case -2:
            xwarn("[$dlg_var(cidhash)] LOOKUP: Contacts found, but method not supported for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
        case -3:
            xerr("[$dlg_var(cidhash)] LOOKUP: Internal error during processing lookup for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
    };

    # Handle multiple contacts
    if (!t_load_contacts()) {
        xerr("[$dlg_var(cidhash)] LOOKUP: Error loading contacts for $rU\n");
        send_reply("500", "Server Internal Error - Cannot load contacts");
        exit;
    }

    # Load contact or contacts
    if (!t_next_contacts()) {
        xinfo("[$dlg_var(cidhash)] LOOKUP: One contact found for $tu, calling $ru\n");
    } else {
        xnotice("[$dlg_var(cidhash)] LOOKUP: Multiple contacts found for $tu, parallel forking\n");
    }
}

route[PREPARE_RETAIL_CFW] {
    xinfo("[$dlg_var(cidhash)] PREPARE-RETAIL-CFW: Calling to retail account with $dlg_var(retail_callfwd) call-forward configured");
    $avp(apply_cfwd) = 'yes';
    $dlg_var(skipRealtime) = 'yes';
    route(DISPATCH_TO_AS);
}

route[APPLY_RETAIL_CFW] {
    # Save From user in PAI if PAI not present
    if (!is_present_hf("P-Asserted-Identity")) {
        append_hf("P-Asserted-Identity: <$dlg_var(rcfw_newpaiuri)>\r\n");
    }

    # Save original caller as caller
    $dlg_var(caller) = $dlg_var(rcfw_newpaiuser);

    # Set retail account AoR as From header
    uac_replace_from("","$dlg_var(rcfw_newfromuri)");

    # Set called DDI in Diversion header
    add_diversion("deflection", "$dlg_var(rcfw_newdiversionuri)");

    # Modify R-URI with call forward target
    $ru = $dlg_var(rcfw_newruri);

    xinfo("[$dlg_var(cidhash)] APPLY-RETAIL-CFW: Call forward to $rU\n");
}

route[STATIC_LOCATION] {
    $var(static_location) = 0;

    if ($avp(endpointType) == 'Terminals') {
        $var(ddi_in) = 'no'; # Terminals need AoR in R-URI
        return;
    }

    sql_xquery("cb", "SELECT name, domain, directConnectivity, ip, port, transport, ddiIn FROM $avp(endpointType) t LEFT JOIN Domains D ON t.domainId=D.id WHERE t.id='$avp(endpointId)'", "rb");
    $var(ddi_in) = $xavp(rb=>ddiIn);

    if ($xavp(rb=>directConnectivity) == 'no') return;

    $var(static_location) = 1;

    if ($xavp(rb=>directConnectivity) == 'intervpbx') {
        xinfo("[$dlg_var(cidhash)] STATIC-LOCATION: Inter-vPBX call\n");
        $rd = $fd;
        $du = "sip:users.ivozprovider.local";
        uac_replace_from("sip:" + $xavp(rb=>name) + "@" + $fd);
        $avp(intervpbx) = 'yes'; # used in SET_PAI
        return;
    }

    $ru = "sip:" + $xavp(rb=>name) + '@' + $xavp(rb=>ip);

    if ($(xavp(rb=>port){s.len}) > 0 && $xavp(rb=>port) != "5060") {
        $ru = $ru + ':' + $xavp(rb=>port);
    }

    if ($xavp(rb=>transport) != "udp") {
        $ru = $ru + ';transport=' + $xavp(rb=>transport);
    }

    xinfo("[$dlg_var(cidhash)] STATIC-LOCATION: Call for static endpoint, route to '$ru'\n");

    setbflag(FLB_NATB); # Assume behind NAT (port-forwarding direct connectivity)

    return;
}

route[GET_CALL_INFO] {
    sql_xquery("cb", "SELECT C.mediaRelaySetsId, C.distributeMethod, AppS.ip AS asAddress, C.onDemandRecord, CONCAT(C.transformationRuleSetId,0) AS caller_in, CONCAT(C.transformationRuleSetId,1) AS callee_in, CONCAT(C.transformationRuleSetId,2) AS caller_out, CONCAT(C.transformationRuleSetId,3) AS callee_out FROM Companies C LEFT JOIN ApplicationServers AppS ON AppS.id=C.applicationServerId WHERE C.id='$dlg_var(companyId)'", "ra");

    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
    $avp(distributeMethod) = $xavp(ra=>distributeMethod);
    $avp(asAddress) = $xavp(ra=>asAddress);

    $dlg_var(tr_caller_in) = $xavp(ra=>caller_in);
    $dlg_var(tr_callee_in) = $xavp(ra=>callee_in);
    $dlg_var(tr_caller_out) = $xavp(ra=>caller_out);
    $dlg_var(tr_callee_out) = $xavp(ra=>callee_out);

    if ($dlg_var(type) == 'wholesale') return;

    if ($xavp(ra=>onDemandRecord) != '0') {
        $dlg_var(onDemandRecord) = '1';
    }

    if ($avp(endpointType) == "Terminals") {
        $dlg_var(userId) = $avp(objectId); # user
    } else if($avp(endpointType) == "Friends") {
        $dlg_var(friendId) = $avp(objectId); # friend
    } else if($avp(endpointType) == "RetailAccounts") {
        $dlg_var(retailAccountId) = $avp(objectId); # retail
    } else {
        $dlg_var(residentialDeviceId) = $avp(objectId); # residential
    }

    if ($avp(endpointTransformationRuleSetId) != $null) {
        $dlg_var(endpointTransformationRuleSetId) = $avp(endpointTransformationRuleSetId);
        $dlg_var(tr_caller_in) = $dlg_var(endpointTransformationRuleSetId) + "0";
        $dlg_var(tr_callee_in) = $dlg_var(endpointTransformationRuleSetId) + "1";
        $dlg_var(tr_caller_out) = $dlg_var(endpointTransformationRuleSetId) + "2";
        $dlg_var(tr_callee_out) = $dlg_var(endpointTransformationRuleSetId) + "3";
    }

    if ($var(is_from_inside)) {
        # Remaining info
        $dlg_var(maxcallsUser) = $avp(maxCalls);

        # Get retail call-forward settings
        if ($dlg_var(type) == 'retail') {
            route(GET_RETAIL_CFW_SETTINGS);
        }

        # Set AoR for maxcallsUser counting
        $avp(AoR) = $tU + '@' + $td;
    } else {
        # Set AoR for maxcallsUser counting
        $avp(AoR) = $fU + '@' + $fd;
    }

    if ($avp(rtpEncryption)) {
        $dlg_var(srtp) = 'yes';
    }
}

route[GET_RETAIL_CFW_SETTINGS] {
    # Check for unconditional call forward settings
    $xavp(ra) = $null;
    sql_xquery("cb", "SELECT RA.name, D.domain, CONCAT(C.countryCode, CFS.numberValue) AS CfwTarget, RA.t38passthrough, CFS.callForwardType FROM RetailAccounts RA INNER JOIN Domains D ON RA.domainId=D.id INNER JOIN CallForwardSettings CFS ON CFS.retailAccountId=RA.id INNER JOIN Countries C ON C.id=CFS.numberCountryId WHERE CFS.enabled=1 AND CFS.callForwardType='inconditional' AND RA.t38passthrough='no' AND RA.id='$dlg_var(retailAccountId)'", "ra");

    if ($xavp(ra=>CfwTarget) == $null) {
        # Check for unreachable call forward settings
        $xavp(ra) = $null;
        sql_xquery("cb", "SELECT RA.name, D.domain, CONCAT(C.countryCode, CFS.numberValue) AS CfwTarget, RA.t38passthrough, CFS.callForwardType FROM RetailAccounts RA INNER JOIN Domains D ON RA.domainId=D.id INNER JOIN CallForwardSettings CFS ON CFS.retailAccountId=RA.id INNER JOIN Countries C ON C.id=CFS.numberCountryId WHERE CFS.enabled=1 AND CFS.callForwardType='userNotRegistered' AND RA.t38passthrough='no' AND RA.id='$dlg_var(retailAccountId)'", "ra");
    }

    # Leave if no call forward configured
    if ($xavp(ra=>CfwTarget) == $null) return;

    $dlg_var(rcfw_newfromuri) =  "sip:" + $xavp(ra=>name) + '@' + $xavp(ra=>domain);
    $dlg_var(rcfw_newpaiuri) = "sip:" + $fU + '@' + $xavp(ra=>domain);
    $dlg_var(rcfw_newpaiuser) = $fU;
    $dlg_var(rcfw_newdiversionuri) = 'sip:' + $hdr(X-Info-Callee) + '@' + $xavp(ra=>domain);
    $dlg_var(rcfw_newruri) = "sip:" + $xavp(ra=>CfwTarget) + '@' + $xavp(ra=>domain);
    $dlg_var(retail_callfwd) = $xavp(ra=>callForwardType);

    if ($dlg_var(retail_callfwd) == "userNotRegistered") {
        t_on_failure("MANAGE_FAILURE_RETAIL");
    }
}

route[FILTER_BY_SRC_ADDR] {
    if ($var(is_from_inside) || src_ip == myself) return;
    if ($dlg_var(type) == 'wholesale') return;

    # Get needed info
    $xavp(rt) = $null;
    sql_xquery("cb", "SELECT C.brandId, C.ipFilter FROM Companies C JOIN Brands B ON B.id=C.brandId WHERE C.id='$avp(companyId)'", "rt");
    $dlg_var(brandId) = $xavp(rt=>brandId);
    $dlg_var(companyId) = $avp(companyId);

    if (!$xavp(rt=>ipFilter)) {
        xinfo("[$dlg_var(cidhash)] FILTER-BY-SRC-ADDR: IP filter is disabled for company '$dlg_var(companyId)'\n");
        return;
    }

    # Company has IP check enabled

    #!ifdef WITH_GEOIP
    if(geoip2_match("$si", "src")) {
        $xavp(country) = $null;
        sql_xquery("cb", "SELECT C.code FROM CompaniesRelGeoIPCountries G JOIN Countries C ON C.id=G.countryId WHERE G.companyId='$dlg_var(companyId)' AND C.code='$gip2(src=>cc)'", "country");

        if ($xavp(country=>code) != $null) {
            xinfo("[$dlg_var(cidhash)] FILTER-BY-SRC-ADDR: Whitelisted country for company '$dlg_var(companyId)' ($gip2(src=>cc) - $si)\n");
            return;
        }
    }
    #!endif

    if (allow_source_address($dlg_var(companyId))) {
        xinfo("[$dlg_var(cidhash)] FILTER-BY-SRC-ADDR: Valid source $si for company '$dlg_var(companyId)'\n");
        return;
    }

    # Roadwarrior logic
    if ($avp(externalIpCalls) > 0) {
        if (!is_method("INVITE")) {
            xinfo("[$dlg_var(cidhash)] FILTER-BY-SRC-ADDR: non-invite request from roadwarrior '$fU@$fd', allow and proceed\n");
            return;
        }

        # Roadwarrior INVITE request
        get_profile_size("outgoingCallsPerAor", "$fU@$fd", "$var(currentOutgoingCalls)");
        xnotice("[$dlg_var(cidhash)] FILTER-BY-SRC-ADDR: '$fU@$fd' roadwarrior has $var(currentOutgoingCalls) out of $avp(externalIpCalls) outgoing calls\n");

        if ($var(currentOutgoingCalls) < $avp(externalIpCalls)) {
            xinfo("[$dlg_var(cidhash)] FILTER-BY-SRC-ADDR: Allow roadwarrior call\n");
            set_dlg_profile("outgoingCallsPerAor", "$fU@$fd");
            return;
        }
    }

    xwarn("[$dlg_var(cidhash)] FILTER-BY-SRC-ADDR: $si is not valid for company '$dlg_var(companyId)'\n");
    route(IPFILTER_BLOCKED_IP);

    if (!is_method("INVITE") || $dlg_var(type) == "retail") {
        send_reply("403", "Forbidden (invalid IP)");
        exit;
    }
    $rU = 'ipnotallowed';
}

route[PARSE_X_HEADERS] {
    # Set callee
    $var(header) = 'X-Info-Callee';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(callee) = $var(header-value);

    # Extract xcallid
    if (is_present_hf("X-Call-Id")) {
        $dlg_var(xcallid) = $hdr(X-Call-Id);
        xnotice("[$dlg_var(cidhash)] PARSE-X-HEADERS: Related leg: $dlg_var(xcallid)\n");
    }

    # Remove all X headers
    remove_hf_re("^X-");
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if ($(hdr($var(header)){s.len})) {
        $var(header-value) = $hdr($var(header));
    } else {
        xerr("[$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: '$var(header)' not present or not valid, aborting\n");
        send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[IS_INTERNAL] {
    $avp(is_internal) = '0';
    if ($dlg_var(type) != "vpbx") return; # No internal concept for non-vpbx calls
    if ($avp(alwaysApplyTransformations) || $dlg_var(alwaysApplyTransformations)) {
        $dlg_var(alwaysApplyTransformations) = "1";
        return;
    }

    # Is a service?
    if ($(var(number){s.substr,0,1}) == '*') {
        xinfo("[$dlg_var(cidhash)] IS-INTERNAL: $var(number) is an internal service\n");
        $avp(is_internal) = '1';
        return;
    }

    # Is extension in Extensions?
    $xavp(ra) = $null;
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isExtension FROM Extensions E WHERE number='$var(number)' AND companyId='$dlg_var(companyId)'", "ra");
    if ($xavp(ra=>isExtension) == '1') {
        xinfo("[$dlg_var(cidhash)] IS-INTERNAL: $var(number) is an internal extension\n");
        $avp(is_internal) = '1';
        return;
    }

    # Is a friend?
    sql_query("cb", "SELECT id, name, directConnectivity, interCompanyId FROM Friends WHERE companyId = '$dlg_var(companyId)' ORDER BY PRIORITY ASC", "friends");
    if ($dbr(friends=>rows) > 0) {
        $var(i) = 0;
        while($var(i) < $dbr(friends=>rows)) {
            $var(currentFriendId) = $dbr(friends=>[$var(i),0]);
            $var(currentFriendName) = $dbr(friends=>[$var(i),1]);
            $var(directConnectivity) = $dbr(friends=>[$var(i),2]);
            $var(interCompanyId) = $dbr(friends=>[$var(i),3]);
            if ($var(directConnectivity) == "intervpbx") {
                $xavp(ra) = $null;
                sql_xquery("cb", "SELECT COUNT(*) > 0 AS isExtension FROM Extensions E WHERE number='$var(number)' AND companyId='$var(interCompanyId)'", "ra");
                if ($xavp(ra=>isExtension) == '1') {
                    $avp(is_internal) = '1';
                    xinfo("[$dlg_var(cidhash)] IS-INTERNAL: $var(number) is an internal friend ([$var(currentFriendId)] $var(currentFriendName))\n");
                    break;
                }
            } else {
                $xavp(rd) = $null;
                sql_xquery("cb", "SELECT F.id, F.directConnectivity, F.interCompanyId FROM FriendsPatterns FP JOIN Friends F ON FP.friendId=F.id WHERE F.id='$var(currentFriendId)' AND '$var(number)' REGEXP `regExp` ORDER BY F.priority ASC LIMIT 1", "rd");
                if ($xavp(rd=>directConnectivity) != $null) {
                    xinfo("[$dlg_var(cidhash)] IS-INTERNAL: $var(number) is a remote friend ([$var(currentFriendId)] $var(currentFriendName))\n");
                    if ($(var(number){s.substr,0,1}) == '+') {
                        xinfo("[$dlg_var(cidhash)] IS-INTERNAL: $var(number) not considered as internal as starts with +\n");
                    } else {
                        $avp(is_internal) = '1';
                    }
                    break;
                }
            }
            $var(i) = $var(i) + 1;
        }
    }
    sql_result_free("friends");
    if ($avp(is_internal) == '1') return;

    xinfo("[$dlg_var(cidhash)] IS-INTERNAL: $var(number) is an external number\n");

    # Not recognized as internal, must start with '+' if AS talking
    if ($(var(number){s.substr,0,1}) != '+' && $var(is_from_inside)) {
        xerr("[$dlg_var(cidhash)] IS-INTERNAL: Not internal number '$var(number)' not starting with '+', this shouldn't happen\n");
    }

    return;
}

# Authentication prechecks
route[PREAUTH] {
    if (src_ip == myself || $var(is_from_inside)) return;
    if ($avp(wholesaleId) != $null) return; # Wholesale clients don't use domains

    # External subscriber (non-wholesale) calling

    if (from_uri != myself) {
        xwarn("[$dlg_var(cidhash)] AUTH: $fd is not my domain, 403 forbidden\n");
        route(ANTIFLOOD);
        send_reply("403","Forbidden");
        exit;
    }

    if (uri != myself) {
        xwarn("[$dlg_var(cidhash)] AUTH: $rd is not my domain, 404 Not here\n");
        route(ANTIFLOOD);
        send_reply("404", "Invalid domain in R-URI");
        exit;
    }

    # Domain strict checking
    if (!is_uri_host_local()) {
        xwarn("[$dlg_var(cidhash)] AUTH: $rd is my IP but domains should be used, reject\n");
        route(ANTIFLOOD);
        send_reply("488", "Domain needed");
        exit;
    }

    if (!is_from_local()) {
        xwarn("[$dlg_var(cidhash)] AUTH: $fd is my IP but domains should be used, reject\n");
        route(ANTIFLOOD);
        send_reply("488", "Domain needed");
        exit;
    }
}

# Authentication route
route[AUTH] {
    if (src_ip == myself || $var(is_from_inside)) return;
    if ($avp(wholesaleId) != $null) return; # No AUTH for wholesale clients

    # Handle passwordless friends
    if ($avp(endpointType) == "Friends" && $avp(password) == $null) {
        $xavp(friend) = $null;
        sql_xquery("cb", "SELECT ip FROM Friends WHERE id='$avp(endpointId)'", "friend");
        if ($xavp(friend=>ip) == $si) {
            xinfo("[$dlg_var(cidhash)] AUTH: $avp(endpointType)#$avp(endpointId) talking from $xavp(friend=>ip), skip auth");
            return;
        } else {
            xwarn("[$dlg_var(cidhash)] AUTH: $avp(endpointType)#$avp(endpointId) talking from $si instead of $xavp(friend=>ip), forbidden");
            route(ANTIFLOOD);
            send_reply("403", "Forbidden [FS]");
            exit;
        }
    }

    if ($avp(password) == $null) {
        xerr("[$dlg_var(cidhash)] AUTH: No password for $avp(endpointType)#$avp(endpointId), error");
        route(ANTIFLOOD);
        send_reply("403", "Forbidden [NP]");
        exit;
    }

    if (is_method("REGISTER") || from_uri==myself) {
        # authenticate requests
        $var(skipAntiflood) = 0;
        if(!pv_auth_check("$fd", "$avp(password)", "0", "1")) {
            switch($rc) {
                case -2:
                    xnotice("[$dlg_var(cidhash)] AUTH: Auth needed ($fu from $proto:$si) - invalid_password\n");
                    route(BAD_CREDENTIALS);
                    break;
                case -3:
                    xnotice("[$dlg_var(cidhash)] AUTH: Auth needed ($fu from $proto:$si) - invalid_user\n");
                    route(BAD_CREDENTIALS);
                    break;
                case -5:
                    xnotice("[$dlg_var(cidhash)] AUTH: Auth needed ($fu from $proto:$si) - no_credentials\n");
                    $var(skipAntiflood) = 1;
                    break;
                default:
                    xnotice("[$dlg_var(cidhash)] AUTH: Auth needed ($fu from $proto:$si) - $rc\n");
            }
            if (!$var(skipAntiflood)) route(ANTIFLOOD);
            auth_challenge("$fd", "0");
            exit;
        }

        xinfo("[$dlg_var(cidhash)] AUTH: Authentication OK\n");
        # user authenticated - remove auth header
        consume_credentials();
    }

    return;
}

route[GET_INFO_FROM_ENDPOINT] {
    if ($avp(wholesaleId) != $null) return; # No endpoint for wholesale clients

    $xavp(endpoint) = $null;

    if ($avp(endpointType) == "Terminals") {
        sql_xquery("cb", "SELECT U.id, E.number AS extension, U.externalIpCalls, U.maxCalls, T.companyId, U.transformationRuleSetId, U.rejectCallMethod, U.multiContact, T.t38Passthrough, T.rtpEncryption FROM Users U JOIN Terminals T ON U.terminalId=T.id JOIN Extensions E ON U.extensionId=E.id WHERE T.id='$avp(endpointId)'", "endpoint");
        if ($xavp(endpoint=>extension) == $null) {
            send_reply("404", "Not Here [TUE]");
            exit;
        }

        $avp(extension) = $xavp(endpoint=>extension); # used in FILTER_BY_SRC_ADDR
        $avp(externalIpCalls) = $xavp(endpoint=>externalIpCalls); # used in FILTER_BY_SRC_ADDR
        $avp(maxCalls) = $xavp(endpoint=>maxCalls); # used in GET_CALL_INFO
        $avp(rejectCallMethod) = $xavp(endpoint=>rejectCallMethod); # used in onreply_route GENERIC_REPLY
    } else if ($avp(endpointType) == "ResidentialDevices") {
        sql_xquery("cb", "SELECT id, companyId, transformationRuleSetId, t38Passthrough, maxCalls, rtpEncryption, multiContact FROM ResidentialDevices WHERE id='$avp(endpointId)'", "endpoint");
        $avp(maxCalls) = $xavp(endpoint=>maxCalls); # used in GET_CALL_INFO
    } else if ($avp(endpointType) == "Friends") {
        sql_xquery("cb", "SELECT id, companyId, transformationRuleSetId, t38Passthrough, alwaysApplyTransformations, rtpEncryption, from_user, multiContact FROM Friends WHERE id='$avp(endpointId)'", "endpoint");
        $avp(maxCalls) = 0; # used in GET_CALL_INFO
        $avp(alwaysApplyTransformations) = $xavp(endpoint=>alwaysApplyTransformations); # used in IS_INTERNAL
        if ($xavp(endpoint=>from_user) != $null) {
            $avp(friendFromUser) = $(xavp(endpoint=>from_user){s.trim}); # used in SET_PAI
        }
    } else {
        sql_xquery("cb", "SELECT id, companyId, transformationRuleSetId, t38Passthrough, rtpEncryption, multiContact FROM RetailAccounts WHERE id='$avp(endpointId)'", "endpoint");
        $avp(maxCalls) = 0; # used in GET_CALL_INFO
    }

    $avp(companyId) = $xavp(endpoint=>companyId); # used in CLASSIFY and FILTER_BY_SRC_ADDR
    $avp(objectId) = $xavp(endpoint=>id); # used in GET_CALL_INFO
    $avp(endpointTransformationRuleSetId) = $xavp(endpoint=>transformationRuleSetId); # used in GET_CALL_INFO
    $avp(t38Passthrough) = $xavp(endpoint=>t38Passthrough); # used in DISPATCH_TO_TRUNKS
    $avp(rtpEncryption) = $xavp(endpoint=>rtpEncryption); # used in GET_CALL_INFO
    $avp(multiContact) = $xavp(endpoint=>multiContact); # used in REGISTER
}

# Sets $avp(endpointType), $avp(endpointId) and $avp(password)
route[GET_ENDPOINT] {
    if ($avp(wholesaleId) != $null) return; # No endpoint for wholesale clients

    $var(found) = 0;

    if ($var(is_from_inside)) {
        $var(username) = $tU;
        $var(domain) = $td;
    } else {
        $var(username) = $fU;
        $var(domain) = $fd;
    }

    $var(aor) = $var(username) + '@' + $var(domain);

    while (!$var(found)) {
        # cached?
        if ($sht(aors=>$var(aor)) != $null) {
            $xavp(endpoint) = $null;
            sql_xquery("cb", "SELECT T.id, T.password FROM $sht(aors=>$var(aor)) T JOIN Domains D ON D.id=T.domainId WHERE T.name='$var(username)' AND D.domain='$var(domain)'", "endpoint");
            if ($xavp(endpoint=>id) != $null) {
                $var(found) = 1;
                break;
            }
            $sht(aors=>$var(aor)) = $null;
        }

        # terminal
        $xavp(endpoint) = $null;
        sql_xquery("cb", "SELECT T.id, T.password FROM Terminals T JOIN Domains D ON D.id=T.domainId WHERE T.name='$var(username)' AND D.domain='$var(domain)'", "endpoint");
        if ($xavp(endpoint=>id) != $null) {
            $sht(aors=>$var(aor)) = "Terminals";
            $var(found) = 1;
            break;
        }

        # retail
        $xavp(endpoint) = $null;
        sql_xquery("cb", "SELECT T.id, T.password FROM RetailAccounts T JOIN Domains D ON D.id=T.domainId WHERE T.name='$var(username)' AND D.domain='$var(domain)'", "endpoint");
        if ($xavp(endpoint=>id) != $null) {
            $sht(aors=>$var(aor)) = "RetailAccounts";
            $var(found) = 1;
            break;
        }

        # friend
        $xavp(endpoint) = $null;
        sql_xquery("cb", "SELECT T.id, T.password FROM Friends T JOIN Domains D ON D.id=T.domainId WHERE T.name='$var(username)' AND D.domain='$var(domain)'", "endpoint");
        if ($xavp(endpoint=>id) != $null) {
            $sht(aors=>$var(aor)) = "Friends";
            $var(found) = 1;
            break;
        }

        # residential
        $xavp(endpoint) = $null;
        sql_xquery("cb", "SELECT T.id, T.password FROM ResidentialDevices T JOIN Domains D ON D.id=T.domainId WHERE T.name='$var(username)' AND D.domain='$var(domain)'", "endpoint");
        if ($xavp(endpoint=>id) != $null) {
            $sht(aors=>$var(aor)) = "ResidentialDevices";
            $var(found) = 1;
            break;
        }

        break;
    }

    if (!$var(found)) {
        route(ANTIFLOOD);
        send_reply("404", "Not Here [GE]");
        exit;
    }

    $avp(endpointType) = $sht(aors=>$var(aor));
    $avp(endpointId) = $xavp(endpoint=>id);
    $avp(password) = $xavp(endpoint=>password);

    xinfo("[$dlg_var(cidhash)] GET-ENDPOINT: $avp(endpointType)#$avp(endpointId)");
}

route[BAD_CREDENTIALS] {
    if ($sht(badauthcnt=>$fU@$fd::$si) == $null) {
        # New failing source, add key to counter htable
        xinfo("[$dlg_var(cidhash)] BAD-CREDENTIALS: $fU@$fd::$si => 1");
        $sht(badauthcnt=>$fU@$fd::$si) = 1;
        return;
    }

    # Existing failing source, increase counter
    $var(currentVal) = $shtinc(badauthcnt=>$fU@$fd::$si);
    xinfo("[$dlg_var(cidhash)] BAD-CREDENTIALS: $fU@$fd::$si => $var(currentVal)");

    # Check if limit exceeded
    if ($var(currentVal) >= 100) {
        xwarn("[$dlg_var(cidhash)] BAD-CREDENTIALS: $fU@$fd::$si banned for 12 hours)");
        $sht(srcban=>$fU@$fd::$si) = 1;
        route(ANTIBRUTEFORCE_BLOCKED_IP);
        $sht(badauthcnt=>$fU@$fd::$si) = 80; # Start from 80 after ban expiration (faster re-ban)
    }
}

# Handle within-dialog messages
route[WITHINDLG] {
    if (!$dlg_var(confirmed) && is_method("UPDATE|INVITE")) drop;

    route(ADAPT_CALLER);

    #!ifdef WITH_REALTIME
    if (is_method("UPDATE|INVITE") && $var(is_from_inside)) {
        $var(rtEvent) = 'UpdateCLID';
        route(REALTIME);
    }
    #!endif

    route(ADAPT_REFERTO);

    # Fix overridden R-URI if needed
    if (!$var(is_from_inside) && src_ip != myself) {
        route(FIX_RURI);
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(RURIALIAS);
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        } else if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("REFER")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(REFER);
        } else if (is_method("INFO")) {
            route(INFO);
        } else if (is_method("MESSAGE")) {
            route(MESSAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
    } else {
        if (is_method("SUBSCRIBE") && uri == myself) {
            # in-dialog subscribe requests
            route(PRESENCE);
            exit;
        }

        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        send_reply("404","Not here");
    }
}

route[REFER] {
    if (is_present_hf("Refer-to")) {
        xinfo("[$dlg_var(cidhash)] REFER: $fU transfers call to $hdr(Refer-to)\n");
        $dlg_var(referee) = $hdr(Refer-to);
    } else {
        xwarn("[$dlg_var(cidhash)] REFER: No Refer-To header found, relay\n");
    }

    return;
}

route[INFO] {
    if (is_present_hf("Record")) {
        xinfo("[$dlg_var(cidhash)] INFO: On demand record using INFO, proceed\n");
        route(ONDEMANDRECORD);
    } else {
        xinfo("[$dlg_var(cidhash)] INFO: INFO without Record header, relay\n");
    }

    return;
}

route[MESSAGE] {
    if (!$var(is_from_inside)) return;

    if (search_body("on-demand-record")) {
        xinfo("[$dlg_var(cidhash)] MESSAGE: On demand record using MESSAGE, proceed\n");
        route(ONDEMANDRECORD);
    } else {
        xinfo("[$dlg_var(cidhash)] MESSAGE: MESSAGE without on-demand-record body, relay\n");
    }

    return;
}

route[ONDEMANDRECORD] {
    if (!$dlg_var(onDemandRecord)) {
        xwarn("[$dlg_var(cidhash)] ONDEMANDRECORD: On demand record not enabled, ignore\n");
        send_reply("403", "Forbidden");
        exit;
    }

    if ($dlg_var(noRecording)) {
        xwarn("[$dlg_var(cidhash)] ONDEMANDRECORD: On demand record not allowed for number '$dlg_var(callee)', ignore\n");
        send_reply("403", "Forbidden");
        exit;
    }

    $var(callid) = "call-id=users-" + $dlg_var(direction) + '-' + $dlg_var(callid);

    if ($dlg_var(recording) != 'yes') {
        xnotice("[$dlg_var(cidhash)] ONDEMANDRECORD: Start recording call\n");
        start_recording("$var(callid)");
        $dlg_var(recording) = 'yes';

        send_reply("200", "Record On");
    } else {
        xnotice("[$dlg_var(cidhash)] ONDEMANDRECORD: Stop recording call\n");
        stop_recording("$var(callid)");
        $dlg_var(recording) = 'no';

        send_reply("200", "Record Off");
    }

    exit;
}

# URI update for requests where alias found
route[RURIALIAS] {
    if(isdsturiset()) {
        return;
    }

    handle_ruri_alias();
    switch ($rc) {
    case -1:
        xerr("[$dlg_var(cidhash)] RURIALIAS: Failed to handle alias of R-URI $ru\n");
        send_reply("400", "Bad request");
        exit;
    case 1:
        # ;alias parsed
        break;
    case 2:
        # ;alias not found
        break;
    };

    return;
}

# Relay request
route[RELAY] {
    if ($branch(count) == $null) {
        if ($(du{uri.host}) != $null) {
            xnotice("[$dlg_var(cidhash)] RELAY: Relaying to $ru via $du (du, $dP)\n");
        } else {
            xnotice("[$dlg_var(cidhash)] RELAY: Relaying to $ru (ru)\n");
        }
    }

    # Common for every transaction
    t_on_reply("MANAGE_REPLY");
    t_on_branch("MANAGE_BRANCH");

    #!ifdef WITH_REALTIME
    if (is_request() && is_method("INVITE") && !has_totag()) {
        $var(rtEvent) = "Trying";
        route(REALTIME);
    }
    #!endif

    if (!t_relay())
        sl_reply_error();

    exit;
}

route[ANTIFLOOD] {
#!ifdef WITH_ANTIFLOOD
    # Inside request
    if (src_ip == myself || $var(is_from_inside)) return;

    # Evaluate PIKE
    if (!pike_check_req()) {
        xwarn("[$dlg_var(cidhash)] ANTIFLOOD: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
        $sht(ipban=>$si) = 1;
        route(ANTIFLOOD_BLOCKED_IP);
        exit;
    }
#!endif

    return;
}

route[ANTIBRUTEFORCE_BLOCKED_IP] {
    sql_xquery("cb", "SELECT T.companyId, C.brandId FROM $avp(endpointType) T JOIN Companies C ON T.companyId=C.id WHERE T.id='$avp(endpointId)'", "bf");

    $var(bannedAor) = $fU + '@' + $fd;

    sql_xquery("cb", "SELECT COUNT(*) > 0 AS banned FROM BannedAddresses WHERE aor='$var(bannedAor)' AND ip='$si' AND blocker='antibruteforce' AND companyId='$xavp(bf=>companyId)'", "ra");
    if ($xavp(ra=>banned) == '1') {
        sql_xquery("cb", "UPDATE BannedAddresses SET lastTimeBanned=NOW() WHERE aor='$var(bannedAor)' AND ip='$si' AND blocker='antibruteforce' AND companyId='$xavp(bf=>companyId)'", "rb");
    } else {
        sql_xquery("cb", "INSERT INTO BannedAddresses (aor, ip, blocker, brandId, companyId, lastTimeBanned) VALUES ('$var(bannedAor)', '$si', 'antibruteforce', '$xavp(bf=>brandId)', '$xavp(bf=>companyId)', NOW())", "rb");
    }
}

route[ANTIFLOOD_BLOCKED_IP]{
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS banned FROM BannedAddresses WHERE ip='$si' AND blocker='antiflood'", "ra");

    if ($xavp(ra=>banned) == '1') {
        # Not first time, just update timestamp
        xinfo("[$dlg_var(cidhash)] ANTIFLOOD-BLOCKED-IP: Blocking again $si\n");
        sql_xquery("cb", "UPDATE BannedAddresses SET lastTimeBanned=NOW() WHERE ip='$si' AND blocker='antiflood'", "rb");
    } else {
        # First time, insert
        xinfo("[$dlg_var(cidhash)] ANTIFLOOD-BLOCKED-IP: First time blocking $si\n");
        sql_xquery("cb", "INSERT INTO BannedAddresses (ip, blocker, lastTimeBanned) VALUES ('$si', 'antiflood', NOW())", "rb");
    }
}

route[IPFILTER_BLOCKED_IP]{
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS banned FROM BannedAddresses WHERE ip='$si' AND blocker='ipfilter' AND brandId=$dlg_var(brandId) AND companyId=$dlg_var(companyId)", "ra");

    if ($xavp(ra=>banned) == '1') {
        # Not first time, just update timestamp
        xinfo("[$dlg_var(cidhash)] IPFILTER-BLOCKED-IP: Blocking again $si (b$dlg_var(brandId)c$dlg_var(companyId))\n");
        sql_xquery("cb", "UPDATE BannedAddresses SET lastTimeBanned=NOW() WHERE ip='$si' AND blocker='ipfilter' AND brandId=$dlg_var(brandId)", "rb");
    } else {
        # First time, insert
        xinfo("[$dlg_var(cidhash)] IPFILTER-BLOCKED-IP: First time blocking $si (b$dlg_var(brandId)c$dlg_var(companyId))\n");
        sql_xquery("cb", "INSERT INTO BannedAddresses (ip, brandId, companyId, blocker, lastTimeBanned) VALUES ('$si', '$dlg_var(brandId)', '$dlg_var(companyId)', 'ipfilter', NOW())", "rb");
    }
}

# Handle SIP registrations
route[REGISTER] {
    if(!is_method("REGISTER")) return;

    if(isflagset(FLT_NATS)) {
        setbflag(FLB_NATB);
        # Enable SIP NAT pinging
        if ($proto == 'udp') {
            setbflag(FLB_NATSIPPING);
        }
    }

    # Store in kam_users_location_attrs used transport to retrieve it in lookup
    $xavp(ulattrs=>transport) = $proto;

    if (is_present_hf("Contact")) {
        $var(contact_uri) = @contact.uri;
    }

    if ($avp(multiContact)) {
        xinfo("[$dlg_var(cidhash)] REGISTER: Keep 10 contacts per AoR (multiContact: on)\n");
        save("kam_users_location");
    } else {
        xnotice("[$dlg_var(cidhash)] REGISTER: Keep just one contact per AoR (multiContact: off)\n");
        save("kam_users_location", "0x04");
    }

    switch ($?) {
        case -1:
            xerr("[$dlg_var(cidhash)] REGISTER: Something went wrong when saving location\n");
            sl_reply_error();
            break;
        case 1:
            xnotice("[$dlg_var(cidhash)] REGISTER: Contacts inserted ($tu: $var(contact_uri))\n");
            break;
        case 2:
            xnotice("[$dlg_var(cidhash)] REGISTER: Contacts updated ($tu: $var(contact_uri))\n");
            break;
        case 3:
            xnotice("[$dlg_var(cidhash)] REGISTER: Contacts deleted ($tu: $var(contact_uri))\n");
            break;
        case 4:
            xnotice("[$dlg_var(cidhash)] REGISTER: Contacts returned\n");
            break;
    };

    exit;
}

# Detect NAT
route[NATDETECT] {
    # 64 - Test if the source connection of signaling is WS
    if (nat_uac_test(64)) {
        route(WSFIX);
        return;
    }
    force_rport();

    if (nat_uac_test("18")) {
        xinfo("[$dlg_var(cidhash)] NATDETECT: NAT detected\n");
        setflag(FLT_NATS);

        if (is_method("REGISTER")) {
            fix_nated_register();
        } else if (is_method("SUBSCRIBE")) {
            fix_nated_contact();
        } else {
            if(is_first_hop()) {
                # Sets ;alias only if received ip and port differ from those in contact URI
                if (is_present_hf("Contact") && !set_contact_alias()) {
                   xerr("[$dlg_var(cidhash)] NATDETECT: Error in aliasing contact $ct\n");
                   route(ANTIFLOOD);
                   send_reply("400", "Bad request");
                   exit;
                }
            }
        }
    }
}

route[WSFIX] {
    if ($dlg_var(type) == 'wholesale') {
       xwarn("[$dlg_var(cidhash)] WSFIX: Wholesale using WSS\n");
       send_reply("400", "Invalid transport");
       exit;
    }
    xinfo("[$dlg_var(cidhash)] WSFIX: Websockets detected, fix contact\n");
    # Do NAT traversal stuff for requests from a WebSocket
    # connection - even if it is not behind a NAT!
    # This won't be needed in the future if Kamailio and the
    # WebSocket client support Outbound and Path.
    force_rport();
    if (is_method("REGISTER")) {
        fix_nated_register();
    } else if (is_present_hf("Contact") && !set_contact_alias()) {
        if($dlg_var(nolog) != "1") xerr("[$dlg_var(cidhash)] WSFIX: Error aliasing contact <$ct>\n");
        send_reply("400", "Bad Request");
        exit;
    }
    return;
}

# Handle NAT
route[NATMANAGE] {
    # RTP handling is always enforced
    route(RTPENGINE);

    # Set FLB_NATB? Only in within-dialog request with nat=yes on Route header initiated by us
    if (is_request() && has_totag() && check_route_param("nat=yes") && $var(is_from_inside)) {
       setbflag(FLB_NATB);
    }

    # Return unless FLT_NATS or FLB_NATB are set
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        return;
    }

    # Add nat=yes in record-route? Only in initial requests when called from branch_route
    if (is_request() && !has_totag() && t_is_branch_route()) {
        add_rr_param(";nat=yes");
    }

    # Add contact alias? Only to replies with NATB set and first hop
    if (is_reply() && isbflagset(FLB_NATB) && is_first_hop()) {
        # Sets ;alias only if received ip and port differ from those in contact URI
        if (is_present_hf("Contact") && !set_contact_alias()) {
           xerr("[$dlg_var(cidhash)] NATMANAGE: Error in aliasing contact $ct\n");
           send_reply("400", "Bad request");
           exit;
        }
    }
}

# This route sets following dlg_vars: brandId, companyId, type
route[CLASSIFY] {
    if ($var(is_from_inside)) {
        $var(header) = 'X-Info-BrandId';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(brandId) = $var(header-value);

        $var(header) = 'X-Info-CompanyId';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(companyId) = $var(header-value);

        $var(header) = 'X-Info-Type';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(type) = $var(header-value);
    } else {
        if ($avp(wholesaleId) != $null) {
            $avp(companyId) = $avp(wholesaleId);
        }

        sql_xquery("cb", "SELECT brandId, type FROM Companies WHERE id='$avp(companyId)'", "ra");
        $dlg_var(brandId) = $xavp(ra=>brandId);
        $dlg_var(companyId) = $avp(companyId);
        $dlg_var(type) = $xavp(ra=>type);
    }

    # Generate CDR only for vpbx calls
    if ($dlg_var(type) != "vpbx") {
        $dlg_var(nocdr) = "1";
    }

    xnotice("[$dlg_var(cidhash)] CLASSIFY: $dlg_var(type) call $avp(endpointType)#$avp(endpointId) (b$dlg_var(brandId):c$dlg_var(companyId))");
}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    if ($var(is_from_inside)) {
        # IvozProvider talking
        $dlg_var(direction) = 'inbound';

        # -- Set caller
        # dlg_var(caller) will be set in all cases in ADAPT_CALLER (except 404 in retail call forwards that will be set in APPLY_RETAIL_CFW)
    } else {
        # External world talking
        $dlg_var(direction) = 'outbound';

        # -- Set caller
        # Calls from terminals will have dlg_var(caller) set in GENERATE_PUBLISH
        # Calls from friends/residentials/retails with PAI/RPID have dlg_var(caller) set in ADAPT_CALLER
        # Calls from wholesale have dlg_var(caller) set in ADAPT_CALLER
        # Calls from friends/residentials without PAI/RPID will have dlg_var(caller) empty
        # Calls from retails without PAI/RPID will have dlg_var(caller) set to fallback DDI

        # -- Set caller
        $dlg_var(callee) = $rU;
    }

    route(CHECK_SPECIAL);

    $dlg_var(callid) = $ci;

    if (is_present_hf("Referred-by")) {
        $dlg_var(referrer) = $(hdr(Referred-by){nameaddr.uri}{uri.user});
    }
}

route[CHECK_SPECIAL] {
    $var(specialNumber) = 0;

    if ($var(is_from_inside)) return;

    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isBrandSpecial FROM SpecialNumbers WHERE numberE164='$rU' AND disableCDR='1' AND brandId='$dlg_var(brandId)'", "ra");

    if ($xavp(ra=>isBrandSpecial) == '1') {
        xnotice("[$dlg_var(cidhash)] CHECK-SPECIAL: Calling to a brand special number '$rU'\n");
        $var(specialNumber) = 1;
    }

    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isGlobalSpecial FROM SpecialNumbers WHERE numberE164='$rU' AND disableCDR='1' AND brandId IS NULL", "rb");
    if ($xavp(rb=>isGlobalSpecial) == '1') {
        xnotice("[$dlg_var(cidhash)] CHECK-SPECIAL: Calling to a global special number '$rU'\n");
        $var(specialNumber) = 1;
    }

    if ($var(specialNumber)) {
        $dlg_var(nocdr) = "1"; # Skip this call in CDRs
        $dlg_var(noRecording) = '1'; # Skip recording for this call
        $dlg_var(skipRealtime) = 'yes'; # Skip this call in realtime
    }
}

route[SAVE_CONTACT] {
    if (!is_present_hf("Contact")) return;
    if (!is_method("INVITE")) return;

    if ($ct =~ "<.*>") {
        # Contact has < >
        $var(contact) = $(ct{s.select,0,>});
        $var(contact) = $(var(contact){s.select,1,<});
    } else {
        $var(contact) = $ct;
    }

    if (is_request()) {
        if ($sht(dialogs=>$ci::contact::$ft) != $null) return;
        $sht(dialogs=>$ci::contact::$ft) = $var(contact);
        xinfo("[$dlg_var(cidhash)] SAVE-CONTACT: Saving '$var(contact)' for $ci::contact::$ft\n");
    } else {
        if ($sht(dialogs=>$ci::contact::$tt) != $null) return;
        $sht(dialogs=>$ci::contact::$tt) = $var(contact);
        xinfo("[$dlg_var(cidhash)] SAVE-CONTACT: Saving '$var(contact)' for $ci::contact::$tt\n");
    }
}

route[FIX_RURI] {
    if ($sht(dialogs=>$ci::contact::$tt) == $null) return; # No saved contact found
    if (uri == $sht(dialogs=>$ci::contact::$tt)) return; # R-URI is OK

    xwarn("[$dlg_var(cidhash)] FIX-RURI: Fix overridden contact ($ru -> $sht(dialogs=>$ci::contact::$tt))\n");
    $ru = $sht(dialogs=>$ci::contact::$tt);
}

#!ifdef WITH_REALTIME
route[REALTIME] {
    if ($dlg_var(skipRealtime) == "yes") return;

    # Reset JSON value
    $var(rtValue) = 0;

    # Common fields
    jansson_set("string", "Event", "$var(rtEvent)", "$var(rtValue)");
    jansson_set("integer", "Time", "$TS", "$var(rtValue)");
    jansson_set("string", "Call-ID", "$dlg_var(callid)", "$var(rtValue)");

    if ($var(rtEvent) == 'UpdateCLID') {
        route(GET_CALLER);
        if ($var(number) == $dlg_var(party)) return; # No CLID change, leave

        jansson_set("string", "Party", "$var(number)", "$var(rtValue)");

        # Save to avoid events for same CLID
        $dlg_var(party) = $var(number);
    } else {
        # Avoid going backwards or repeating state (Trying > Proceeding > Early > Confirmed > Terminated)
        if ($dlg_var(lastCallState) != $null) {
            switch ($var(rtEvent)) {
                case "Trying":
                    return;
                case "Proceeding":
                    if ($(dlg_var(lastCallState){s.int}) >= 1) return;
                    $dlg_var(lastCallState) = "1";
                    break;
                case "Early":
                    if ($(dlg_var(lastCallState){s.int}) >= 2) return;
                    $dlg_var(lastCallState) = "2";
                    break;
                case "Confirmed":
                    if ($(dlg_var(lastCallState){s.int}) >= 3) return;
                    $dlg_var(lastCallState) = "3";
                    break;
                case "Terminated":
                    if ($(dlg_var(lastCallState){s.int}) >= 4) return;
                    $dlg_var(lastCallState) = "4";
                    break;
            };
        }

        if ($var(rtEvent) == 'Trying') {
            route(RT_NEWCALL);
            $dlg_var(lastCallState) = "0";
        }
    }

    # Publish to redis
    if ($dlg_var(rtChannel) != $null) {
        jansson_set("string", "ID", "$dlg_var(rtId)", "$var(rtValue)");
        if (redis_cmd("realtime", "PUBLISH %s %s", "$dlg_var(rtChannel)", "$var(rtValue)", "r")) {
            xnotice("[$dlg_var(cidhash)] REALTIME: $dlg_var(rtChannel) -> $var(rtValue)");
        } else {
            xerr("[$dlg_var(cidhash)] REALTIME: $dlg_var(rtChannel) -> $var(rtValue)");
        }
    }
}

route[RT_NEWCALL] {
    # Set brand, company and direction
    sql_xquery("cb", "SELECT C.name AS companyName, B.name AS brandName FROM Companies C JOIN Brands B ON B.id=C.brandId WHERE C.id='$dlg_var(companyId)'", "names");
    jansson_set("string", "Brand", "$xavp(names=>brandName)", "$var(rtValue)");
    jansson_set("string", "Company", "$xavp(names=>companyName)", "$var(rtValue)");
    jansson_set("string", "Direction", "$dlg_var(direction)", "$var(rtValue)");

    # Set rtChannel, owner and ownerName
    if ($dlg_var(residentialDeviceId) != $null) {
        sql_xquery("cb", "SELECT name FROM ResidentialDevices WHERE id=$dlg_var(residentialDeviceId)", "rd");
        $dlg_var(rtChannel) = 'users' + ':b' + $dlg_var(brandId) + ':c' + $dlg_var(companyId) + ':r' + $dlg_var(residentialDeviceId) + ':' + $ci;
        jansson_set("string", "Owner", "$xavp(rd=>name)", "$var(rtValue)");
    } else if ($dlg_var(retailAccountId) != $null) {
        sql_xquery("cb", "SELECT name FROM RetailAccounts WHERE id=$dlg_var(retailAccountId)", "ra");
        $dlg_var(rtChannel) = 'users' + ':b' + $dlg_var(brandId) + ':c' + $dlg_var(companyId) + ':rt' + $dlg_var(retailAccountId) + ':' + $ci;
        jansson_set("string", "Owner", "$xavp(ra=>name)", "$var(rtValue)");
    } else if ($dlg_var(userId) != $null) {
        sql_xquery("cb", "SELECT CONCAT(E.number, ' - ', U.name, ' ', U.lastname) AS userName FROM Users U JOIN Extensions E ON E.id=U.extensionId WHERE U.id=$dlg_var(userId)", "u");
        $dlg_var(rtChannel) = 'users' + ':b' + $dlg_var(brandId) + ':c' + $dlg_var(companyId) + ':u' + $dlg_var(userId) + ':' + $ci;
        jansson_set("string", "Owner", "$xavp(u=>userName)", "$var(rtValue)");
    } else if ($dlg_var(friendId) != $null) {
        sql_xquery("cb", "SELECT name FROM Friends WHERE id=$dlg_var(friendId)", "f");
        $dlg_var(rtChannel) = 'users' + ':b' + $dlg_var(brandId) + ':c' + $dlg_var(companyId) + ':f' + $dlg_var(friendId) + ':' + $ci;
        jansson_set("string", "Owner", "$xavp(f=>name)", "$var(rtValue)");
    } else {
        # wholesale
        $dlg_var(rtChannel) = 'users' + ':b' + $dlg_var(brandId) + ':c' + $dlg_var(companyId) + ':w' + ':' + $ci;
        jansson_set("string", "Owner", "$dlg_var(caller)", "$var(rtValue)");
    }

    # Set party
    if ($dlg_var(direction) == 'inbound') {
        route(GET_CALLER);
        $dlg_var(party) = $var(number);
    } else {
        $dlg_var(party) = $dlg_var(callee);
    }
    jansson_set("string", "Party", "$dlg_var(party)", "$var(rtValue)");

    # Calculate session-id
    $dlg_var(rtId) = $(dlg_var(rtChannel){s.md5}{s.substr,0,8});
}
#!endif

# Reply generic route (all replies goes through this route)
onreply_route {
    # Silent NAT-handling OPTIONS replies
    if (is_method("OPTIONS") && $fu == "sip:pinger@kamailio.org") exit;

    # Silent KDMQ replies
    if (is_method("KDMQ")) exit;

    route(CIDHASH);
    xnotice("[$dlg_var(cidhash)] Response: $rs $rr from $fu ($cs $rm - $proto:$si:$sp)\n");
    route(IS_FROM_INSIDE);
}

# Reply generic route (additional, for all replies)
onreply_route[MANAGE_REPLY] {
    # Control call limit if necessary
    if ($avp(AoR) != $null && !is_in_profile("callsPerAor", "$avp(AoR)")) {
        set_dlg_profile("callsPerAor", "$avp(AoR)");
        get_profile_size("callsPerAor", "$avp(AoR)", "$var(currentCalls)");
        xnotice("[$dlg_var(cidhash)] MANAGE_REPLY: '$avp(AoR)' has $var(currentCalls) calls now\n");
    }

    # Account user's missed calls if ringing
    if (is_method("INVITE") && t_check_status("180") && !$var(is_from_inside)) {
        setflag(FLT_ACCMISSED);
    }

    # 486/480 vs 600/603 in parallel-forking scenarios
    # -- treat 480/486 as 600
    if (is_method("INVITE") && t_check_status("(480)|(486)") && !$var(is_from_inside) && $avp(rejectCallMethod) == "600") {
        t_cancel_branches("others");
        exit;
    }
    # -- treat 600/603 as 486
    if (is_method("INVITE") && t_check_status("(600)|(603)") && !$var(is_from_inside) && $avp(rejectCallMethod) == "486") {
        t_set_disable_6xx(1);
        exit;
    }

    if (is_present_hf("P-Asserted-Identity") || is_present_hf("Remote-Party-ID")) {
        route(ADAPT_CALLER);
    }

    if (is_method("INVITE") && t_check_status("3[0-9]{2}")) {
        route(ADAPT_CONTACT);
    }

    if (t_check_status("2[0-9]{2}") && ($var(is_from_inside) == 1)) {
        route(SAVE_CONTACT);
    }

    # Manage NAT
    if (t_check_status("[12][0-9]{2}")) {
        route(NATMANAGE);
    }

    #!ifdef WITH_REALTIME
    if (is_method("INVITE") && t_check_status("1[0-9]{2}")) {
        if (has_totag()) {
            $var(rtEvent) = "Early";
        } else {
            $var(rtEvent) = "Proceeding";
        }
        route(REALTIME);
    }
    #!endif

    # Manage WS
    if (nat_uac_test(64)) { # 64 - Test if the source connection of signaling is WS
        # Do NAT traversal stuff for replies to a WebSocket connection
        # - even if it is not behind a NAT!
        # This won't be needed in the future if Kamailio and the
        # WebSocket client support Outbound and Path.
        if (is_present_hf("Contact"))
            set_contact_alias();
    }
}

failure_route[MANAGE_FAILURE] {
    xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE: t_is_canceled, exit here\n");
        exit;
    }

    route(IS_FROM_INSIDE);
    route(NATMANAGE);
}

failure_route[MANAGE_FAILURE_RETAIL] {
    xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-RETAIL: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-RETAIL: t_is_canceled, exit here\n");
        exit;
    }

    route(IS_FROM_INSIDE);
    route(NATMANAGE);

    # Handle 408 to retail accounts and apply call-forward if necessary
    if (t_branch_timeout() && !t_branch_replied()) {
        xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-RETAIL: 408 calling to retail account with call-forward configured");
        #!ifdef WITH_REALTIME
        $var(rtEvent) = 'Terminated';
        route(REALTIME);
        #!endif
        route(PREPARE_RETAIL_CFW);
        route(RELAY);
    }
}

failure_route[MANAGE_FAILURE_AS] {
    xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    route(IS_FROM_INSIDE);
    route(NATMANAGE);

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS '$avp(AVP_DST)' as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            t_on_failure("MANAGE_FAILURE_AS");
            route(RELAY);
        } else {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Route for branching: Only for INVITEs and BYEs (fork-able)
branch_route[MANAGE_BRANCH] {
    if ($branch(count) != $null) {
        if ($(du{uri.host}) != $null) {
            xnotice("[$dlg_var(cidhash)] MANAGE_BRANCH: new branch [$T_branch_idx] to $ru via $du (du, $dP)\n");
        } else {
            xnotice("[$dlg_var(cidhash)] MANAGE_BRANCH: new branch [$T_branch_idx] to $ru\n");
        }
    }

    #!ifdef WITH_MULTISOCKET
    if ($fs != $null && $fs != "udp:" + $sel(cfg_get.address.main) + ":5060") {
        $dlg_var(extra_socket) = $(fs{s.select,1,:});
        xinfo("[$dlg_var(cidhash)] MANAGE_BRANCH: Calling to a UAC through $dlg_var(extra_socket)\n");
    }
    #!endif

    route(IS_FROM_INSIDE);

    # Prepare call
    if ($var(is_from_inside) && !has_totag() && is_method("INVITE")) {
        if ($avp(apply_cfwd) == 'yes') {
            route(APPLY_RETAIL_CFW);
        } else {
            route(ADAPT_CALLER);
            route(ADAPT_DIVERSION);
            route(ADAPT_RURI_OUT);
        }
    }

    route(TRANSPORT_DETECT);
    route(NATMANAGE);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    if(isbflagset(FLB_WEBSOCKETS)) {
        xnotice("[$dlg_var(cidhash)] Dialog involving WSS started\n");
        $dlg_var(ws) = 'yes';
    }

    #!ifdef WITH_REALTIME
    $var(rtEvent) = "Confirmed";
    route(REALTIME);
    if ($dlg_var(direction) == 'outbound') {
        $var(rtEvent) = "UpdateCLID";
        route(REALTIME);
    }
    #!endif

    if ($dlg_var(xcallid) != $null && $sht(dmq=>$dlg_var(xcallid)::user) == $null && $sht(dmq=>$dlg_var(xcallid)::friend) == $null) {
        if ($dlg_var(userId) != $null) {
            $sht(dmq=>$dlg_var(xcallid)::user) = $dlg_var(userId);
        }
        if ($dlg_var(friendId) != $null) {
            $sht(dmq=>$dlg_var(xcallid)::friend) = $dlg_var(friendId);
        }
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    sht_rm_name_re("dialogs=>$ci::.*");

    #!ifdef WITH_REALTIME
    $var(rtEvent) = "Terminated";
    route(REALTIME);
    #!endif
}

# Executed when dialog is not established
event_route[dialog:failed] {
    sht_rm_name_re("dialogs=>$ci::.*");

    #!ifdef WITH_REALTIME
    $var(rtEvent) = 'Terminated';
    route(REALTIME);
    #!endif
}

onsend_route {
    if (is_method("ACK")) $dlg_var(confirmed) = '1';
}

route[TRANSPORT_DETECT] {
    if (!is_method("INVITE")) return;

    if (is_request() && !has_totag()) {
        if ($proto == 'ws' || $proto == 'wss' || $xavp(ulattrs[$T_branch_idx]=>transport) == 'ws' || $xavp(ulattrs[$T_branch_idx]=>transport) == 'wss') {
            xnotice("[$dlg_var(cidhash)] TRANSPORT_DETECT: Mark branch as WSS\n");
            setbflag(FLB_WEBSOCKETS);
        }
    }
}

route[GET_CODEC_INFO] {
    $dlg_var(codecs) = "";
    if ($dlg_var(type) != "retail" && $dlg_var(type) != "wholesale") return;

    sql_query("cb", "SELECT Co.iden AS codec FROM CompaniesRelCodecs CRC JOIN Codecs Co ON Co.id=CRC.codecId JOIN Companies C ON C.id=CRC.companyId WHERE companyId='$dlg_var(companyId)'", "rb");
    if ($dbr(rb=>rows) > 0) {
        $var(i) = 0;
        while($var(i) < $dbr(rb=>rows)) {
            $dlg_var(codecs) = $dlg_var(codecs) + "transcode-" + $dbr(rb=>[$var(i),0]) + " ";
            $var(i) = $var(i) + 1;
        }
    }
    sql_result_free("rb");
}

route[RTPENGINE] {
    # Requests - BYE/CANCEL + INVITE/UPDATE/ACK with SDP
    if (is_request() && !is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;
    if (is_request() && is_method("INVITE|UPDATE|ACK") && !has_body("application/sdp")) return;

    # Responses - negative responses to INVITE/UPDATE + positive responses to INVITE/UPDATE with SDP
    if (!is_request() && !is_method("INVITE|UPDATE")) return;
    if (!is_request() && is_method("INVITE|UPDATE") && t_check_status("[12][0-9]{2}") && !has_body("application/sdp")) return;

    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        xnotice("[$dlg_var(cidhash)] RTPENGINE: MediarelaysetId: $dlg_var(mediaRelaySetsId)\n");
        set_rtpengine_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    $var(common_opts) = 'replace-session-connection replace-origin';

    if (nat_uac_test("18") && !$var(is_from_inside)) {
        # NAT detected, do not trust SDP addresses
        $var(symmetry) = 'SIP-source-address';
    } else {
        # No NAT detected, trust SDP addresses
        $var(symmetry) = 'asymmetric trust-address';
    }

    if ($dlg_var(ws) == 'yes' || isbflagset(FLB_WEBSOCKETS)) {
        if ($proto == 'ws' || $proto == 'wss') {
            # WSS UAC talking, convert to UDP
            $var(bridging) = 'ICE=remove RTP/AVP rtcp-mux-demux';
        } else {
            # Talking to WSS UAC, convert from UDP
            $var(bridging) = 'ICE=force UDP/TLS/RTP/SAVPF SDES-off rtcp-mux-offer';
        }
    } else if ($dlg_var(srtp) == 'yes' && $var(is_from_inside)) {
        $var(bridging) ='ICE=remove RTP/SAVP';
    } else {
        $var(bridging) ='ICE=remove RTP/AVP';
    }

    $var(interfaces) = "";
    #!ifdef WITH_MULTISOCKET
    if ($Ri == $sel(cfg_get.address.main) && $dlg_var(extra_socket) != $null) {
        $var(interfaces) = "direction=" + $sel(cfg_get.address.main) + " direction=" + $dlg_var(extra_socket);
    }
    #!endif

    $var(callid) = "call-id=users-" + $dlg_var(direction) + '-' + $dlg_var(callid);

    $var(log_level) = 2; # L_INFO
    if (is_request()) {
        if (!has_totag()) {
            $var(log_level) = 1; # L_NOTICE
        }
    } else {
        if ($dlg_var(confirmed) != 1 && t_check_status("2[0-9]{2}")) {
            $var(log_level) = 1; # L_NOTICE
        }
    }

    route(QUALITYLABELS);

    xlog("$var(log_level)", "[$dlg_var(cidhash)] RTPENGINE: rtpengine_manage [$var(common_opts) $var(symmetry) $var(bridging) $var(interfaces) $dlg_var(codecs) $var(callid) $var(label)]\n");
    rtpengine_manage("$var(common_opts) $var(symmetry) $var(bridging) $var(interfaces) $dlg_var(codecs) $var(callid) $var(label)");

    if (is_request() && is_method("BYE")) {
        route(QUALITY);
    }
}

route[QUALITYLABELS] {
    $var(label) = "";

    if (is_request() && is_method("BYE")) {
        $avp(mos_A_label) = 'Aleg_label';
        $avp(mos_B_label) = 'Bleg_label';
    }

    if (!has_body("application/sdp")) return;
    if ($dlg_var(confirmed) == 1) return;

    if (is_request()) {
        $var(label) = "label=Aleg_label";
    } else {
        $var(label) = "label=Bleg_label";
    }
}

route[QUALITY] {
    $var(tag) =  'users' + ':b' + $dlg_var(brandId) + ':c' + $dlg_var(companyId) + ':' + $(dlg_var(rtChannel){s.select,3,:});

    xnotice("[$dlg_var(cidhash)] QUALITY: global mos $avp(mos_average) - pl $avp(mos_average_packetloss) % - jt $avp(mos_average_jitter) ms - rtt $avp(mos_average_roundtrip) ms ($var(tag))");

    if ($dlg_var(direction) == 'outbound') {
        # Call from UAC: A leg is inbound RTP flow (flow from UAC) / B leg is outbound RTP flow (flow to UAC)
        xnotice("[$dlg_var(cidhash)] QUALITY: inbound mos $avp(mos_average_A) - pl $avp(mos_average_packetloss_A) % - jt $avp(mos_average_jitter_A) ms - rtt $avp(mos_average_roundtrip_A) ms ($var(tag))");
        xnotice("[$dlg_var(cidhash)] QUALITY: outbound mos $avp(mos_average_B) - pl $avp(mos_average_packetloss_B) % - jt $avp(mos_average_jitter_B) ms - rtt $avp(mos_average_roundtrip_B) ms ($var(tag))");
    } else {
        # Call to UAC: A leg is outbound RTP flow (flow to UAC) / B leg is inbound RTP flow (flow from UAC)
        xnotice("[$dlg_var(cidhash)] QUALITY: inbound mos $avp(mos_average_B) - pl $avp(mos_average_packetloss_B) % - jt $avp(mos_average_jitter_B) ms - rtt $avp(mos_average_roundtrip_B) ms ($var(tag))");
        xnotice("[$dlg_var(cidhash)] QUALITY: outbound mos $avp(mos_average_A) - pl $avp(mos_average_packetloss_A) % - jt $avp(mos_average_jitter_A) ms - rtt $avp(mos_average_roundtrip_A) ms ($var(tag))");
    }
}

route[LOCAL_PUBLISH] {
    if(!is_method("PUBLISH") || src_ip != myself) return;

    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }

    if(is_method("PUBLISH")) {
        handle_publish();
        t_release();
    }
    exit;
}

route[PRESENCE] {
    if(!is_method("PUBLISH|SUBSCRIBE|NOTIFY")) return;

    if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
        send_reply("404", "No voicemail service");
        exit;
    }

    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }

    if(is_method("PUBLISH")) {
        handle_publish();
        t_release();
    } else if(is_method("SUBSCRIBE")) {
        handle_subscribe();
        t_release();
    } else if(is_method("NOTIFY")) {
        # Handle unsolicited NOTIFY messages (non-related to previous SUBSCRIBE)
        if (!$var(is_from_inside)) {
            xwarn("[$dlg_var(cidhash)] NOTIFY: Received $rm from not AS, 405 Method Not Allowed\n");
            send_reply("405", "Method Not Allowed");
            exit;
        }

        # Lookup contact and relay
        route(LOOKUP);
        route(RELAY);
    }
    exit;
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp == WS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xinfo("HTTP Request Received from $si:$sp\n");
    } else if ($Rp == WSS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xinfo("HTTPS Request Received from $si:$sp\n");
    } else if ($Rp == RPC_PORT) {
        xnotice("HTTP request from $si:$sp on $Rp, dispatch $hu command\n");
        jsonrpc_dispatch();
        exit;
    } else {
        if ($sel(cfg_get.dolog.websocket)) xwarn("HTTP(S) request received on $Rp, port not allowed\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {
        # Validate Host - make sure the client is using the correct
        # alias for WebSockets
        # if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
        #     if ($sel(cfg_get.dolog.websocket)) xwarn("Bad host $hdr(Host)\n");
        #     xhttp_reply("403", "Forbidden, bad host", "", "");
        #     exit;
        # }

        # Optional... validate Origin - make sure the client is from an
        # authorized website.  For example,
        #
        # if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
        #     && $hdr(Origin) != "https://communicator.MY_DOMAIN") {
        #       if ($sel(cfg_get.dolog.websocket)) xwarn("Unauthorized client $hdr(Origin)\n");
        #       xhttp_reply("403", "Forbidden", "", "");
        #       exit;
        # }

        # Optional... perform HTTP authentication

        # ws_handle_handshake() exits (no further configuration file
        # processing of the request) when complete.
        if (ws_handle_handshake()) {
            # Optional... cache some information about the
            # successful connection
            if ($sel(cfg_get.dolog.websocket)) xnotice("Connection upgrade to websocket was successful\n");
            exit;
        }
    }

    if ($sel(cfg_get.dolog.websocket)) xwarn("HTTP(S) request received without Upgrade to Websocket header, 404\n");
    xhttp_reply("404", "Not found", "", "");
}

event_route[websocket:closed] {
    if ($sel(cfg_get.dolog.websocket)) xnotice("WebSocket connection from $si:$sp has closed\n");
}

event_route[htable:mod-init] {
    if (dns_query("trunks.ivozprovider.local", "kamtrunks")) {
        $var(trunksAddress) = $dns(kamtrunks=>addr);
        xnotice("trunks.ivozprovider.local: $var(trunksAddress)\n");
    } else {
        xerr("Problems resolving trunks.ivozprovider.local, aborting\n");
        abort();
    }
}

event_route[core:worker-one-init] {
    sql_xquery("cb", "DELETE FROM BannedAddresses WHERE blocker='antibruteforce'", "flush");
}

event_route[htable:expired:srcban] {
    $var(bannedAor) = $(shtrecord(key){s.select,0,:});
    sql_xquery("cb", "DELETE FROM BannedAddresses WHERE aor='$var(bannedAor)'", "bf");
}

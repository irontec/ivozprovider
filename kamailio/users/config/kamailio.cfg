#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define XMLRPC_PORT 8000
#!define WS_PORT 10080
#!define WSS_PORT 10081

#
# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# FTL_NATS: Tags the transaction as behind NAT. It uses nat_uac_test(18) as NAT-detection mechanism
# 18: 2 + 16
# 2 - the "received" test is used: address in the "Via" header is compared against source IP address of signaling
# 16 - Test if the source port is different from the port in the "Via" header

#!define FLT_NATS 5

# FLB_NATB: Tags the branch as behind NAT.
# Is is set in 2 cases:
# 1. REGISTER behind NAT (received IP:PORT are saved in usrloc table)
# 2. Within-dialog request with nat=yes in Route header (added by this proxy in Record-route of initial transaction)

#!define FLB_NATB 6

# FLB_NATSIPPING: Enables SIP-pinging using OPTIONS for UACs registered behind NAT (see case 1 FLB_NATB)
#!define FLB_NATSIPPING 7

# DLG_FLAG
#!define DLG_FLAG 8

# ACC Flags
#!define FLT_ACC 9
#!define FLT_ACCMISSED 10

# RELATED Flag (when set, aleg found for this call in this proxy)
#!define FLT_ISBLEG 11

#!define FLT_ACCFAILED 12

#!define FLB_WEBSOCKETS 13

# - options
#!define WITH_ANTIFLOOD

#!define WITH_STATSPERCALL
# Note: if enabled, one additional sql query is made per call

#!define WITH_REDIS
# Note: if enabled, call stats are saved to REDIS

##!define KIND_MEDIALIBERATION
# Note: If defined, enable hack that avoids forwarding media liberation reINVITEs to endpoints

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

#!define REGISTER_TIMEOUT 300

####### Runtime cfg values (kamcmd cfg.list) #########

# Log dialogs initiated by these SIP methods
dolog.invite    = 1 desc "If 1, log invite transactions"
dolog.register  = 1 desc "If 1, log register transactions"
dolog.publish   = 1 desc "If 1, log publish transactions"
dolog.subscribe = 1 desc "If 1, log subscribe transactions"
dolog.notify    = 1 desc "If 1, log notify transactions"
dolog.options   = 1 desc "If 1, log options transactions"
dolog.message   = 1 desc "If 1, log message transactions"
dolog.refer     = 1 desc "If 1, log refer transactions"
dolog.websocket = 1 desc "If 1, debug WS connection upgrade"

# Debug
dolog.xmlrpc    = 0 desc "If 1, debug XMLRPC"
dolog.printmsg_methods = 'NONE' desc "Print full SIP messages with these methods" # e.g. 'INVITE|REGISTER', 'NONE' to disable

####### Global Parameters #########

listen=udp:IP:5060
listen=tcp:IP:5060
listen=tls:IP:5061
listen=tcp:IP:XMLRPC_PORT
listen=tcp:IP:WS_PORT
listen=tls:IP:WSS_PORT

tcp_accept_no_cl=yes # Needed for WS

# -- Debug level
# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# If debug level of message is lower than current debug parameter, it gets printed
# Current value: 2 (INFO and higher)
#
# This setting can me modified/seen live running:
# kamcmd-proxyusers cfg.seti core debug X
# kamcmd-proxyusers cfg.get core debug

debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec Ivoz Provider v1.0"
user_agent_header="User-Agent: Irontec Ivoz Provider v1.0"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "mi_fifo.so"
loadmodule    "mi_rpc.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "usrloc.so"
loadmodule    "registrar.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "nathelper.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "permissions.so"
loadmodule    "sqlops.so"
loadmodule    "cfg_rpc.so"
loadmodule    "acc.so"
loadmodule    "dialog.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "auth.so"
loadmodule    "auth_db.so"
loadmodule    "domain.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "corex.so"
loadmodule    "rtpengine.so"
loadmodule    "websocket.so"
loadmodule    "xhttp.so"
loadmodule    "jsonrpc-s.so"
loadmodule    "json.so"
loadmodule    "rtpproxy.so"

#!ifdef WITH_REDIS
loadmodule    "ndb_redis.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# RTPENGINE
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:22223")

# RTPPROXY
modparam("rtpproxy", "db_url", DBURL)
modparam("rtpproxy", "table_name", "kam_rtpproxy")
modparam("rtpproxy", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpproxy", "nortpproxy_str", "a=sdpmangled:yes\r\n")

#!ifdef WITH_REDIS
# REDIS
modparam("ndb_redis", "server", "name=redis;addr=jobs.ivozprovider.local;port=6379")
modparam("ndb_redis", "init_without_redis", 1)
#!endif

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_DSSOCKET)")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_mode", 2)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@users.ivozprovider.local")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxyusers_ctl")

# TLS
modparam("tls", "config", "/etc/kamailio/proxyusers/tls.cfg")
modparam("tls", "tls_log", 2)

# MI_FIFO
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_proxyusers_fifo")

# USRLOC
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc|tm", "xavp_contact", "ulattrs")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# NAT
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")

# REGISTER
modparam("registrar", "max_expires", REGISTER_TIMEOUT)
modparam("registrar", "max_contacts", 5)

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_users_address") # Allowed networks per company
modparam("permissions", "trusted_table", "kam_pike_trusted") # IPs excluded from pike checking
modparam("permissions", "db_mode", 1)
modparam("permissions", "grp_col", "companyId")

# ACC
modparam("acc", "early_media", 1)
modparam("acc", "report_ack", 1) # Only for successful establishments
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 0)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "acc_time_column", "localtime")

# -- to syslog
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 2)
modparam("acc", "db_table_acc", "kam_users_acc")
modparam("acc", "db_table_missed_calls", "kam_users_missed_calls")
modparam("acc", "cdrs_table", "kam_acc_cdrs")
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd; cseq=$cs")

# -- cdr accounting
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "proxy=$dlg_var(proxy);brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);referrer=$dlg_var(referrer);referee=$dlg_var(referee);direction=$dlg_var(direction)")

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "activeCalls; internalCalls; inboundExtCalls; outboundExtCalls")
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n") # Added to requests generated locally by the module (e.g. BYE)

# TM
modparam("tm", "fr_timer", 5000)
modparam("tm", "contacts_avp", "tm_contacts")
modparam("tm", "contact_flows_avp", "tm_contact_flows")
modparam("tm", "local_cancel_reason", 200)

# AUTH_DB
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "user_column", "name")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "domain_column", "domain")
modparam("auth_db", "use_domain", 1)

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif

# dialogs htable contains aleg, bleg and applicationserver per dialog
modparam("htable", "htable", "dialogs=>size=10;autoexpire=0")

# SANITY
modparam("sanity", "autodrop", 0)

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_users_domain")
modparam("domain", "domain_attrs_table", "kam_users_domain_attrs")
modparam("domain", "register_myself", 1)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

####### Routing Logic ########

request_route {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");

    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) xlog("L_WARN", "Received message:\n\n$mb\n");

    if (is_method("OPTIONS")) {
        if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Send 200 to '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");
        send_reply("200", "I'm here!");
        exit;
    }

    # per request initial checks
    route(REQINIT);

    # NAT/WS detection
    if (nat_uac_test(64)) # 64 - Test if the source connection of signaling is WS
        route(WSFIX);
    else
        route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si\n");
        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RELAY);
        }

        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] In dialog request - has_to_tag\n");
        route(WITHINDLG);
    }

    ### only initial requests (no To tag)

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NOT in dialog request - not has_to_tag: Initial transaction\n");

    # Manage retransmissions
    t_check_trans();

    # Discard unsupported methods
    if (!is_method("INVITE|REGISTER|SUBSCRIBE|NOTIFY|PUBLISH")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Manage authentication
    route(AUTH);

    # Remove preloaded route headers
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Remove preloaded route headers\n");
    remove_hf("Route");

    # Handle everything except INVITEs
    if(is_method("REGISTER")) {
        route(REGISTER);
    } else if(is_method("SUBSCRIBE")) {
        route(SUBSCRIBE);
    } else if(is_method("NOTIFY")) {
        route(NOTIFY);
    } else if(is_method("PUBLISH")) {
        route(PUBLISH);
    }

    # From now on, everything is for INVITEs: track dialog

    # Setup accounting
    route(ACCOUNTING);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] dialog_manage()\n");
    dlg_manage();

    # Add record-route to INVITE requests
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Add record-route\n");
    record_route();

    # uri!=myself:
    # (a) from_uri==myself: Local subscriber calling to external domain
    # (b) from_uri!=myself: Trusted host with incorrect domain in R-URI
    if (uri!=myself) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] R-URI not for my domain\n");
        if (from_uri==myself) {
            # (a) Local subscriber calling to external domain
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Local subscriber calling to external domain, 501 Not implemented\n");
            send_reply("501", "Not Implemented");
            exit;
        } else {
            # (b) Trusted host with incorrect domain in R-URI
            # Only AS-es could reach this point (ds_is_from_list(1)), remaining would be dropped as open-relay is not allowed
            if ($dlg_var(log)) xlog("L_ERR", "AS talking with incorrect domain in R-URI ($ru), check!!\n");
            send_reply("500", "Invalid URI domain");
            exit;
        }
    }

    # uri==myself
    # (a) from_uri==myself: Local subscriber calling to my domain
    # (b) from_uri!=myself:
    #   (b1) AS
    #   (b2) DROP
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] R-URI: My domain\n");

    if (from_uri==myself) {
        $dlg_var(direction) = 'inbound';

        # (a) from_uri==myself: Local subscriber calling to my domain
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Local subscriber calling to my domain, dispatch to AS(-es)\n");
        route(GET_INFO_FROM_CALLER);
        route(FILTER_BY_SCR_ADDR);
        if ($rU =~ '^\*') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calling to feature-like $rU, ringall all AS-es\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calling to non-feature-like $rU, dispatch to any AS\n");
            route(PROFILE_UAC_CALL);
        }

        #!ifdef WITH_REDIS
        # Redis data
        $dlg_var(AoR) = $fU + '@' + $fd;
        $dlg_var(interlocutor) = $rU;
        $dlg_var(redisset) = 'call::b' + $dlg_var(brandId) + 'c' + $dlg_var(companyId) + 'e' + $dlg_var(caller) + '::' + $ci;
        #!endif

        route(DISPATCH);
        route(RELAY);
    } else {
        if (ds_is_from_list("1")) {
            $dlg_var(direction) = 'outbound';

            # Save CallID <-> AS relationship
            $sht(dialogs=>$ci::applicationserver) = 'sip:' + $si + ':6060';

            # (b1) AS calling to local subscriber
            route(REPLACES);
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AS calling to local subscriber, relay to subcriber\n");
            route(PARSE_X_HEADERS);
            route(RELATE_LEGS);
            route(FRIENDS);
            if ($avp(friend) != 'yes') route(LOOKUP);
            route(PROFILE_AS_CALL);

            #!ifdef WITH_REDIS
            # Redis data
            $dlg_var(AoR) = $tU + '@' + $td;
            $dlg_var(interlocutor) = $(ai{uri.user});
            $dlg_var(redisset) = 'call::b' + $dlg_var(brandId) + 'c' + $dlg_var(companyId) + 'e' + $dlg_var(callee) + '::' + $ci;
            #!endif

            route(RELAY);
        } else {
            # (b2) from_uri!=myself: Who is calling?? ProxyUsers only receives from subscribers and AS-es -> Drop
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Who is calling?? ProxyUsers only receives from subscribers and AS-es -> Drop\n");
            send_reply("403", "Forbidden");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Main script error, should NOT arrive this point.\n");
    drop;
}

route[REPLACES] {
    if (! is_present_hf("Replaces")) return;

    # AS sending an INVITE with REPLACE header, guess which AS is the proper destination
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: AS sending a INVITE with Replaces header, forward to proper AS\n");

    # Extract CallId from Replaces header
    $var(replace_uri) = $(hdr(Replaces){s.select,0,;});
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: Which AS is handling $(hdr(Replaces){s.select,0,;})?\n");

    if ($sht(dialogs=>$var(replace_uri)::applicationserver) != $null) {
        $du = $sht(dialogs=>$var(replace_uri)::applicationserver);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: Forward to '$du'\n");
        $fu = 'sip:replacer@users.ivozprovider.local'; # Change From header too
        route(RELAY);
    } else {
        if ($dlg_var(log)) xlog("L_ERROR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: CallID not found, 500\n");
        send_reply("500", "CallID not found");
        exit;
    }
    # Note: this dialog won't be inserted into kam_acc_cdrs (INSERT fails) and that's OK
}

route[DISPATCH] {
    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Strict routing to specific AS?
    if ($avp(asAddress) != $null) {
        $du = "sip:" + $avp(asAddress) + ":6060";
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du> (strict routing)\n");
        t_on_failure("MANAGE_FAILURE");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: dispatch to any AS (loose routing)\n");

        # round robin dispatching on ASs
        if(!ds_select_dst("1", "10")) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: No destination found\n");
            send_reply("404", "No destination");
            exit;
        }

        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du>\n");
        t_on_failure("MANAGE_FAILURE_AS");
    }

    # Save CallID <-> AS relationship
    $sht(dialogs=>$ci::applicationserver) = $du;
}

route[LOOKUP] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Look up $ru on location DB\n");
    lookup("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Contact not found for $ru, 404\n");
            sl_send_reply("404", "Not Found");
            exit;
        case -2:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Contacts found, but method not supported for $ru, 404\n");
            sl_send_reply("404", "Not Found");
            exit;
        case -3:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Internal error during processing lookup for $ru, 404\n");
            sl_send_reply("404", "Not Found");
            exit;
    };

    # Handle multiple contacts
    if (!t_load_contacts()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Error loading contacts for $rU\n");
        sl_send_reply("500", "Server Internal Error - Cannot load contacts");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Contacts loaded for $rU\n");
    }

    # Load contact or contacts
    if (!t_next_contacts()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: t_next_contacts - Only one contact found for $rU, calling\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: t_next_contacts - Multiple contacts found for $rU, parallel forking\n");
    }

    # Is this a call to a dynamic friend?
    if (is_method("INVITE") && $dlg_var(friend) == 'dynamic') {
        # Fix call destination to avoid sending call to user part of Contact header in REGISTER
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: This call is for a dynamic friend, set destination to $dlg_var(callee)\n");
        $rU = $dlg_var(callee);
    }
}

route[FRIENDS] {
    if (!is_method("INVITE")) return;
    if ($dlg_var(friend) == $null) return;
    if ($dlg_var(friend) == 'dynamic') return;

    # Static friend
    $ru = $dlg_var(friend);
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FRIEND: It is a static friend, route to '$ru'\n");
    $avp(friend) = 'yes';
}

route[GET_INFO_FROM_CALLER] {
    # Get needed information from terminal name
    sql_xquery("cb", "SELECT EXT.number AS userExtension, C.id AS companyId, C.brandId AS brandId, C.name AS companyName, C.mediaRelaySetsId, C.ipFilter, AppS.ip AS asAddress, C.onDemandRecord, C.onDemandRecordCode FROM kam_users KU LEFT JOIN Users U ON U.terminalId=KU.id LEFT JOIN Extensions EXT ON EXT.Id=U.extensionId LEFT JOIN Companies C ON KU.companyId=C.id LEFT JOIN ApplicationServers AppS ON AppS.id=C.applicationServerId WHERE KU.name='$fU' AND KU.domain='$fd'", "ra");

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: caller: $xavp(ra=>userExtension)\n");
    if ($xavp(ra=>userExtension) == $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: seems a friend calling, keep $dlg_var(caller) as caller\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: seems a terminal calling, set $xavp(ra=>userExtension) as caller\n");
        $dlg_var(caller) = $xavp(ra=>userExtension);
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: brandId: $xavp(ra=>brandId)\n");
    $dlg_var(brandId) = $xavp(ra=>brandId);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: companyId: $xavp(ra=>companyId)\n");
    $dlg_var(companyId) = $xavp(ra=>companyId);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: companyName: $xavp(ra=>companyName)\n");
    $dlg_var(companyName) = $xavp(ra=>companyName);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: ipFilter: $xavp(ra=>ipFilter)\n");
    $var(ipFilter) = $xavp(ra=>ipFilter);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: asAddress: $xavp(ra=>asAddress)\n");
    $avp(asAddress) = $xavp(ra=>asAddress);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: mediaRelaySetsId: $xavp(ra=>mediaRelaySetsId)\n");
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: onDemandRecord: $xavp(ra=>onDemandRecord)\n");
    if ($xavp(ra=>onDemandRecord)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-CALLER: onDemandRecordCode: $xavp(ra=>onDemandRecordCode)\n");
        $dlg_var(onDemandRecordCode) = $xavp(ra=>onDemandRecordCode);
    }
}

route[FILTER_BY_SCR_ADDR] {
    if ($var(ipFilter) == '0') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: IP filter is disabled for company $dlg_var(companyName) (id: $dlg_var(companyId))\n");
        return;
    }

    if (!allow_source_address($dlg_var(companyId))) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: $si is not valid for company $dlg_var(companyName) (id: $dlg_var(companyId))\n");
        $rU = 'ipnotallowed';
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: Valid source $si for company $dlg_var(companyName) (id: $dlg_var(companyId))\n");
    }
}

route[PARSE_X_HEADERS] {
    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(xcallid) = $var(header-value);

    # Extract callee
    $var(header) = 'X-Info-Callee';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(callee) = $var(header-value);

    # Extract brandId
    $var(header) = 'X-Info-BrandId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(brandId) = $var(header-value);

    # Extract companyId
    $var(header) = 'X-Info-CompanyId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyId) = $var(header-value);

    # Extract companyName
    $var(header) = 'X-Info-CompanyName';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyName) = $var(header-value);

    # Extract companyDomain
    $var(header) = 'X-Info-CompanyDomain';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyDomain) = $var(header-value);

    # Extract MediaRelaySet (can be null and non-exist)
    $var(header) = 'X-Info-MediaRelaySet';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(mediaRelaySetsId) = $var(header-value);

    # Extract RecordCode (can be null and non-exist)
    $var(header) = 'X-Info-RecordCode';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(onDemandRecordCode) = $var(header-value);

    # Extract Friend (can be null and non-exist)
    $var(header) = 'X-Info-Friend';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(friend) = $var(header-value);
}

# Header might not be present and, if present, might be empty
route[PARSE_OPTIONAL_X_HEADER] {
    if (is_present_hf($var(header))) {
        if ($(hdr($var(header)){s.len})) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header): $hdr($var(header))\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header): <empty>\n");
        }
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header) not present\n");
        $var(header-value) = '';
    }
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header): $hdr($var(header))\n");
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        sl_send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[PROFILE_UAC_CALL] {
#!ifdef WITH_STATSPERCALL
    # Inbound / outbound
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-UAC-CALL: Type-> outbound\n");

    # Internal / External
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS seemsInternal FROM Extensions E WHERE number='$rU' AND companyId='$dlg_var(companyId)' AND routeType!='number'", "ra");
    if ($xavp(ra=>seemsInternal) == '1' || pcre_match("$rU", "^\*")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-UAC-CALL: Subtype-> seems internal\n");
        # We cannot warranty that it is an internal call (the destination may have an inconditional call-forward, etc.)
        # If it is a real internal calls it will be profiled in its bleg
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-UAC-CALL: Subtype-> external\n");

        # Outbound external calls by company
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-UAC-CALL: Profile-> outboundExtCalls\n");
        $dlg_var(profile) = "Outbound external call";
        set_dlg_profile("outboundExtCalls", "$dlg_var(companyId)");

        # Active calls by company
        set_dlg_profile("activeCalls", "$dlg_var(companyId)");
    }
#!endif

    return;
}

route[PRINT_STATS] {
#!ifdef WITH_STATSPERCALL
    # Global stats
    if(get_profile_size("activeCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) active calls\n");
    }

    if(get_profile_size("internalCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) internal calls\n");
    }

    if(get_profile_size("outboundExtCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) external outbound calls\n");
    }

    if(get_profile_size("inboundExtCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) external inbound calls\n");
    }

    # Company stats
    if(get_profile_size("activeCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) active calls\n");
    }

    if(get_profile_size("internalCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) internal calls\n");
    }

    if(get_profile_size("outboundExtCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) external outbound calls\n");
    }

    if(get_profile_size("inboundExtCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) external inbound calls\n");
    }
#!endif

    return;
}

route[PROFILE_AS_CALL] {
#!ifdef WITH_STATSPERCALL
    # Inbound / outbound
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-AS-CALL: Type-> inbound\n");

    # Internal / External
    if (isflagset(FLT_ISBLEG)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-AS-CALL: Subtype-> internal\n");

        # Internal calls by company
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-AS-CALL: Profile-> internalCalls\n");
        $dlg_var(profile) = "Internal call";
        set_dlg_profile("internalCalls", "$dlg_var(companyId)");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-AS-CALL: Subtype-> external\n");

        # Inbound external calls by company
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-AS-CALL: Profile-> inboundExtCalls\n");
        $dlg_var(profile) = "Inbound external call";
        set_dlg_profile("inboundExtCalls", "$dlg_var(companyId)");
    }

    # Active calls by company
    set_dlg_profile("activeCalls", "$dlg_var(companyId)");
#!endif

    return;
}

# Authentication route
route[AUTH] {
    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AUTH: No auth for AS request\n");
        return;
    }

    if (is_method("REGISTER") || from_uri==myself) {
        # authenticate requests
        if (!auth_check("$fd", "kam_users", "1")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AUTH: Auth needed\n");
            auth_challenge("$fd", "0");
            exit;
        }

        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AUTH: Authentication OK, consume credentials\n");
        # user authenticated - remove auth header
        consume_credentials();
    }

    # if caller is not local subscriber, then check if it calls
    # a local destination, otherwise deny, not an open relay here
    if (from_uri!=myself && uri!=myself) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Not open relay here!\n");
        sl_send_reply("403","Not relaying");
        exit;
    }

    # Domain strict checking
    if ( uri == myself && !is_uri_host_local() ) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rd is my IP but domains should be used, reject\n");
        sl_send_reply("488", "Domain needed");
        exit;
    }

    if ( from_uri == myself && !is_from_local() ) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $fd is my IP but domains should be used, reject\n");
        sl_send_reply("488", "Domain needed");
        exit;
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Domain strict checking success\n");

    return;
}

route[MEDIALIBERATION] {
#!ifdef KIND_MEDIALIBERATION
    if (is_method("ACK") && $dlg_var(discardack) == '1') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIALIBERATION: Drop ACK, magic part 2 of 2!\n");
        $dlg_var(discardack) = $null;
        exit;
    }

    if (is_method("INVITE|UPDATE") && has_body("application/sdp") && ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIALIBERATION: Re-$rm from AS, evaluate doing magic\n");
        if (!sdp_get_line_startswith("$avp(cline)", "c=IN IP4 " + $si)) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIALIBERATION: RTPproxy on SDP, start magic!\n");
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIALIBERATION: Mangle RTPproxy ports and reply 200, magic part 1 of 2!\n");
            if (is_method("INVITE"))
                $dlg_var(discardack) = '1'; # Set dlg_flag to discard subsequent ACK
            route(RTPRELAY); # Call RTPRELAY to link ports accordingly
            send_reply("200", "I agree");
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIALIBERATION: SDP does not contain RTPproxy ($avp(cline)), abort magic\n");
        }
    }
#!endif
    return;
}

# Handle within-dialog messages
route[WITHINDLG] {
    # Do not forward media liberation reinvite
    route(MEDIALIBERATION);

    #!ifdef WITH_REDIS
    # Update interlocutor
    if (is_present_hf("P-Asserted-Identity") && $(ai{uri.user})) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: Update redis interlocutor to $(ai{uri.user})\n");
        redis_cmd("redis", "HMSET $dlg_var(redisset) interlocutor $(ai{uri.user})", "r");
    }
    #!endif

    # Subscribe requests do not follow loose routing
    if (is_method("SUBSCRIBE")) {
        remove_hf("Proxy-Authorization");
        if (uri==myself) {
            # Within dialog subscribe shouldn't have my domain in R-URI, loose routing is not possible!
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: SUBSCRIBE loose-routing is not possible, fake!\n");
            if ($sht(dialogs=>$ci::applicationserver) =~ '^sip:') {
                if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: SUBSCRIBE from known dialog, forward to $sht(dialogs=>$ci::applicationserver)\n");
                $ru = $sht(dialogs=>$ci::applicationserver);
                route(RELAY);
            } else {
                if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: SUBSCRIBE from unknown dialog, 481\n");
                send_reply("481", "Call/Transaction Does Not Exist");
                exit;
            }
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: SUBSCRIBE loose-routing capable, proceed\n");
        }
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(RURIALIAS);
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        } else if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("REFER")) {
            route(REFER);
        } else if (is_method("INFO")) {
            route(INFO);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        sl_send_reply("404","Not here");
    }
    exit;
}

route[REFER] {
    if (is_present_hf("Refer-to") && $(hdr(Refer-to){s.len})) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REFER: $fU transfers call to $hdr(Refer-to)\n");

        if ($(hdr(Refer-to){nameaddr.uri}{uri.user}) =~ '^,?\*[0-9]{1,3}$') {
            route(ONDEMANDRECORD);
        }

        $dlg_var(referee) = $hdr(Refer-to);
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REFER: No Refer-To header found, error\n");
        send_reply("400", "Refer-To is missing");
        exit;
    }
}

route[INFO] {
    if (is_present_hf("Record")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] On demand record using INFO, proceed\n");
        route(ONDEMANDRECORD);
    }

    return;
}

route[ONDEMANDRECORD] {
    if (!$dlg_var(onDemandRecordCode)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: On demand record not enabled, ignore\n");
        send_reply("403", "Forbidden");
        exit;
    }

    if (is_method("REFER")) {
        $var(opt1) = ',*' + $dlg_var(onDemandRecordCode);
        $var(opt2) = '*' + $dlg_var(onDemandRecordCode);
        $var(code) = $(hdr(Refer-to){nameaddr.uri}{uri.user});

        if ($var(code) != $var(opt1) && $var(code) != $var(opt2)) {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: That is NOT the code, ignore\n");
            send_reply("403", "Forbidden");
            exit;
        }
    }

    if ($dlg_var(recording) != 'yes') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: Start recording call\n");
        start_recording();
        $dlg_var(recording) = 'yes';
        send_reply("404", "Record On");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: Start recording code again, stop recording\n");
        stop_recording();
        $dlg_var(recording) = 'no';
        send_reply("404", "Record Off");
    }
    exit;
}

# URI update for requests where alias found
route[RURIALIAS] {
    if(isdsturiset()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Destination URI is set, no un-aliasing is needed\n");
        return;
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Route using R-URI, any alias on R-URI ('$ru')?\n");

    handle_ruri_alias();
    switch ($rc) {
    case -1:
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Failed to handle alias of R-URI $ru\n");
        send_reply("400", "Bad request");
        exit;
    case 1:
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Alias parsed, routing $rm from $fu to $du\n");
        break;
    case 2:
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Alias not found, routing $rm from $fu to $ru\n");
        break;
    };

    return;
}

# Relay request
route[RELAY] {
    # Common for every transaction
    t_on_reply("MANAGE_REPLY");
    t_on_branch("MANAGE_BRANCH");

    # Only for non-initial transaction and for UAC initial (AS initial has custom route)
    if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");

    if (!t_relay())
        sl_reply_error();

    exit;
}

# Initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
    # flood detection from same IP and traffic ban for a while
    #
    # Excluded from pike:
    #   - my ip excluded
    #   - AS-es excluded
    #   - IPs in trusted table
    #   - Authorized IPs for companies
    $var(group) = allow_address_group($si, $sp);
    if ($var(group) != -1) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: $si is not checked against antiflood (allowed source for companyId '$var(group)')\n");
    } else if (allow_trusted($si, 'any')) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: $si is not checked against antiflood (IP added in antiflood trusted IPs)\n");
    } else if (src_ip==myself || ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: $si is not checked against antiflood (AS or myself talking)\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: $si will be checked against antiflood\n");
        if($sht(ipban=>$si) != $null) {
            # ip is already blocked
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: $si granted by antiflood\n");
    }
#!endif

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: Too many hops for SIP message from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: Malformed SIP message from $si:$sp\n");
        exit;
    }

    # Easy dropping for sipvicious scans
    if (search("sipvicious")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: DROPPED SIPVICIOUS ----> $rm from $si\n");
        exit;
    }
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: All checks passed, continue...\n");
}

# Handle SIP registrations
route[REGISTER] {
    if(isflagset(FLT_NATS)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: NAT must be kept open\n");
        setbflag(FLB_NATB);
        # Enable SIP NAT pinging
        if ($proto == 'udp') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Enable UDP SIP OPTIONS PINGING\n");
            setbflag(FLB_NATSIPPING);
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Enable TCP raw NAT keeper\n");
        }
    }

    # Store in kam_users_location_attrs used transport to retrieve it in lookup
    $xavp(ulattrs=>transport) = $proto;

    $var(contact_uri) = @contact.uri;
    save("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Something went wrong when saving location\n");
            sl_reply_error();
            break;
        case 1:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts inserted ($tu: $var(contact_uri))\n");
            break;
        case 2:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts updated ($tu: $var(contact_uri))\n");
            break;
        case 3:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts deleted ($tu: $var(contact_uri))\n");
            break;
        case 4:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts returned\n");
            break;
    };

    exit;
}

# Handle SUBSCRIBE messages
route[SUBSCRIBE] {
    # Only UACs can send SUBSCRIBE requests
    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SUBSCRIBE: Received $rm from AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # I only handle my domains
    if (uri!=myself) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SUBSCRIBE: Received $rm to an incorrect domain $rd, 404 Not Here\n");
        send_reply("404", "Not here");
        exit;
    }

    # Add record-route to SUBSCRIBE requests
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SUBSCRIBE: Add record-route\n");
    record_route();

    # Dispatch SUBSCRIBE to AS
    route(GET_INFO_FROM_CALLER);
    route(DISPATCH);
    route(RELAY);
}

# Handle NOTIFY messages
route[NOTIFY] {
    if (!ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NOTIFY: Received $rm from not AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # Lookup contact and relay
    route(LOOKUP);
    route(RELAY);
}

# Handle PUBLISH messages
route[PUBLISH] {
    if (!ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PUBLISH: Received $rm from not AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # Republish to remaining AS-es
    route(REPUBLISH);
}

route[REPUBLISH] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPUBLISH: Send PUBLISH from $si to remaining AS-es\n");

    sl_send_reply("200", "OK, republishing");
    t_release();

    if(!ds_select_dst("1", "4")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPUBLISH: No destination found\n");
        exit;
    }

    $var(i) = 0;
    while(is_avp_set("$(avp(AVP_DST)[$var(i)])")) {
        $du = $(avp(AVP_DST)[$var(i)]);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPUBLISH: Forward[$var(i)]: $du\n");
        route(AVOID_SRC);

        $var(i) = $var(i) + 1;
    }

    exit;
}

route[AVOID_SRC] {
    if ($(du{s.select,1,:}) == $si) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPUBLISH: not sending to original source, skip\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPUBLISH: destination found, going to <$ru> via <$du>\n");
        forward();
    }
}

# Detect NAT
route[NATDETECT] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: Force rport\n");
    force_rport();

    if (nat_uac_test("18")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: NAT detected, set FLT_NATS\n");
        setflag(FLT_NATS);

        if (is_method("REGISTER")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: REGISTER ---> fix_nated_register\n");
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: Non-REGISTER and first hop ---> Add contact alias\n");
                # Sets ;alias only if received ip and port differ from those in contact URI
                if (!add_contact_alias()) {
                   if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: Error in aliasing contact $ct\n");
                   send_reply("400", "Bad request");
                   exit;
                }
            }
        }
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: No NAT detected\n");
    }
}

route[WSFIX] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSFIX: Websockets detected, fix contact\n");
    # Do NAT traversal stuff for requests from a WebSocket
    # connection - even if it is not behind a NAT!
    # This won't be needed in the future if Kamailio and the
    # WebSocket client support Outbound and Path.
    force_rport();
    if (is_method("REGISTER")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSFIX: Add Received AVP to be stored by userloc with $proto:$si:$sp\n");
        fix_nated_register();
    } else if (!add_contact_alias()) {
        if($dlg_var(nolog) != "1") xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSFIX: Error aliasing contact <$ct>\n");
        sl_send_reply("400", "Bad Request");
        exit;
    }
    return;
}

# Handle NAT
route[NATMANAGE] {
    # RTP handling is always enforced
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Force RTPRELAY\n");
    route(RTPRELAY);

    # Set FLB_NATB? Only in within-dialog request with nat=yes on Route header
    if (is_request() && has_totag() && check_route_param("nat=yes")) {
       if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Set FLB_NATB (reason: within-dialog request with nat=yes on Route header)\n");
       setbflag(FLB_NATB);
    }

    # Return unless FLT_NATS or FLB_NATB are set
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: No endpoint is behind NAT, return\n");
        return;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: One or both endpoints are behind NAT, continue!\n");
    }

    # Add nat=yes in record-route? Only in initial requests when called from branch_route
    if (is_request() && !has_totag() && t_is_branch_route()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Add nat=yes to record-route (reason: initial request called from branch route)\n");
        add_rr_param(";nat=yes");
    }

    # Add contact alias? Only to replies with NATB set and first hop
    if (is_reply() && isbflagset(FLB_NATB) && is_first_hop()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Add contact alias (reason: reply with NATB set and first hop)\n");
        # Sets ;alias only if received ip and port differ from those in contact URI
        if (!add_contact_alias()) {
           if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Error in aliasing contact $ct\n");
           send_reply("400", "Bad request");
           exit;
        }
    }
}

# Configure xlog
route[CONFIGURE_XLOG] {
    # Evaluate only once for SIP methods than can initiate transaction
    if ($dlg_var(log) == "0" || $dlg_var(log)) return;

    $dlg_var(log) = "0";

    if (is_method("INVITE") && $sel(cfg_get.dolog.invite)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REGISTER") && $sel(cfg_get.dolog.register)) {
        $dlg_var(log) = "1";
    }

    if (is_method("PUBLISH") && $sel(cfg_get.dolog.publish)) {
        $dlg_var(log) = "1";
    }

    if (is_method("SUBSCRIBE") && $sel(cfg_get.dolog.subscribe)) {
        $dlg_var(log) = "1";
    }

    if (is_method("NOTIFY") && $sel(cfg_get.dolog.notify)) {
        $dlg_var(log) = "1";
    }

    if (is_method("OPTIONS") && $sel(cfg_get.dolog.options)) {
        $dlg_var(log) = "1";
    }

    if (is_method("MESSAGE") && $sel(cfg_get.dolog.message)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REFER") && $sel(cfg_get.dolog.refer)) {
        $dlg_var(log) = "1";
    }

    # Needed variables
    if ($dlg_var(cidhash) == $null) {
        # Extract brandId (if present)
        if (is_present_hf('X-Info-BrandId')) {
            $dlg_var(brandId) = $hdr(X-Info-BrandId);
        } else if (lookup_domain("$fd")) {
            # If X-Info-BrandId not present, UAC talking
            # Guess brandId from domain :)
            $dlg_var(brandId) = $avp(brandId);
        }

        # Calculate callid hash
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calculated hash for $ci\n");
    }

    return;
}

route[RELATE_LEGS] {
    if ($sht(dialogs=>$dlg_var(xcallid)::applicationserver) != '') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELATE-LEGS: $ci aleg is $dlg_var(xcallid), set FLT-ISBLEG\n");
        setflag(FLT_ISBLEG);
        $sht(dialogs=>$ci::aleg) = $dlg_var(xcallid);

        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELATE-LEGS: $dlg_var(xcallid) bleg is $ci\n");
        $sht(dialogs=>$dlg_var(xcallid)::bleg) = $ci;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELATE-LEGS: $dlg_var(xcallid) not present in dialogs htable, skip\n");
    }
}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    # Set proxy value
    $dlg_var(proxy) = 'USER';

    # Where is my caller? Order: PAI, RPID, From
    # Note: In UAC->AS, caller will be overriden with user extension
    if (is_present_hf("P-Asserted-Identity")) {
        $dlg_var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        $dlg_var(caller) = $(re{uri.user});
    } else {
        $dlg_var(caller) = $fU;
    }

    $dlg_var(callee) = $rU; # In AS->UAC, callee will be overriden with X-Info-Callee
    $dlg_var(callid) = $ci;
    if (is_present_hf("Diversion"))
        $dlg_var(diversion) = $(di{uri.user});

    if (is_present_hf("Referred-by")) {
        $dlg_var(referrer) = $(hdr(Referred-by){nameaddr.uri}{uri.user});
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ACCOUNTING: Call due to bxfer from $dlg_var(referrer)\n");
    }
}

# Reply generic route (all replies goes through this route)
onreply_route {
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ( $rm =~ $sel(cfg_get.dolog.printmsg_methods) ) xlog("L_WARN", "Received reply:\n\n$mb\n");

    if (is_method("PUBLISH") && ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Drop '$rs $rr' from AS to PUBLISH\n");
        drop;
    }
}

# Reply generic route (additional, for all replies)
onreply_route[MANAGE_REPLY] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_REPLY: Additional for all replies\n");

    # Account user's missed calls if ringing
    if (is_method("INVITE") && $rs=="180" && !ds_is_from_list("1")) {
        setflag(FLT_ACCMISSED);
    }

    #!ifdef WITH_REDIS
    # Create Redis object
    if (is_method("INVITE") && $rs =~ "[12][0-9][0-9]") {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_REPLY: Create/Update $dlg_var(redisset) redis object\n");
        redis_cmd("redis", "HSETNX $dlg_var(redisset) create-time $TS", "r");
        redis_cmd("redis", "HSET $dlg_var(redisset) status $rr", "r");
        redis_cmd("redis", "HSETNX $dlg_var(redisset) AoR $dlg_var(AoR)", "r");
        redis_cmd("redis", "HSETNX $dlg_var(redisset) interlocutor $dlg_var(interlocutor)", "r");
        redis_cmd("redis", "HSETNX $dlg_var(redisset) applicationserver $sht(dialogs=>$ci::applicationserver)", "r");
    }
    #!endif

    # Manage NAT
    if ($rs =~ "[12][0-9][0-9]") {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_REPLY: Non-error reply $rs, call NATMANAGE\n");
        route(NATMANAGE);
    }

    # Manage WS
    if (nat_uac_test(64)) { # 64 - Test if the source connection of signaling is WS
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_REPLY: add_contact_alias\n");
        # Do NAT traversal stuff for replies to a WebSocket connection
        # - even if it is not behind a NAT!
        # This won't be needed in the future if Kamailio and the
        # WebSocket client support Outbound and Path.
        add_contact_alias();
    }
}

failure_route[MANAGE_FAILURE] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: Call NATMANAGE\n");
    route(NATMANAGE);

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: t_is_canceled, exit here\n");
        exit;
    }
}

failure_route[MANAGE_FAILURE_AS] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: Call NATMANAGE\n");
    route(NATMANAGE);

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Route for branching: Only for INVITEs and BYEs (fork-able)
branch_route[MANAGE_BRANCH] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_BRANCH: NEW BRANCH [$T_branch_idx] to $du (R-URI: $ru)\n");

    route(TRANSPORT_DETECT);

    # Manage NAT
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH: Call NATMANAGE\n");
    route(NATMANAGE);
}

# Executed when dialog fails with +3XX response code
#!ifdef WITH_REDIS
event_route[dialog:failed] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] dialog-failed: Delete $dlg_var(redisset) redis object\n");
    redis_cmd("redis", "DEL $dlg_var(redisset)", "r");
}
#!endif

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
#!ifdef WITH_REDIS
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] dialog-start: Update $dlg_var(redisset) redis object status to established\n");
    redis_cmd("redis", "HMSET $dlg_var(redisset) status established establish-time $TS", "r");
#!endif

    if(isbflagset(FLB_WEBSOCKETS)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Answered dialog involves websockets\n");
        $dlg_var(ws) = 'yes';
    }

    if ($dlg_var(profile) != $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: $dlg_var(profile) established for '$dlg_var(companyName)' (id: $dlg_var(companyId)) [$ci]\n");
        route(PRINT_STATS);
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
#!ifdef WITH_REDIS
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] dialog-end: Delete $dlg_var(redisset) redis object\n");
    redis_cmd("redis", "DEL $dlg_var(redisset)", "r");
#!endif

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Dialog ended, delete keys from dialogs htable starting with $ci\n");
    sht_rm_name_re("dialogs=>$ci::.*");

    if ($dlg_var(profile) != $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: $dlg_var(profile) ended for '$dlg_var(companyName)' (id: $dlg_var(companyId)) [$ci]\n");
        route(PRINT_STATS);
    }
}

onsend_route {
    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) {
        if (is_request())
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent request:\n\n$snd(buf)\n");
        else
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent reply:\n\n$snd(buf)\n");
    }
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_WARN", "XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");
    route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "GENERIC_XMLRPC_COMMAND: XMLRPC generic command from allowed IP ($si), dispatch!\n");

    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[TRANSPORT_DETECT] {
    if (!is_method("INVITE")) return;

    if (is_request() && !has_totag()) {
        if ($rP == 'ws' || $rP == 'wss' || $proto == 'ws' || $proto == 'wss') {
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSPORT-DETECT: Websockets, set FLB_WEBSOCKETS\n");
            setbflag(FLB_WEBSOCKETS);
        }
    }
}

route[RTPRELAY] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;

    if ($dlg_var(ws) == 'yes' || isbflagset(FLB_WEBSOCKETS)) {
        xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPRELAY: Websockets around, call rtpengine\n");
        route(RTPENGINE);
    } else {
        route(RTPPROXY);
    }
}

route[RTPPROXY] {
    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: Custom rtpproxy set: $dlg_var(mediaRelaySetsId)\n");
        set_rtp_proxy_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    if (has_body("application/sdp") && nat_uac_test("18")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: Private IPs in SDP found, do not trust SDP addresses\n");
        rtpproxy_manage("cowf");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: No private IPs in SDP, trust SDP addresses\n");
        rtpproxy_manage("coarf");
    }

    if (is_request() && is_method("INVITE") && !has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: Chosen RTPproxy instance $var(RTP_INSTANCE)\n");
    }
}

route[RTPENGINE] {
    $var(common_opts) = 'replace-session-connection replace-origin force';

    if (has_body("application/sdp") && nat_uac_test("18")) {
        $var(symmetry) = 'symmetric SIP-source-address';
    } else {
        $var(symmetry) = 'asymmetric trust-address';
    }

    if ($proto == 'ws' || $proto == 'wss' ) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: Is through $proto, convert to udp\n");
        $var(wsopts) = 'ICE=remove RTP/AVP DTLS=no';
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: Is through $proto (non-ws), convert to wss\n");
        $var(wsopts) = 'ICE=force RTP/SAVPF DTLS=passive';
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: rtpengine_manage [$var(common_opts) $var(symmetry) $var(wsopts)]\n");
    rtpengine_manage("$var(common_opts) $var(symmetry) $var(wsopts)");
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp == WS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "HTTP Request Received from $si:$sp\n");
    } else if ($Rp == WSS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "HTTPS Request Received from $si:$sp\n");
    } else {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "HTTP(S) request received on $Rp, port not allowed\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {
        # Validate Host - make sure the client is using the correct
        # alias for WebSockets
        # if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
        #     if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "Bad host $hdr(Host)\n");
        #     xhttp_reply("403", "Forbidden, bad host", "", "");
        #     exit;
        # }

        # Optional... validate Origin - make sure the client is from an
        # authorised website.  For example,
        #
        # if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
        #     && $hdr(Origin) != "https://communicator.MY_DOMAIN") {
        #       if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "Unauthorised client $hdr(Origin)\n");
        #       xhttp_reply("403", "Forbidden", "", "");
        #       exit;
        # }

        # Optional... perform HTTP authentication

        # ws_handle_handshake() exits (no further configuration file
        # processing of the request) when complete.
        if (ws_handle_handshake()) {
            # Optional... cache some information about the
            # successful connection
            if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "Connection upgrade to websocket was successful\n");
            exit;
        }
    }

    if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "HTTP(S) request received without Upgrade to Websocket header, 404\n");
    xhttp_reply("404", "Not found", "", "");
}

event_route[websocket:closed] {
    if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}

event_route[dispatcher:dst-down] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Destination down: $rm $ru ($du)\n");
}

event_route[dispatcher:dst-up] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Destination up: $rm $ru\n");
}


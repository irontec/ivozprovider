#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define TRUNKS_SIP_PORT 5060
#!define SIP_PORT 5060
#!define SIPS_PORT 5061
#!define XMLRPC_PORT 8000
#!define WS_PORT 10080
#!define WSS_PORT 10081

#
# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# FTL_NATS: Tags the transaction as behind NAT. It uses nat_uac_test(18) as NAT-detection mechanism
# 18: 2 + 16
# 2 - the "received" test is used: address in the "Via" header is compared against source IP address of signaling
# 16 - Test if the source port is different from the port in the "Via" header

#!define FLT_NATS 1

# FLB_NATB: Tags the branch as behind NAT.
# Is is set in 2 cases:
# 1. REGISTER behind NAT (received IP:PORT are saved in usrloc table)
# 2. Within-dialog request with nat=yes in Route header (added by this proxy in Record-route of initial transaction)

#!define FLB_NATB 2

# FLB_NATSIPPING: Enables SIP-pinging using OPTIONS for UACs registered behind NAT (see case 1 FLB_NATB)
#!define FLB_NATSIPPING 3

# DLG_FLAG
#!define DLG_FLAG 4

# ACC Flags
#!define FLT_ACC 5
#!define FLT_ACCMISSED 6
#!define FLT_ACCFAILED 7

# Marked for branches involving wss
#!define FLB_WEBSOCKETS 8

# - options
#!define WITH_ANTIFLOOD

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

####### Runtime cfg values (kamcmd cfg.list) #########

# Log dialogs initiated by these SIP methods
dolog.invite    = 1 desc "If 1, log invite transactions"
dolog.register  = 1 desc "If 1, log register transactions"
dolog.publish   = 1 desc "If 1, log publish transactions"
dolog.subscribe = 1 desc "If 1, log subscribe transactions"
dolog.notify    = 1 desc "If 1, log notify transactions"
dolog.options   = 1 desc "If 1, log options transactions"
dolog.message   = 1 desc "If 1, log message transactions"
dolog.refer     = 1 desc "If 1, log refer transactions"
dolog.websocket = 1 desc "If 1, debug WS connection upgrade"

# Debug
dolog.xmlrpc    = 0 desc "If 1, debug XMLRPC"
dolog.printmsg_methods = 'NONE' desc "Print full SIP messages with these methods" # e.g. 'INVITE|REGISTER', 'NONE' to disable

####### Global Parameters #########

listen=udp:IP:SIP_PORT
listen=tcp:IP:SIP_PORT
listen=tls:IP:SIPS_PORT
listen=tcp:IP:XMLRPC_PORT
listen=tcp:IP:WS_PORT
listen=tls:IP:WSS_PORT

tcp_accept_no_cl=yes # Needed for WS

# -- Debug level
# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# If debug level of message is lower than current debug parameter, it gets printed
# Current value: 2 (INFO and higher)
#
# This setting can me modified/seen live running:
# kamcmd-proxyusers cfg.seti core debug X
# kamcmd-proxyusers cfg.get core debug

debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes
version_table="kam_version"

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec IvozProvider v2.2"
user_agent_header="User-Agent: Irontec IvozProvider v2.2"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "usrloc.so"
loadmodule    "registrar.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "nathelper.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "permissions.so"
loadmodule    "sqlops.so"
loadmodule    "cfg_rpc.so"
loadmodule    "dialog.so"
loadmodule    "acc.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "auth.so"
loadmodule    "auth_db.so"
loadmodule    "domain.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "corex.so"
loadmodule    "rtpengine.so"
loadmodule    "websocket.so"
loadmodule    "xhttp.so"
loadmodule    "jsonrpcs.so"
loadmodule    "json.so"
loadmodule    "rtpproxy.so"
loadmodule    "pua.so"
loadmodule    "pua_dialoginfo.so"
loadmodule    "presence.so"
loadmodule    "presence_xml.so"
loadmodule    "presence_dialoginfo.so"
loadmodule    "ipops.so"
loadmodule    "dialplan.so"
loadmodule    "diversion.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# RTPENGINE
modparam("rtpengine", "db_url", DBURL)
modparam("rtpengine", "table_name", "kam_rtpengine")
modparam("rtpengine", "setid_avp", "$avp(setid)")
modparam("rtpengine", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpengine", "setid_default", 1)

# RTPPROXY
modparam("rtpproxy", "db_url", DBURL)
modparam("rtpproxy", "table_name", "kam_rtpproxy")
modparam("rtpproxy", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpproxy", "nortpproxy_str", "a=sdpmangled:yes\r\n")

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_DSSOCKET)")
modparam("dispatcher", "attrs_avp", "$avp(DSATTRS)")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 2)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@users.ivozprovider.local")
modparam("dispatcher", "hash_pvar", "$avp(hash)")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxyusers_ctl")

# TLS
modparam("tls", "config", "/etc/kamailio/proxyusers/tls.cfg")
modparam("tls", "tls_log", 2)

# JSONRPCS
modparam("jsonrpcs", "fifo_name", "/tmp/kamailio_proxyusers_fifo")

# USRLOC
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc|tm", "xavp_contact", "ulattrs")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# NAT
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")

# REGISTER
modparam("registrar", "min_expires", 300)
modparam("registrar", "max_contacts", 5)

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_users_address") # Allowed networks per company
modparam("permissions", "trusted_table", "kam_trusted") # IPs excluded from pike checking and wholesale IPs
modparam("permissions", "db_mode", 1)
modparam("permissions", "grp_col", "companyId")
modparam("permissions", "max_subnets", 4096)
modparam("permissions", "peer_tag_avp", "$avp(trustedTag)")

# ACC
# -- transactions to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- cdr accounting to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 0)
modparam("acc", "cdrs_table", "kam_users_cdrs")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_extra_nullable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);referrer=$dlg_var(referrer);referee=$dlg_var(referee);direction=$dlg_var(direction);userId=$dlg_var(userId);friendId=$dlg_var(friendId);retailAccountId=$dlg_var(retailAccountId)")

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "callsPerAor; activeCallsCompany; activeCallsBrand; outgoingCallsPerAor")
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "default_timeout", 10800) # 3 hours
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n") # Added to requests generated locally by the module (e.g. BYE)

# TM
modparam("tm", "fr_timer", 5000)
modparam("tm", "contacts_avp", "tm_contacts")
modparam("tm", "contact_flows_avp", "tm_contact_flows")
modparam("tm", "local_cancel_reason", 200)

# AUTH_DB
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "user_column", "name")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "domain_column", "domain")
modparam("auth_db", "use_domain", 1)

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif

# dialogs htable contains aleg, bleg and applicationserver per dialog
modparam("htable", "htable", "dialogs=>size=10;autoexpire=0")

# SANITY
modparam("sanity", "autodrop", 0)

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_users_domain")
modparam("domain", "domain_attrs_table", "kam_users_domain_attrs")
modparam("domain", "register_myself", 1)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

# PRESENCE
modparam("presence", "db_url", DBURL)
modparam("presence", "presentity_table", "kam_users_presentity")
modparam("presence", "active_watchers_table", "kam_users_active_watchers")
modparam("presence", "watchers_table", "kam_users_watchers")
modparam("presence", "min_expires", 1800)
modparam("presence", "max_expires", 3600)
modparam("presence", "db_update_period", 100)
modparam("presence", "subs_db_mode", 2)

# PRESENCE XML
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "xcap_table", "kam_users_xcap")
modparam("presence_xml", "force_active", 1)

# PRESENCE XML
modparam("presence_dialoginfo", "force_single_dialog", 1)
modparam("presence_dialoginfo", "force_dummy_dialog", 1)

# PUA
modparam("pua", "db_url", DBURL)
modparam("pua", "db_table", "kam_users_pua")
modparam("pua", "db_mode", 0)
modparam("pua", "update_period", 100)

# PUA_DIALOGINFO
# -- needed for call-pickup
modparam("pua_dialoginfo", "include_callid", 0)
modparam("pua_dialoginfo", "include_tags", 0)
modparam("pua_dialoginfo", "include_localremote", 0)
modparam("pua_dialoginfo", "caller_confirmed", 0)
modparam("pua_dialoginfo", "use_pubruri_avps", 1)
modparam("pua_dialoginfo", "pubruri_caller_avp", "$avp(pubruri_caller)")
modparam("pua_dialoginfo", "pubruri_callee_avp", "$avp(pubruri_callee)")
modparam("pua_dialoginfo", "pubruri_caller_dlg_var", "pubruri_caller")
modparam("pua_dialoginfo", "pubruri_callee_dlg_var", "pubruri_callee")

# DIALPLAN
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "table_name", "kam_dialplan")
modparam("dialplan", "attrs_pvar", "$avp(s:appliedrule)")

####### Routing Logic ########

request_route {
    # per request initial checks
    route(REQINIT);

    # Is this a wholesale call?
    route(DETECT_WHOLESALE);

    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($si:$sp) [$proto]\n");

    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) xlog("L_WARN", "Received message:\n\n$mb\n");

    if (is_method("OPTIONS")) {
        force_rport();
        send_reply("200", "I'm here!");
        exit;
    }

    route(ANTIFLOOD);

    # NAT/WS detection
    if (nat_uac_test(64)) # 64 - Test if the source connection of signaling is WS
        route(WSFIX);
    else
        route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si\n");
        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RELAY);
        }

        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # Manage retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        route(WITHINDLG);
    }

    ### only initial requests (no To tag)

    # Discard unsupported methods
    if (!is_method("INVITE|REGISTER|SUBSCRIBE|NOTIFY|PUBLISH")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Manage authentication
    route(AUTH);

    # Remove preloaded route headers
    remove_hf("Route");

    # Handle REGISTER
    route(REGISTER);

    # Add record-route to INVITE and SUBSCRIBE requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Handle SUBSCRIBE and PUBLISH
    route(PRESENCE);

    # Handle out-of-dialog NOTIFY
    route(NOTIFY);

    # From now on, everything is for INVITEs: track dialog

    # Set caller and callee to generate PUBLISH
    route(GENERATE_PUBLISH);

    dlg_manage();

    # Route AS or subscriber calls
    if (ds_is_from_list("1")) {
        # (a) AS calling

        # Save CallID <-> AS relationship
        $sht(dialogs=>$ci::applicationserver) = 'sip:' + $si + ':6060';

        route(REPLACES);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AS calling to local subscriber, relay to subcriber\n");
        route(PARSE_X_HEADERS);
        route(GET_INFO_FROM_CALLEE);
        route(ADAPT_PAI);
        route(ADAPT_DIVERSION);
        route(MAXCALLS_USER);
        route(FRIENDS);
        route(RETAILS);
        route(LOOKUP);
    } else if ($dlg_var(wholesaleId) != $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Wholesale call, send to trunks\n");
        route(MEDIARELAY_TYPE);
        route(CONTROL_MAXCALLS);
        route(ADAPT_RURI);
        route(ADAPT_PAI);
        route(ADAPT_DIVERSION);
        $du = "sip:trunks.ivozprovider.local:" + TRUNKS_SIP_PORT;
    } else {
        # (b) Subscriber calling
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Local subscriber calling to my domain, dispatch to AS\n");
        route(GET_INFO_FROM_CALLER);
        route(FILTER_BY_SCR_ADDR);
        route(CONTROL_MAXCALLS);
        if ($rU =~ '^\*') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calling to feature-like $rU\n");
        } else {
            route(ADAPT_RURI);
            route(ADAPT_PAI);
            route(ADAPT_DIVERSION);
        }

        route(DISPATCH);
    }

    route(ACCOUNTING);
    route(RELAY);
}

route[ADAPT_RURI] {
# Only in initial INVITE requests from subscribers
    $var(number) = $rU;

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-RURI: '$var(number)' is internal, do not transformate\n");
        return;
    }

    $var(transformation) = $dlg_var(callee_in);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-RURI: Adapt '$var(number)' using rule '$var(transformation)'\n");
    route(APPLY_TRANSFORMATION);
    $rU = $var(transformated);
}

route[ADAPT_REFERTO] {
# Only in within-dialog REFER requests from subscribers
    if(!is_method("REFER")) return;
    if(!ds_is_from_list("1")) return;

    if (search_hf("Refer-To", "Replaces", "a")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-REFERTO: Replacer found in Refer-To, return\n");
        return;
    }

    $var(number) = $(rt{uri.user});

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-REFERTO: '$var(number)' is internal, do not transformate\n");
        return;
    }

    $var(transformation) = $dlg_var(callee_in);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-REFERTO: Adapt '$var(number)' using rule '$var(transformation)'\n");
    route(APPLY_TRANSFORMATION);
    $var(newreferto) = '<sip:' + $var(transformated) + '@' + $(rt{uri.host}) + '>';
    remove_hf("Refer-To");
    append_hf("Refer-To: $var(newreferto)\r\n");
}

route[ADAPT_PAI] {
# In all requests and replies
    if (!is_present_hf("P-Asserted-Identity")) return;

    if (is_request() && !has_totag()) {
        # Save caller for accounting
        $dlg_var(caller) = $(ai{uri.user});
    }

    $var(number) = $(ai{uri.user});

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-PAI: '$var(number)' is internal, do not transformate\n");
        return;
    }

    if (ds_is_from_list("1")) {
        $var(transformation) = $dlg_var(caller_out);
    } else {
        $var(transformation) = $dlg_var(caller_in);
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-PAI: Adapt '$var(number)' using rule '$var(transformation)'\n");
    route(APPLY_TRANSFORMATION);

    if ($fn != $null && is_request() && ds_is_from_list("1")) {
        $var(newpai) = $fn + ' <sip:' + $var(transformated) + '@' + $(ai{uri.host}) + '>';
    } else {
        $var(newpai) = '<sip:' + $var(transformated) + '@' + $(ai{uri.host}) + '>';
    }

    remove_hf("P-Asserted-Identity");
    append_hf("P-Asserted-Identity: $var(newpai)\r\n");

    if (is_request() && !has_totag()) {
        # Update caller value in e164 for accounting
        $dlg_var(caller) = $var(transformated);
    }
}

route[ADAPT_CONTACT] {
# Only in 3XX replies to INVITEs from subscribers
    if (!is_present_hf("Contact")) return;

    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-CONTACT: 3XX reply from AS, this shouldn't happen\n");
        return;
    }

    $var(number) = @contact.uri.user;

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-CONTACT: '$var(number)' is internal, do not transformate\n");
        return;
    }

    $var(transformation) = $dlg_var(callee_in);
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-CONTACT: After -> $var(transformated) (applied rule: '$avp(appliedrule)')\n");
    route(APPLY_TRANSFORMATION);
    $var(newcontact) = '<sip:' + $var(transformated) + '@' + @contact.uri.host + '>';
    remove_hf("Contact");
    append_hf("Contact: $var(newcontact)\r\n");
}

route[ADAPT_DIVERSION] {
# In all initial INVITE requests
    if (!is_present_hf("Diversion")) return;

    # Only adapt first Diversion header
    $var(number) = $(di{uri.user});
    if ($var(number) == $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-DIVERSION: No number extracted, return\n");
        return;
    }

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-DIVERSION: '$var(number)' is internal, do not transformate\n");
        return;
    }

    $avp(reason) = @hf_value.diversion[0].param['reason'];
    if ($avp(reason) == $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-DIVERSION: No reason extracted, set 'deflection'\n");
        $avp(reason) = 'deflection';
    }

    if (ds_is_from_list("1")) {
        $var(transformation) = $dlg_var(caller_out);
    } else {
        $var(transformation) = $dlg_var(caller_in);
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-DIVERSION: Adapt '$var(number)' using rule '$var(transformation)'\n");
    route(APPLY_TRANSFORMATION);
    remove_hf_value("Diversion[0]");
    add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $(di{uri.host}));
}

# Apply $var(transformation) transformations (if set) to $var(number)
# Sets result in $var(transformated)
route[APPLY_TRANSFORMATION] {
    $var(transformated) = $var(number);
    $avp(appliedrule) = $null;

    dp_translate("$(var(transformation){s.int})", "$var(number)/$var(transformated)");

    # If no rule applied, re-set value
    if ($avp(appliedrule) == $null)
        $var(transformated) = $var(number);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] APPLY-TRANSFORMATION: Number after: $var(transformated) (applied rule: '$avp(appliedrule)')\n");
}

route[REQINIT] {
    # Easy dropping for scanners
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent" || search("sipvicious")) {
        xlog("L_WARN", "REQINIT: Dropping scanner request ----> $rm from $si\n");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        xlog("L_ERR", "REQINIT: Dropping malformed SIP message from $si:$sp\n");
        exit;
    }

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        xlog("L_ERR", "REQINIT: Too many hops for SIP message from $si:$sp\n");
        send_reply("483","Too Many Hops");
        exit;
    }
}

route[GENERATE_PUBLISH] {
    if ($dlg_var(wholesaleId) != $null) return; # Skip logic for wholesale clients

    if (ds_is_from_list("1")) {
        # No PUBLISH for calls to friends/retails
        if (is_present_hf("X-Info-Friend")) return;
        if (is_present_hf("X-Info-Retail")) return;

        # Set X-Info-Callee as 'callee' instead of user in To header
        $avp(pubruri_callee)= "sip:" + $hdr(X-Info-Callee) + "@" + $fd;
    } else {
        sql_xquery("cb", "SELECT extension, externalIpCalls FROM kam_users WHERE name='$fU' AND domain='$fd'", "rp");
        if ($xavp(rp=>extension) == $null) return; # No PUBLISH for calls from non-terminals

        # Terminal calling
        # Set user extension as 'caller' instead of user in From header
        $avp(pubruri_caller)= "sip:" + $xavp(rp=>extension) + "@" + $fd;

        $dlg_var(caller) = $xavp(rp=>extension); # Set accounting dlg_var too

        # Is this user allowed to call from non-granted IPs?
        $avp(externalIpCalls) = $xavp(rp=>externalIpCalls);
    }
}

route[MAXCALLS_USER] {
    if (!$dlg_var(maxcallsUser)){
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MAXCALLS-USER: '$tU@$td' has no call-limit, proceed\n");
        return;
    }

    get_profile_size("callsPerAor", "$tU@$td", "$var(currentCalls)");
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MAXCALLS-USER: '$tU@$td' has $var(currentCalls) out of $dlg_var(maxcallsUser) active calls\n");

    if ($var(currentCalls) >= $dlg_var(maxcallsUser)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MAXCALLS-USER: Reject call\n");
        send_reply("486", "Maxcalls exceeded");
        exit;
    } else {
        $avp(AoR) = $tU + '@' + $td;
    }
}

route[REPLACES] {
    if (! is_present_hf("Replaces")) return;

    # AS sending an INVITE with REPLACE header, guess which AS is the proper destination
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: AS sending a INVITE with Replaces header, forward to proper AS\n");

    # Extract CallId from Replaces header
    $var(replace_uri) = $(hdr(Replaces){s.select,0,;});
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: Which AS is handling $(hdr(Replaces){s.select,0,;})?\n");

    if ($sht(dialogs=>$var(replace_uri)::applicationserver) != $null) {
        $du = $sht(dialogs=>$var(replace_uri)::applicationserver);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: Forward to '$du'\n");
        $fu = 'sip:replacer@users.ivozprovider.local'; # Change From header too
        route(RELAY);
    } else {
        if ($dlg_var(log)) xlog("L_ERROR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: CallID not found, 500\n");
        send_reply("500", "CallID not found");
        exit;
    }
    # Note: this dialog won't be inserted into kam_acc_cdrs (INSERT fails) and that's OK
}

route[DISPATCH] {
    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Static routing to specific AS?
    if ($avp(distributeMethod) == 'static') {
        $du = "sip:" + $avp(asAddress) + ":6060";
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: Company has static routing enabled\n");
        t_on_failure("MANAGE_FAILURE");
    } else {
        if ($avp(distributeMethod) == 'hash') {
            $avp(hash) = $dlg_var(companyId);
            # hash over $avp(hash)
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: Dispatch hashing '$avp(hash)'\n");
            $var(alg) = 7;
        } else {
            # round robin dispatching on ASs (distributeMethod == 'rr')
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: dispatch to any AS (round robin)\n");
            $var(alg) = 4;
        }

        if(!ds_select_dst("1", "$var(alg)")) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: No destination found\n");
            send_reply("404", "No destination");
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: $avp(AVP_CNT) destination(s) found\n");
        }

        t_on_failure("MANAGE_FAILURE_AS");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du>\n");

    # Save CallID <-> AS relationship
    $sht(dialogs=>$ci::applicationserver) = $du;
}

route[LOOKUP] {
    if ($avp(static_location) == 'yes') return;

    lookup("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Contact not found for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
        case -2:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Contacts found, but method not supported for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
        case -3:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Internal error during processing lookup for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
    };

    # Handle multiple contacts
    if (!t_load_contacts()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Error loading contacts for $rU\n");
        send_reply("500", "Server Internal Error - Cannot load contacts");
        exit;
    }

    # Load contact or contacts
    if (!t_next_contacts()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: t_next_contacts - One contact found for $tu, calling $ru\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: t_next_contacts - Multiple contacts found for $tu, parallel forking\n");
    }

    # Is this a call to a dynamic friend/retail?
    route(DYNAMIC_ENDPOINT);
}

route[DYNAMIC_ENDPOINT] {
    if (!is_method("INVITE")) return;
    if (!($dlg_var(friend) == 'dynamic' || $dlg_var(retail) == 'dynamic')) return;

    # Fix call destination to avoid sending call to user part of Contact header in REGISTER
    $rU = $dlg_var(callee);

    # Need adaptation?
    if ($(rU{s.substr,0,1}) == '+') {
        $var(number) = $rU;
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DYNAMIC-ENDPOINT: Before -> $var(number)\n");
        $var(transformation) = $dlg_var(callee_out);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DYNAMIC-ENDPOINT: Adapt '$var(number)' using rule '$var(transformation)'\n");
        route(APPLY_TRANSFORMATION);
        $rU = $var(transformated);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DYNAMIC-ENDPOINT: After -> $var(transformated) (applied rule: '$avp(appliedrule)')\n");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DYNAMIC-ENDPOINT: This call is for a dynamic friend/retail, set destination to '$rU'\n");
}

route[FRIENDS] {
    if (!is_method("INVITE")) return;
    if ($dlg_var(friend) == $null) return;
    if ($dlg_var(friend) == 'dynamic') return;

    # Static friend
    $ru = $dlg_var(friend);
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FRIEND: It is a static friend, route to '$ru'\n");
    $avp(static_location) = 'yes';
}

route[RETAILS] {
    if (!is_method("INVITE")) return;
    if ($dlg_var(retail) == $null) return;
    if ($dlg_var(retail) == 'dynamic') return;

    # Static retail
    $ru = $dlg_var(retail);
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RETAILS: It is a static retail, route to '$ru'\n");
    $avp(static_location) = 'yes';
}

route[DETECT_WHOLESALE]{
    if(has_totag()) return;

    if (allow_trusted($si, 'any') && $avp(trustedTag) != $null) {
        # Wholesale detected
        $dlg_var(wholesaleId) = $avp(trustedTag);

        # Discard unsupported methods
        if (!is_method("INVITE|CANCEL|ACK|PRACK|OPTIONS")) { # ACK/PRACK must have totag but just in case
            xlog("L_ERR", "$rm not supported for wholesale client '$dlg_var(wholesaleId)'\n");
            send_reply("501", "Not Implemented");
            exit;
        }

        # Get needed information from wholesale client
        route(GET_INFO_FROM_WHOLESALE);
    }

    return;
}

route[GET_INFO_FROM_WHOLESALE] {
    sql_xquery("cb", "SELECT C.brandId, C.billingMethod, C.mediaRelaySetsId, C.maxCalls AS maxCallsCompany, B.maxCalls AS maxCallsBrand, CONCAT(C.transformationRuleSetId,0) AS caller_in, CONCAT(C.transformationRuleSetId,1) AS callee_in, CONCAT(C.transformationRuleSetId,2) AS caller_out, CONCAT(C.transformationRuleSetId,3) AS callee_out FROM Companies C JOIN Brands B ON B.id=C.brandId WHERE C.id='$dlg_var(wholesaleId)'", "ra");

    $dlg_var(brandId) = $xavp(ra=>brandId);
    $dlg_var(companyId) = $dlg_var(wholesaleId);
    $dlg_var(billingMethod) = $xavp(ra=>billingMethod);
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
    $dlg_var(maxCallsCompany) = $xavp(ra=>maxCallsCompany);
    $dlg_var(maxCallsBrand) = $xavp(ra=>maxCallsBrand);

    # Add X-Info-Headers for trunks
    insert_hf("X-Info-BrandId: $dlg_var(brandId)\r\n");
    insert_hf("X-Info-WholesaleId: $dlg_var(wholesaleId)\r\n");
    insert_hf("X-Info-BillingMethod: $dlg_var(billingMethod)\r\n");

    $dlg_var(caller_in) = $xavp(ra=>caller_in);
    $dlg_var(callee_in) = $xavp(ra=>callee_in);
    $dlg_var(caller_out) = $xavp(ra=>caller_out);
    $dlg_var(callee_out) = $xavp(ra=>callee_out);
}

route[GET_INFO_FROM_CALLEE] {
    # Get needed information from To header
    sql_xquery("cb", "SELECT KU.type AS calleeType, KU.objectId, KU.caller_in, KU.callee_in, KU.caller_out, KU.callee_out FROM kam_users KU LEFT JOIN Companies C ON C.id=KU.companyId LEFT JOIN ApplicationServers AppS ON AppS.id=C.applicationServerId WHERE KU.name='$tU' AND KU.domain='$td'", "ra");

    if ($xavp(ra=>calleeType) == 'terminal') {
        $dlg_var(userId) = $xavp(ra=>objectId); # user
    } else if($xavp(ra=>calleeType) == 'friend') {
        $dlg_var(friendId) = $xavp(ra=>objectId); # friend
    } else {
        $dlg_var(retailAccountId) = $xavp(ra=>objectId); # retail
    }

    $dlg_var(caller_in) = $xavp(ra=>caller_in);
    $dlg_var(callee_in) = $xavp(ra=>callee_in);
    $dlg_var(caller_out) = $xavp(ra=>caller_out);
    $dlg_var(callee_out) = $xavp(ra=>callee_out);
}

route[GET_INFO_FROM_CALLER] {
    # Get needed information from terminal name
    sql_xquery("cb", "SELECT KU.type AS callerType, KU.objectId, KU.caller_in, KU.callee_in, KU.caller_out, KU.callee_out, C.id AS companyId, C.mediaRelaySetsId, C.ipFilter, C.distributeMethod, C.maxCalls AS maxCallsCompany, B.maxCalls AS maxCallsBrand, AppS.ip AS asAddress, C.onDemandRecord, C.onDemandRecordCode FROM kam_users KU LEFT JOIN Companies C ON C.id=KU.companyId JOIN Brands B ON C.brandId=B.id LEFT JOIN ApplicationServers AppS ON AppS.id=C.applicationServerId WHERE KU.name='$fU' AND KU.domain='$fd'", "ra");

    if ($xavp(ra=>callerType) == 'terminal') {
        $dlg_var(userId) = $xavp(ra=>objectId); # user
    } else if($xavp(ra=>callerType) == 'friend') {
        $dlg_var(friendId) = $xavp(ra=>objectId); # friend
    } else {
        $dlg_var(retailAccountId) = $xavp(ra=>objectId); # retail
    }

    $dlg_var(caller_in) = $xavp(ra=>caller_in);
    $dlg_var(callee_in) = $xavp(ra=>callee_in);
    $dlg_var(caller_out) = $xavp(ra=>caller_out);
    $dlg_var(callee_out) = $xavp(ra=>callee_out);

    $dlg_var(companyId) = $xavp(ra=>companyId);
    $dlg_var(maxCallsCompany) = $xavp(ra=>maxCallsCompany);
    $dlg_var(maxCallsBrand) = $xavp(ra=>maxCallsBrand);
    $var(ipFilter) = $xavp(ra=>ipFilter);
    $avp(distributeMethod) = $xavp(ra=>distributeMethod);
    $avp(asAddress) = $xavp(ra=>asAddress);
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
    route(MEDIARELAY_TYPE);

    if ($xavp(ra=>onDemandRecord)) {
        $dlg_var(onDemandRecordCode) = $xavp(ra=>onDemandRecordCode);
    }
}

route[MEDIARELAY_TYPE] {
    if ($dlg_var(mediaRelaySetsId) != $null) {
        sql_xquery("cb", "SELECT type FROM MediaRelaySets WHERE id='$dlg_var(mediaRelaySetsId)'", "rb");
        $dlg_var(mediaRelayType) = $xavp(rb=>type);
    } else {
        $dlg_var(mediaRelaySetsId) = '0';
        $dlg_var(mediaRelayType) = 'rtpproxy';
    }
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIARELAY-TYPE: set '$dlg_var(mediaRelaySetsId)' ($dlg_var(mediaRelayType))\n");
}

route[FILTER_BY_SCR_ADDR] {
    if ($var(ipFilter) == '0') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: IP filter is disabled for company '$dlg_var(companyId)'\n");
        return;
    }

    # Company has IP check enabled

    if (allow_source_address($dlg_var(companyId))) {
        # -- Granted IP, proceed
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: Valid source $si for company '$dlg_var(companyId)'\n");
    } else if ($avp(externalIpCalls) > 0) {
        # -- Non-granted IP, but roadwarrior calling
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: This user is allowed to call from non-granted IP (externalIpCalls: $avp(externalIpCalls))\n");
        route(FILTER_BY_NUMCALLS);
    } else {
        # -- Non-granted IP and not roadwarrior
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: $si is not valid for company '$dlg_var(companyId)'\n");
        $rU = 'ipnotallowed';
    }
}

route[FILTER_BY_NUMCALLS] {
    get_profile_size("outgoingCallsPerAor", "$fU@$fd", "$var(currentOutgoingCalls)");
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-NUMCALLS: '$fU@$fd' has $var(currentOutgoingCalls) out of $avp(externalIpCalls) outgoing calls\n");

    if ($var(currentOutgoingCalls) >= $avp(externalIpCalls)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-NUMCALLS: Reject call\n");
        send_reply("486", "Maxcalls exceeded");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-NUMCALLS: Allow call\n");
        set_dlg_profile("outgoingCallsPerAor", "$fU@$fd");
    }
}

route[PARSE_X_HEADERS] {
    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(xcallid) = $var(header-value);
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Related leg: $dlg_var(xcallid)\n");

    # Extract user maxcalls
    $var(header) = 'X-Info-UserMaxCalls';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(maxcallsUser) = $var(header-value);

    # Extract companyId
    $var(header) = 'X-Info-CompanyId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyId) = $var(header-value);

    # Extract MediaRelaySet (can be null and non-exist)
    $var(header) = 'X-Info-MediaRelaySet';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(mediaRelaySetsId) = $var(header-value);
    route(MEDIARELAY_TYPE);

    # Extract RecordCode (can be null and non-exist)
    $var(header) = 'X-Info-RecordCode';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(onDemandRecordCode) = $var(header-value);

    # Extract Friend (can be null and non-exist)
    $var(header) = 'X-Info-Friend';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(friend) = $var(header-value);

    # Extract Retail (can be null and non-exist)
    $var(header) = 'X-Info-Retail';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(retail) = $var(header-value);

    # Set callee
    $var(header) = 'X-Info-Callee';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(callee) = $var(header-value);
}

# Header might not be present and, if present, might be empty
route[PARSE_OPTIONAL_X_HEADER] {
    if (is_present_hf($var(header))) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        $var(header-value) = '';
    }
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[IS_INTERNAL] {
    $avp(is_internal) = '0';

    # Is extension in Extensions?
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isExtension FROM Extensions E WHERE number='$var(number)' AND companyId='$dlg_var(companyId)'", "ra");
    if ($xavp(ra=>isExtension) == '1') {
        $avp(is_internal) = '1';
        return;
    }

    # Is a friend?
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isFriend FROM FriendsPatterns WHERE friendId IN (SELECT id FROM Friends WHERE companyId='$dlg_var(companyId)') AND '$var(number)' REGEXP `regExp`", "ra");
    if ($xavp(ra=>isFriend) == '1') {
        $avp(is_internal) = '1';
        return;
    }

    # Not recognized as internal, must start with '+' if AS talking
    if ($(var(number){s.substr,0,1}) != '+' && ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] IS-INTERNAL: Not internal number not starting with '+', this shouldn't happen\n");
    }

    return;
}

# Authentication route
route[AUTH] {
    if (is_method("PUBLISH") && dns_sys_match_ip("users.ivozprovider.local", "$si")) return;

    if (ds_is_from_list("1")) {
        # No auth for AS requests
        return;
    }

    if ($dlg_var(wholesaleId) != $null) return; # No AUTH for wholesale clients

    if (is_method("REGISTER") || from_uri==myself) {
        # authenticate requests
        if (!auth_check("$fd", "kam_users", "1")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AUTH: Auth needed\n");
            auth_challenge("$fd", "0");
            exit;
        }

        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AUTH: Authentication OK\n");
        # user authenticated - remove auth header
        consume_credentials();
    }

    # If caller is not local subscriber, reject (both AS and subscribers use my domain in from-domain)
    if (from_uri!=myself) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $fd is not my domain, 403 forbidden\n");
        send_reply("403","Forbidden");
        exit;
    }

    # Check R-URI is for my domain
    if (uri!=myself) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] R-URI not for my domain, 404 Not here\n");
        send_reply("404", "Invalid domain in R-URI");
        exit;
    }

    # Domain strict checking
    if ( uri == myself && !is_uri_host_local() ) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rd is my IP but domains should be used, reject\n");
        send_reply("488", "Domain needed");
        exit;
    }

    if ( from_uri == myself && !is_from_local() ) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $fd is my IP but domains should be used, reject\n");
        send_reply("488", "Domain needed");
        exit;
    }

    return;
}

# Handle within-dialog messages
route[WITHINDLG] {
    if (!$dlg_var(confirmed) && is_method("UPDATE|INVITE")) drop;

    route(ADAPT_PAI);
    route(ADAPT_REFERTO);

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(RURIALIAS);
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        } else if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("REFER")) {
            route(REFER);
        } else if (is_method("INFO")) {
            route(INFO);
        } else if (is_method("MESSAGE")) {
            route(MESSAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
    } else {
        if (is_method("SUBSCRIBE") && uri == myself) {
            # in-dialog subscribe requests
            route(PRESENCE);
            exit;
        }

        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        send_reply("404","Not here");
    }
    exit;
}

route[REFER] {
    if (is_present_hf("Refer-to") && $(hdr(Refer-to){s.len})) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REFER: $fU transfers call to $hdr(Refer-to)\n");
        $dlg_var(referee) = $hdr(Refer-to);

        if ($(hdr(Refer-to){nameaddr.uri}{uri.user}) =~ '^,?\*[0-9]{1,3}$') {
            $var(opt1) = ',*' + $dlg_var(onDemandRecordCode);
            $var(opt2) = '*' + $dlg_var(onDemandRecordCode);
            $var(code) = $(hdr(Refer-to){nameaddr.uri}{uri.user});

            if ($var(code) == $var(opt1) || $var(code) == $var(opt2)) {
                route(ONDEMANDRECORD);
            }

            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REFER: That is NOT the code, relay\n");
        }

    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REFER: No Refer-To header found, relay\n");
    }

    return;
}

route[INFO] {
    if (is_present_hf("Record")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] INFO: On demand record using INFO, proceed\n");
        route(ONDEMANDRECORD);
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] INFO: INFO without Record header, relay\n");
    }

    return;
}

route[MESSAGE] {
    if (!ds_is_from_list("1")) return;

    if (search_body("on-demand-record")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MESSAGE: On demand record using MESSAGE, proceed\n");
        route(ONDEMANDRECORD);
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MESSAGE: MESSAGE without on-demand-record body, relay\n");
    }

    return;
}

route[ONDEMANDRECORD] {
    if (!$dlg_var(onDemandRecordCode)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: On demand record not enabled, ignore\n");
        send_reply("403", "Forbidden");
        exit;
    }

    if ($dlg_var(recording) != 'yes') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: Start recording call\n");
        start_recording();
        $dlg_var(recording) = 'yes';

        if (is_method("REFER")) {
            send_reply("404", "Record On");
        } else {
            send_reply("200", "Record On");
        }
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: Stop recording call\n");
        stop_recording();
        $dlg_var(recording) = 'no';

        if (is_method("REFER")) {
            send_reply("404", "Record Off");
        } else {
            send_reply("200", "Record Off");
        }
    }

    exit;
}

# URI update for requests where alias found
route[RURIALIAS] {
    if(isdsturiset()) {
        return;
    }

    handle_ruri_alias();
    switch ($rc) {
    case -1:
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Failed to handle alias of R-URI $ru\n");
        send_reply("400", "Bad request");
        exit;
    case 1:
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Alias parsed, routing $rm from $fu to $du\n");
        break;
    case 2:
        # ;alias not found
        break;
    };

    return;
}

# Relay request
route[RELAY] {
    # Common for every transaction
    t_on_reply("MANAGE_REPLY");
    t_on_branch("MANAGE_BRANCH");

    # Only for non-initial transaction and for UAC initial (AS initial has custom route)
    if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");

    if (!t_relay())
        sl_reply_error();

    exit;
}

route[ANTIFLOOD] {
#!ifdef WITH_ANTIFLOOD
    # AS or myself
    if (src_ip==myself || ds_is_from_list("1") || dns_sys_match_ip("trunks.ivozprovider.local", "$si")) return;

    # Wholesale client
    if ($dlg_var(wholesaleId) != $null) return;

    # Trusted sources
    if (allow_trusted($si, 'any')) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (IP added in kam_trusted)\n");
        return;
    }

    # Allowed sources by company
    $var(group) = allow_source_address_group();
    if ($var(group) != -1) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (allowed source for companyId '$var(group)')\n");
        return;
    }

    # Evaluate PIKE
    if($sht(ipban=>$si) != $null) {
        # ip is already blocked
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
        exit;
    }
    if (!pike_check_req()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
        $sht(ipban=>$si) = 1;
        exit;
    }
#!endif

    return;
}

# Handle SIP registrations
route[REGISTER] {
    if(!is_method("REGISTER")) return;

    if(isflagset(FLT_NATS)) {
        setbflag(FLB_NATB);
        # Enable SIP NAT pinging
        if ($proto == 'udp') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Enable UDP SIP OPTIONS pinging\n");
            setbflag(FLB_NATSIPPING);
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Enable TCP raw NAT keeper\n");
        }
    }

    # Store in kam_users_location_attrs used transport to retrieve it in lookup
    $xavp(ulattrs=>transport) = $proto;

    $var(contact_uri) = @contact.uri;
    save("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Something went wrong when saving location\n");
            sl_reply_error();
            break;
        case 1:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts inserted ($tu: $var(contact_uri))\n");
            break;
        case 2:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts updated ($tu: $var(contact_uri))\n");
            break;
        case 3:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts deleted ($tu: $var(contact_uri))\n");
            break;
        case 4:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts returned\n");
            break;
    };

    exit;
}

# Detect NAT
route[NATDETECT] {
    force_rport();

    if (nat_uac_test("18")) {
        if ($dlg_var(wholesaleId) != $null) {
           if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: Wholesale behind NAT not supported\n");
           send_reply("400", "Wholesale behind NAT not supported");
           exit;
        }
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: NAT detected\n");
        setflag(FLT_NATS);

        if (is_method("REGISTER")) {
            fix_nated_register();
        } else if (is_method("SUBSCRIBE")) {
            fix_nated_contact();
        } else {
            if(is_first_hop()) {
                # Sets ;alias only if received ip and port differ from those in contact URI
                if (!add_contact_alias()) {
                   if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: Error in aliasing contact $ct\n");
                   send_reply("400", "Bad request");
                   exit;
                }
            }
        }
    }
}

route[WSFIX] {
    if ($dlg_var(wholesaleId) != $null) {
       if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSFIX: Wholesale using WSS\n");
       send_reply("400", "Invalid transport");
       exit;
    }
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSFIX: Websockets detected, fix contact\n");
    # Do NAT traversal stuff for requests from a WebSocket
    # connection - even if it is not behind a NAT!
    # This won't be needed in the future if Kamailio and the
    # WebSocket client support Outbound and Path.
    force_rport();
    if (is_method("REGISTER")) {
        fix_nated_register();
    } else if (!add_contact_alias()) {
        if($dlg_var(nolog) != "1") xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSFIX: Error aliasing contact <$ct>\n");
        send_reply("400", "Bad Request");
        exit;
    }
    return;
}

# Handle NAT
route[NATMANAGE] {
    # RTP handling is always enforced
    route(RTPRELAY);

    # Set FLB_NATB? Only in within-dialog request with nat=yes on Route header initiated by AS
    if (is_request() && has_totag() && check_route_param("nat=yes") && ds_is_from_list("1")) {
       setbflag(FLB_NATB);
    }

    # Return unless FLT_NATS or FLB_NATB are set
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        return;
    }

    # Add nat=yes in record-route? Only in initial requests when called from branch_route
    if (is_request() && !has_totag() && t_is_branch_route()) {
        add_rr_param(";nat=yes");
    }

    # Add contact alias? Only to replies with NATB set and first hop
    if (is_reply() && isbflagset(FLB_NATB) && is_first_hop()) {
        # Sets ;alias only if received ip and port differ from those in contact URI
        if (!add_contact_alias()) {
           if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Error in aliasing contact $ct\n");
           send_reply("400", "Bad request");
           exit;
        }
    }
}

# Configure xlog
route[CONFIGURE_XLOG] {
    # Evaluate only once for SIP methods than can initiate transaction
    if ($dlg_var(log) == "0" || $dlg_var(log)) return;

    $dlg_var(log) = "0";

    if (is_method("INVITE") && $sel(cfg_get.dolog.invite)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REGISTER") && $sel(cfg_get.dolog.register)) {
        $dlg_var(log) = "1";
    }

    if (is_method("PUBLISH") && $sel(cfg_get.dolog.publish)) {
        $dlg_var(log) = "1";
    }

    if (is_method("SUBSCRIBE") && $sel(cfg_get.dolog.subscribe)) {
        $dlg_var(log) = "1";
    }

    if (is_method("NOTIFY") && $sel(cfg_get.dolog.notify)) {
        $dlg_var(log) = "1";
    }

    if (is_method("OPTIONS") && $sel(cfg_get.dolog.options)) {
        $dlg_var(log) = "1";
    }

    if (is_method("MESSAGE") && $sel(cfg_get.dolog.message)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REFER") && $sel(cfg_get.dolog.refer)) {
        $dlg_var(log) = "1";
    }

    # Needed variables
    if ($dlg_var(cidhash) == $null) {
        if ($dlg_var(wholesaleId) == $null) {
            # Set brandId
            if (ds_is_from_list("1")) {
                $var(domain) = $rd; # AS talking
            } else {
                $var(domain) = $fd; # UAC talking
            }

            if (lookup_domain("$var(domain)")) {
                if ($avp(brandId) == $null) {
                    if ($dlg_var(log)) xlog("L_ERR", "Brand couldn't be guessed from '$var(domain)', error\n");
                    send_reply("501", "Internal Server Error");
                    exit;
                }
                $dlg_var(brandId) = $avp(brandId);
            } else {
                if ($dlg_var(log)) xlog("L_ERR", "'$var(domain)' not recognized as local domain, error\n");
                send_reply("404", "Not Here");
                exit;
            }
        }

        # Calculate callid hash
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});
        if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calculated hash for $rm $ci\n");
    }

    return;
}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    if (ds_is_from_list("1")) {
        # AS talking
        $dlg_var(direction) = 'inbound';

        # Set caller
        if (is_present_hf("P-Asserted-Identity")) {
            $dlg_var(caller) = $(ai{uri.user});
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ACCOUNTING: PAI not present in AS call\n");
        }
    } else {
        # Terminal/Retail/Friend talking
        $dlg_var(direction) = 'outbound';

        # -- Set caller
        # Calls from terminals will have dlg_var(caller) set in GENERATE_PUBLISH
        # Calls from friends/retails have dlg_var(caller) set in ADAPT_PAI

        # -- Set caller
        $dlg_var(callee) = $rU;
    }

    $dlg_var(callid) = $ci;

    if (is_present_hf("Diversion")) {
        $dlg_var(diversion) = $(di{uri.user});
    }

    if (is_present_hf("Referred-by")) {
        $dlg_var(referrer) = $(hdr(Referred-by){nameaddr.uri}{uri.user});
    }
}

# Reply generic route (all replies goes through this route)
onreply_route {
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ( $rm =~ $sel(cfg_get.dolog.printmsg_methods) ) xlog("L_WARN", "Received reply:\n\n$mb\n");
}

# Reply generic route (additional, for all replies)
onreply_route[MANAGE_REPLY] {
    # Control call limit if necessary
    if ($avp(AoR) != $null && !is_in_profile("callsPerAor", "$avp(AoR)")) {
        set_dlg_profile("callsPerAor", "$avp(AoR)");
        get_profile_size("callsPerAor", "$avp(AoR)", "$var(currentCalls)");
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_REPLY: '$avp(AoR)' has $var(currentCalls) calls now\n");
    }

    # Account user's missed calls if ringing
    if (is_method("INVITE") && t_check_status("180") && !ds_is_from_list("1")) {
        setflag(FLT_ACCMISSED);
    }

    route(ADAPT_PAI);
    if (is_method("INVITE") && t_check_status("3[0-9]{2}")) {
        route(ADAPT_CONTACT);
    }

    # Manage NAT
    if (t_check_status("[12][0-9]{2}")) {
        route(NATMANAGE);
    }

    # Manage WS
    if (nat_uac_test(64)) { # 64 - Test if the source connection of signaling is WS
        # Do NAT traversal stuff for replies to a WebSocket connection
        # - even if it is not behind a NAT!
        # This won't be needed in the future if Kamailio and the
        # WebSocket client support Outbound and Path.
        add_contact_alias();
    }
}

failure_route[MANAGE_FAILURE] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(NATMANAGE);

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: t_is_canceled, exit here\n");
        exit;
    }
}

failure_route[MANAGE_FAILURE_AS] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(NATMANAGE);

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS '$avp(AVP_DST)' as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Route for branching: Only for INVITEs and BYEs (fork-able)
branch_route[MANAGE_BRANCH] {
    route(TRANSPORT_DETECT);
    route(NATMANAGE);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    if(isbflagset(FLB_WEBSOCKETS)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Answered dialog involves websockets\n");
        $dlg_var(ws) = 'yes';
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Dialog ended, delete keys from dialogs htable starting with $ci\n");
    sht_rm_name_re("dialogs=>$ci::.*");
}

onsend_route {
    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) {
        if (is_request())
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent request:\n\n$snd(buf)\n");
        else
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent reply:\n\n$snd(buf)\n");
    }

    if (is_method("ACK")) $dlg_var(confirmed) = '1';
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_WARN", "XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");
    route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[TRANSPORT_DETECT] {
    if (!is_method("INVITE")) return;

    if (is_request() && !has_totag()) {
        if ($rP == 'ws' || $rP == 'wss' || $proto == 'ws' || $proto == 'wss' || $xavp(ulattrs=>transport) == 'ws' || $xavp(ulattrs=>transport) == 'wss') {
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSPORT-DETECT: Websockets, set FLB_WEBSOCKETS\n");
            setbflag(FLB_WEBSOCKETS);
        }
    }
}

route[RTPRELAY] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;
    if (is_method("ACK") && !has_body("application/sdp")) return;

    if ($dlg_var(mediaRelayType) == 'rtpproxy') {
        route(RTPPROXY);
    } else {
        route(RTPENGINE);
    }
}

route[RTPPROXY] {
    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        set_rtp_proxy_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    if (nat_uac_test("18") && !ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: NAT detected, do not trust SDP addresses\n");
        rtpproxy_manage("cowf");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: No NAT detected, trust SDP addresses\n");
        rtpproxy_manage("coarf");
    }

    if (is_request() && is_method("INVITE") && !has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: Chosen RTPproxy instance $var(RTP_INSTANCE)\n");
    }
}

route[RTPENGINE] {
    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 1) {
        set_rtpengine_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    $var(common_opts) = 'replace-session-connection replace-origin force';

    if (nat_uac_test("18") && !ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: NAT detected, do not trust SDP addresses\n");
        $var(symmetry) = 'symmetric SIP-source-address';
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: No NAT detected, trust SDP addresses\n");
        $var(symmetry) = 'asymmetric trust-address';
    }

    if ($dlg_var(ws) == 'yes' || isbflagset(FLB_WEBSOCKETS)) {
        if ($proto == 'ws' || $proto == 'wss' ) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: Is through $proto, convert to udp\n");
            $var(wsopts) = 'ICE=remove RTP/AVP DTLS=no';
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: Is through $proto (non-ws), convert to wss\n");
            $var(wsopts) = 'ICE=force RTP/SAVPF DTLS=passive';
        }
    } else {
        $var(wsopts) ='ICE=remove RTP/AVP';
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: rtpengine_manage [$var(common_opts) $var(symmetry) $var(wsopts)]\n");
    rtpengine_manage("$var(common_opts) $var(symmetry) $var(wsopts)");
}

# Handle unsolicited NOTIFY messages (non-related to previous SUBSCRIBE)
route[NOTIFY] {
    if (!is_method("NOTIFY")) return;

    if (!ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NOTIFY: Received $rm from not AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # Lookup contact and relay
    route(LOOKUP);
    route(RELAY);
}

route[PRESENCE] {
    if(!is_method("PUBLISH|SUBSCRIBE")) return;

    if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
        send_reply("404", "No voicemail service");
        exit;
    }

    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }

    if(is_method("PUBLISH")) {
        handle_publish();
        t_release();
    } else if(is_method("SUBSCRIBE")) {
        handle_subscribe();
        t_release();
    }
    exit;
}

route[CONTROL_MAXCALLS] {
    if (get_profile_size("activeCallsCompany", "$dlg_var(companyId)", "$avp(activeCallsCompany)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany) calls\n");
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany) calls (error obtaining value)\n");
        if ($dlg_var(maxCallsCompany) > 0) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: Dropping call for security\n");
            send_reply("500", "Internal Server Error [MC]");
            exit;
        }
    }

    if (get_profile_size("activeCallsBrand", "$dlg_var(brandId)", "$avp(activeCallsBrand)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand) calls\n");
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand) calls (error obtaining value)\n");
        if ($dlg_var(maxCallsBrand) > 0) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: Dropping call for security\n");
            send_reply("500", "Internal Server Error [MC]");
            exit;
        }
    }

    if ($dlg_var(maxCallsBrand) > 0 && $avp(activeCallsBrand) >= $dlg_var(maxCallsBrand)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: Call NOT allowed for brand$dlg_var(brandId), 403 Maxcalls exceeded\n");
        send_reply("403", "Maxcalls exceeded");
        exit;
    } else if ($dlg_var(maxCallsCompany) > 0 && $avp(activeCallsCompany) >= $dlg_var(maxCallsCompany)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: Call NOT allowed for company$dlg_var(companyId), 403 Maxcalls exceeded\n");
        send_reply("403", "Maxcalls exceeded");
        exit;
    } else {
         set_dlg_profile("activeCallsCompany", "$dlg_var(companyId)");
         set_dlg_profile("activeCallsBrand", "$dlg_var(brandId)");
    }
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp == WS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "HTTP Request Received from $si:$sp\n");
    } else if ($Rp == WSS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "HTTPS Request Received from $si:$sp\n");
    } else {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "HTTP(S) request received on $Rp, port not allowed\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {
        # Validate Host - make sure the client is using the correct
        # alias for WebSockets
        # if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
        #     if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "Bad host $hdr(Host)\n");
        #     xhttp_reply("403", "Forbidden, bad host", "", "");
        #     exit;
        # }

        # Optional... validate Origin - make sure the client is from an
        # authorized website.  For example,
        #
        # if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
        #     && $hdr(Origin) != "https://communicator.MY_DOMAIN") {
        #       if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "Unauthorized client $hdr(Origin)\n");
        #       xhttp_reply("403", "Forbidden", "", "");
        #       exit;
        # }

        # Optional... perform HTTP authentication

        # ws_handle_handshake() exits (no further configuration file
        # processing of the request) when complete.
        if (ws_handle_handshake()) {
            # Optional... cache some information about the
            # successful connection
            if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "Connection upgrade to websocket was successful\n");
            exit;
        }
    }

    if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "HTTP(S) request received without Upgrade to Websocket header, 404\n");
    xhttp_reply("404", "Not found", "", "");
}

event_route[websocket:closed] {
    if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}


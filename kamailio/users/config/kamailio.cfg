#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - ARTEMIS // Kamailio Proxy for Users
#        vozip+ivozprovider@irontec.com
#
#########################################################################################################

####### Defines #########

#!define TRUNKS_SIP_PORT 5060
#!define SIP_PORT 5060
#!define SIPS_PORT 5061
#!define XMLRPC_PORT 8000
#!define WS_PORT 10080
#!define WSS_PORT 10081

#
# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# FTL_NATS: Tags the transaction as behind NAT. It uses nat_uac_test(18) as NAT-detection mechanism
# 18: 2 + 16
# 2 - the "received" test is used: address in the "Via" header is compared against source IP address of signaling
# 16 - Test if the source port is different from the port in the "Via" header

#!define FLT_NATS 1

# FLB_NATB: Tags the branch as behind NAT.
# Is is set in 2 cases:
# 1. REGISTER behind NAT (received IP:PORT are saved in usrloc table)
# 2. Within-dialog request with nat=yes in Route header (added by this proxy in Record-route of initial transaction)

#!define FLB_NATB 2

# FLB_NATSIPPING: Enables SIP-pinging using OPTIONS for UACs registered behind NAT (see case 1 FLB_NATB)
#!define FLB_NATSIPPING 3

# DLG_FLAG
#!define DLG_FLAG 4

# ACC Flags
#!define FLT_ACC 5
#!define FLT_ACCMISSED 6
#!define FLT_ACCFAILED 7

# Marked for branches involving wss
#!define FLB_WEBSOCKETS 8

# - options
#!define WITH_ANTIFLOOD

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

# Maximum call duration: 3 hours
#!define MAX_DIALOG_TIMEOUT 10800

####### Runtime cfg values (kamcmd cfg.list) #########

# Enable/disable debug logs
dolog.websocket = 1 desc "If 1, debug WS connection upgrade"
dolog.xmlrpc    = 0 desc "If 1, debug XMLRPC"

####### Global Parameters #########

listen=udp:IP:SIP_PORT
listen=tcp:IP:SIP_PORT
listen=tls:IP:SIPS_PORT
listen=tcp:IP:XMLRPC_PORT
listen=tcp:IP:WS_PORT
listen=tls:IP:WSS_PORT

tcp_accept_no_cl=yes # Needed for WS

import_file "multisocket.cfg"

# -- Debug level
# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# If debug level of message is lower than current debug parameter, it gets printed
# Current value: 2 (INFO and higher)
#
# This setting can me modified/seen live running:
# kamcmd-proxyusers cfg.seti core debug X
# kamcmd-proxyusers cfg.get core debug

debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes
version_table="kam_version"

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec IvozProvider v2.10"
user_agent_header="User-Agent: Irontec IvozProvider v2.10"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "usrloc.so"
loadmodule    "registrar.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "nathelper.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "permissions.so"
loadmodule    "sqlops.so"
loadmodule    "cfg_rpc.so"
loadmodule    "dialog.so"
loadmodule    "acc.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "auth.so"
loadmodule    "auth_db.so"
loadmodule    "domain.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "corex.so"
loadmodule    "rtpengine.so"
loadmodule    "websocket.so"
loadmodule    "xhttp.so"
loadmodule    "jsonrpcs.so"
loadmodule    "json.so"
loadmodule    "pua.so"
loadmodule    "pua_dialoginfo.so"
loadmodule    "presence.so"
loadmodule    "presence_xml.so"
loadmodule    "presence_dialoginfo.so"
loadmodule    "ipops.so"
loadmodule    "dialplan.so"
loadmodule    "diversion.so"
loadmodule    "cfgutils.so"
loadmodule    "uac.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# RTPENGINE
modparam("rtpengine", "db_url", DBURL)
modparam("rtpengine", "table_name", "kam_rtpengine")
modparam("rtpengine", "setid_avp", "$avp(setid)")
modparam("rtpengine", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpengine", "setid_default", 0)

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_DSSOCKET)")
modparam("dispatcher", "attrs_avp", "$avp(DSATTRS)")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 2)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@users.ivozprovider.local")
modparam("dispatcher", "hash_pvar", "$avp(hash)")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxyusers_ctl")

# TLS
modparam("tls", "config", "/etc/kamailio/proxyusers/tls.cfg")
modparam("tls", "tls_log", 2)

# JSONRPCS
modparam("jsonrpcs", "fifo_name", "/tmp/kamailio_proxyusers_fifo")

# USRLOC
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc|tm", "xavp_contact", "ulattrs")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# NAT
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")

# REGISTER
modparam("registrar", "min_expires", 300)
modparam("registrar", "max_contacts", 5)
modparam("registrar", "use_path", 1)
modparam("registrar", "path_mode", 2)

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_users_address") # Allowed networks per company
modparam("permissions", "trusted_table", "kam_trusted") # IPs excluded from pike checking and wholesale IPs
modparam("permissions", "db_mode", 1)
modparam("permissions", "grp_col", "companyId")
modparam("permissions", "max_subnets", 4096)
modparam("permissions", "peer_tag_avp", "$avp(trustedTag)")

# ACC
# -- transactions to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- cdr accounting to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 0)
modparam("acc", "cdrs_table", "kam_users_cdrs")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_extra_nullable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);referrer=$dlg_var(referrer);referee=$dlg_var(referee);direction=$dlg_var(direction);userId=$dlg_var(userId);friendId=$dlg_var(friendId);residentialDeviceId=$dlg_var(residentialDeviceId);retailAccountId=$dlg_var(retailAccountId)")

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "callsPerAor; outgoingCallsPerAor")
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "default_timeout", MAX_DIALOG_TIMEOUT)
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n") # Added to requests generated locally by the module (e.g. BYE)
modparam("dialog", "detect_spirals", 0)

# TM
modparam("tm", "fr_timer", 5000)
modparam("tm", "contacts_avp", "tm_contacts")
modparam("tm", "contact_flows_avp", "tm_contact_flows")
modparam("tm", "local_cancel_reason", 200)

# AUTH_DB
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "user_column", "name")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "domain_column", "domain")
modparam("auth_db", "use_domain", 1)

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif

# dialogs htable contains aleg, bleg and applicationserver per dialog
modparam("htable", "htable", "dialogs=>size=10;autoexpire=0")

# SANITY
modparam("sanity", "autodrop", 0)

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_users_domain")
modparam("domain", "domain_attrs_table", "kam_users_domain_attrs")
modparam("domain", "register_myself", 1)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

# PRESENCE
modparam("presence", "db_url", DBURL)
modparam("presence", "presentity_table", "kam_users_presentity")
modparam("presence", "active_watchers_table", "kam_users_active_watchers")
modparam("presence", "watchers_table", "kam_users_watchers")
modparam("presence", "min_expires", 1800)
modparam("presence", "max_expires", 3600)
modparam("presence", "db_update_period", 100)
modparam("presence", "subs_db_mode", 2)

# PRESENCE XML
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "xcap_table", "kam_users_xcap")
modparam("presence_xml", "force_active", 1)

# PRESENCE XML
modparam("presence_dialoginfo", "force_single_dialog", 1)
modparam("presence_dialoginfo", "force_dummy_dialog", 1)

# PUA
modparam("pua", "db_url", DBURL)
modparam("pua", "db_table", "kam_users_pua")
modparam("pua", "db_mode", 0)
modparam("pua", "update_period", 100)

# PUA_DIALOGINFO
# -- needed for call-pickup
modparam("pua_dialoginfo", "include_callid", 0)
modparam("pua_dialoginfo", "include_tags", 0)
modparam("pua_dialoginfo", "include_localremote", 0)
modparam("pua_dialoginfo", "caller_confirmed", 0)
modparam("pua_dialoginfo", "use_pubruri_avps", 1)
modparam("pua_dialoginfo", "pubruri_caller_avp", "$avp(pubruri_caller)")
modparam("pua_dialoginfo", "pubruri_callee_avp", "$avp(pubruri_callee)")
modparam("pua_dialoginfo", "pubruri_caller_dlg_var", "pubruri_caller")
modparam("pua_dialoginfo", "pubruri_callee_dlg_var", "pubruri_callee")

# DIALPLAN
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "table_name", "kam_dialplan")
modparam("dialplan", "attrs_pvar", "$avp(s:appliedrule)")

# UAC
modparam("uac", "restore_mode","auto")
modparam("uac", "restore_dlg", 1)

####### Routing Logic ########

request_route {
    route(REQINIT);

    route(IS_FROM_INSIDE);

    route(CIDHASH);

    if (is_method("OPTIONS")) {
        force_rport();
        send_reply("200", "I'm here!");
        exit;
    }

    xnotice("[$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($proto:$si:$sp) [$ci]\n");

    route(ANTIFLOOD);

    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        xinfo("[$dlg_var(cidhash)] ----> $rm from $si\n");
        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RELAY);
        }

        xerr("[$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # Manage retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    ### only initial requests (no To tag)

    # Discard unsupported methods
    route(FILTER_METHODS);

    # Remove preloaded route headers
    remove_hf("Route");

    # Manage authentication
    route(AUTH);

    # Handle REGISTER
    route(REGISTER);

    # Handle NOTIFY, SUBSCRIBE and PUBLISH
    route(PRESENCE);

    # Set caller and callee to generate PUBLISH
    route(GENERATE_PUBLISH);

    # From now on, everything is for INVITEs: track dialog
    if (!is_known_dlg() || $si == $var(trunksAddress)) {
        dlg_manage();
        route(CIDHASH);
    }

    # Inspect new request
    route(CLASSIFY);

    # Add record-route to INVITE requests
    record_route();

    # Route by source
    if ($var(is_from_inside)) {
        xinfo("[$dlg_var(cidhash)] $dlg_var(type) inside call\n");
        route(REPLACES);
        route(PARSE_X_HEADERS);
        route(GET_INFO_FROM_CALLEE);
        route(MAXCALLS_USER);
        route(LOOKUP);
    } else {
        xinfo("[$dlg_var(cidhash)] $dlg_var(type) outside call\n");
        route(GET_INFO_FROM_CALLER);
        route(FILTER_BY_SCR_ADDR);
        route(ADAPT_RURI_IN);
        route(ADAPT_DIVERSION);
        route(ADAPT_CALLER);
        #!ifdef WITH_MULTISOCKET
        if ($Ri != $sel(cfg_get.address.main)) {
            $fs = "udp:" + $sel(cfg_get.address.main) + ":5060";
            $dlg_var(extra_socket) = $Ri;
            xwarn("[$dlg_var(cidhash)] force_send_socket to main address (UAC talking to non-main address $dlg_var(extra_socket))\n");
        }
        #!endif
        if ($dlg_var(type) == 'wholesale' || $dlg_var(type) == 'retail') {
            route(DISPATCH_TO_TRUNKS);
        } else {
            route(DISPATCH_TO_AS);
        }
    }

    if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    route(ACCOUNTING);
    route(RELAY);
}

# This route sets $var(is_from_inside): 1 / 0
#   - 1: request/response comes from the inside
#   - 0: request/response comes from the outside world
route[IS_FROM_INSIDE] {
    if (ds_is_from_list("1") || $si == $var(trunksAddress)) {
        $var(is_from_inside) = 1; # as / trunks
    } else {
        $var(is_from_inside) = 0; # uacs
    }
}

route[FILTER_METHODS] {
    if (!is_method("INVITE|REGISTER|SUBSCRIBE|PUBLISH|NOTIFY")) {
        xwarn("[$dlg_var(cidhash)] FILTER-METHODS: $rm not supported for $dlg_var(type)\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    if (is_method("PUBLISH") && src_ip != myself) {
        send_reply("405", "Method Not Allowed");
        exit;
    }
}

# Sets dlg_var(cidhash)
route[CIDHASH] {
    if ($dlg_var(cidhash) == $null)
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});
}

route[ADAPT_RURI_OUT] {
    if ($var(ddi_in) != 'yes') return;

    # Use callee as destination instead of username
    xinfo("[$dlg_var(cidhash)] ADAPT-RURI-OUT: Set callee as destination ($rU -> $dlg_var(callee))\n");
    $rU = $dlg_var(callee);

    # Need adaptation?
    if ($(rU{s.substr,0,1}) == '+') {
        $var(number) = $rU;
        xinfo("[$dlg_var(cidhash)] ADAPT-RURI-OUT: Before -> $var(number)\n");
        $var(transformation) = $dlg_var(tr_callee_out);
        xinfo("[$dlg_var(cidhash)] ADAPT-RURI-OUT: Adapt '$var(number)' using rule '$var(transformation)'\n");
        route(APPLY_TRANSFORMATION);
        $rU = $var(transformated);
        xinfo("[$dlg_var(cidhash)] ADAPT-RURI-OUT: After -> $var(transformated) (applied rule: '$avp(appliedrule)')\n");
    }
}

route[ADAPT_RURI_IN] {
# Only in initial INVITE requests from subscribers
    route(GET_ROUTING_TAG);

    $var(number) = $rU;
    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        xinfo("[$dlg_var(cidhash)] ADAPT-RURI-IN: '$var(number)' is internal, do not transformate\n");
        return;
    }

    $var(transformation) = $dlg_var(tr_callee_in);

    xinfo("[$dlg_var(cidhash)] ADAPT-RURI-IN: Adapt '$var(number)' using rule '$var(transformation)'\n");
    route(APPLY_TRANSFORMATION);
    $rU = $var(transformated);
}

# Detects routing tag, sets header with tag and strips it from r-uri
route[GET_ROUTING_TAG] {
    if ($dlg_var(type) != 'wholesale' && $dlg_var(type) != 'retail') return;

    # Guess routing tag
    sql_query("cb", "SELECT tag, RT.id FROM RoutingTags RT INNER JOIN CompaniesRelRoutingTags CRRT ON CRRT.routingTagId = RT.id WHERE CRRT.companyId = '$dlg_var(companyId)'", "rb");
    $var(tag) = "";
    if ($dbr(rb=>rows) > 0) {
        $var(i) = 0;
        while($var(i) < $dbr(rb=>rows)) {
            $var(currentTag) = $dbr(rb=>[$var(i),0]);
            if ($rU =~ "^" + $var(currentTag)) {
                $var(tag) = $var(currentTag);
                $var(tagId) = $dbr(rb=>[$var(i),1]);
                break;
            }
            $var(i) = $var(i) + 1;
        }
    }
    sql_result_free("rb");

    # Leave if no routing tag matched
    if ($var(tag) == "") return;

    # Add headers and strip from request uri
    insert_hf("X-Info-RoutingTagId: $var(tagId)\r\n");
    insert_hf("X-Info-RoutingTag: $var(tag)\r\n");
    $rU = $(rU{s.strip, $(var(tag){s.len})});

    xinfo("[$dlg_var(cidhash)] GET-ROUTING-TAG: Detected tag '$var(tag)' (id: $var(tagId)), new destination: $rU\n");

    return;
}

route[ADAPT_REFERTO] {
# Only in within-dialog REFER requests from subscribers
    if(!is_method("REFER")) return;
    if($dlg_var(type ) != 'vpbx') return;

    if (search_hf("Refer-To", "Replaces", "a")) {
        xinfo("[$dlg_var(cidhash)] ADAPT-REFERTO: Replacer found in Refer-To, return\n");
        return;
    }

    $var(number) = $(rt{uri.user});

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        xinfo("[$dlg_var(cidhash)] ADAPT-REFERTO: '$var(number)' is internal, do not transformate\n");
        return;
    }

    $var(transformation) = $dlg_var(tr_callee_in);

    xinfo("[$dlg_var(cidhash)] ADAPT-REFERTO: Adapt '$var(number)' using rule '$var(transformation)'\n");
    route(APPLY_TRANSFORMATION);
    $var(newreferto) = '<sip:' + $var(transformated) + '@' + $(rt{uri.host}) + '>';
    remove_hf("Refer-To");
    append_hf("Refer-To: $var(newreferto)\r\n");
}

route[ADAPT_CALLER] {
    # First of all: do I have to mangle caller?
    if (!$var(is_from_inside)) {
        if ($dlg_var(type) == "retail" && !is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
            route(FORCE_FALLBACK_DDI);
            return;
        }

        if ($dlg_var(type) == "residential" && !is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
            return;
        }

        if ($dlg_var(type) == 'vpbx') {
            if ($dlg_var(userId) != $null) {
                remove_hf("P-Asserted-Identity");
                remove_hf("Remote-Party-ID");
                return;
            } else if ($dlg_var(friendId) != $null) {
                if (!is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
                    return;
                }
            }
        }
    } else {
        if ($dlg_var(type) == "vpbx" && !is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
            return;
        }
    }

    route(GET_CALLER); # Greps caller and sets it in $var(number)

    if (is_request() && !has_totag() && $var(is_from_inside)) {
        # Save caller in e164 for accounting
        $dlg_var(caller) = $var(number);
    }

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        xinfo("[$dlg_var(cidhash)] ADAPT-CALLER: '$var(number)' is internal, do not transformate\n");
        return;
    }

    if ($var(is_from_inside)) {
        $var(transformation) = $dlg_var(tr_caller_out);
    } else {
        $var(transformation) = $dlg_var(tr_caller_in);
    }

    xinfo("[$dlg_var(cidhash)] ADAPT-CALLER: Adapt '$var(number)' using rule '$var(transformation)'\n");
    route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)

    if ($var(is_from_inside)) {
        route(SET_PAI);
    } else {
        $var(number) = $var(transformated);
        route(CALLER_CHECK);
        $var(transformated) = $var(number);
        route(SET_CALLER);
    }

    if (is_request() && !has_totag() && !$var(is_from_inside)) {
        # Save caller in e164 for accounting
        $dlg_var(caller) = $var(transformated);
    }
}

route[FORCE_FALLBACK_DDI] {
    $var(number) = $null;
    route(CALLER_CHECK);
    append_hf("P-Asserted-Identity: <sip:$var(number)@$fd>\r\n");
}

# Sets caller in $var(number) seeking in PAI/RPID/From (in this order)
route[GET_CALLER] {
    # Where is my caller? PAI/RPID/From?
    if (is_present_hf("P-Asserted-Identity")) {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: PAI present: $(ai{uri.user})\n");
        $var(number) = $(ai{uri.user});
    } else if (is_present_hf("Remote-Party-ID")) {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: RPID present: $(re{uri.user})\n");
        $var(number) = $(re{uri.user});
    } else {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: Nor PAI nor RPID present, only From ($fU)! :(\n");
        $var(number) = $fU;
    }
}

# Sets $var(transformated) in existing origin headers (From + PAI + RPID)
route[SET_CALLER] {
    # Mangle From only for initial requests from wholesale clients without PAI nor RPID
    if (is_request() && !has_totag()) {
        if ($dlg_var(type) == 'wholesale' && !is_present_hf("P-Asserted-Identity") && !is_present_hf("Remote-Party-ID")) {
            if ($fU != $var(transformated)) {
                $var(newfromuri) = 'sip:' + $var(transformated) + '@' + $fd;
                uac_replace_from("","$var(newfromuri)");
            }
        }
    }

    if (is_present_hf("P-Asserted-Identity")) {
        if ($(ai{uri.user}) != $var(transformated)) { # If new value differs from previous, change
            remove_hf("P-Asserted-Identity");
            append_hf("P-Asserted-Identity: <sip:$var(transformated)@$(ai{uri.host})>\r\n");
        }
    }

    if (is_present_hf("Remote-Party-ID")) {
        if ($(re{uri.user}) != $var(transformated)) { # If new value differs from previous, change
            remove_hf("Remote-Party-ID");
            append_hf("Remote-Party-ID: <sip:$var(transformated)@$(re{uri.host})>\r\n");
        }
    }
}

# Sets $var(transformated) in new PAI or existing PAI (and makes From username equal)
route[SET_PAI] {
    if (is_request() && !has_totag()) {
        if ($fU != $var(transformated)) {
            $var(newfromuri) = 'sip:' + $var(transformated) + '@' + $fd;
            uac_replace_from("", "$var(newfromuri)");
        }
    }

    if (is_present_hf("Remote-Party-ID")) remove_hf("Remote-Party-ID");

    if (is_present_hf("P-Asserted-Identity")) {
        if ($(ai{uri.user}) != $var(transformated)) { # If new value differs from previous, change
            remove_hf("P-Asserted-Identity");
            append_hf("P-Asserted-Identity: <sip:$var(transformated)@$(ai{uri.host})>\r\n");
        }
    } else {
        $var(newpai) = 'sip:' + $var(transformated) + '@' + $fd;
        append_hf("P-Asserted-Identity: <$var(newpai)>\r\n");
    }

    return;
}

route[ADAPT_CONTACT] {
# Only in 3XX replies to INVITEs from subscribers
    if (!is_present_hf("Contact")) return;

    if ($var(is_from_inside)) {
        xerr("[$dlg_var(cidhash)] ADAPT-CONTACT: 3XX reply from AS, this shouldn't happen\n");
        return;
    }

    $var(number) = @contact.uri.user;

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        xinfo("[$dlg_var(cidhash)] ADAPT-CONTACT: '$var(number)' is internal, do not transformate\n");
        return;
    }

    $var(transformation) = $dlg_var(tr_callee_in);
    xinfo("[$dlg_var(cidhash)] ADAPT-CONTACT: After -> $var(transformated) (applied rule: '$avp(appliedrule)')\n");
    route(APPLY_TRANSFORMATION);
    $var(newcontact) = '<sip:' + $var(transformated) + '@' + @contact.uri.host + '>';
    remove_hf("Contact");
    append_hf("Contact: $var(newcontact)\r\n");
}

route[ADAPT_DIVERSION] {
# In all initial INVITE requests
    if (!is_present_hf("Diversion")) return;

    # Only adapt first Diversion header
    $var(number) = $(di{uri.user});
    if ($var(number) == $null) {
        xinfo("[$dlg_var(cidhash)] ADAPT-DIVERSION: No number extracted, return\n");
        return;
    }

    route(IS_INTERNAL);
    if ($avp(is_internal) == '1') {
        xinfo("[$dlg_var(cidhash)] ADAPT-DIVERSION: '$var(number)' is internal, do not transformate\n");
        $dlg_var(diversion) = $var(number);
        return;
    }

    $avp(reason) = @hf_value.diversion[0].param['reason'];
    if ($avp(reason) == $null) {
        xinfo("[$dlg_var(cidhash)] ADAPT-DIVERSION: No reason extracted, set 'deflection'\n");
        $avp(reason) = 'deflection';
    }

    if ($var(is_from_inside)) {
        $var(transformation) = $dlg_var(tr_caller_out);
    } else {
        $var(transformation) = $dlg_var(tr_caller_in);
    }

    xinfo("[$dlg_var(cidhash)] ADAPT-DIVERSION: Adapt '$var(number)' using rule '$var(transformation)'\n");
    route(APPLY_TRANSFORMATION);
    if ($dlg_var(type) == "retail" && !$var(is_from_inside)) {
        # Check if Diversion is valid before proceeding
        $var(number) = $var(transformated);
        route(VALIDATE_CLID_NUMBER);

        if ($dlg_var(valid_clid) == "no") {
            xwarn("[$dlg_var(cidhash)] ADAPT-DIVERSION: Remove Diversion headers as $var(number) is not valid for retail account $dlg_var(retailAccountId)\n");
            remove_hf("Diversion");
            return;
        }
    }
    remove_hf_value("Diversion[0]");
    add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $(di{uri.host}));
    $dlg_var(diversion) = $var(transformated);
}

# Evaluates if $var(number) is valid for $dlg_var(companyId). If not, $var(number) is set to fallback DDI
route[CALLER_CHECK] {
    if (!is_request() || has_totag()) return;

    if ($dlg_var(type) != "retail" || $dlg_var(valid_clid) == "yes") return;

    if ($var(number) != $null) {
        route(VALIDATE_CLID_NUMBER);
        if ($dlg_var(valid_clid) == "yes") return;
    }

    sql_xquery("cb", "SELECT DDIE164 FROM RetailAccounts RA INNER JOIN Companies C ON C.id = RA.companyId INNER JOIN DDIs D ON D.id = COALESCE(RA.outgoingDdiId, C.outgoingDdiId) WHERE RA.id = $dlg_var(retailAccountId)", "ra");

    $var(fallback_ddi) = $xavp(ra=>DDIE164);
    if (!$var(fallback_ddi)) {
        xerr("[$dlg_var(cidhash)] CALLER-CHECK: No fallback DDI for retail account $dlg_var(retailAccountId)\n");
        send_reply("403", "Forbidden (invalid CLID)");
        exit;
    }

    xwarn("[$dlg_var(cidhash)] CALLER-CHECK: Force $var(fallback_ddi) as PAI/RPID ($var(number)) is not valid for retail account $dlg_var(retailAccountId)\n");
    $var(number) = $var(fallback_ddi);
    $dlg_var(caller) = $var(fallback_ddi);
}

# Sets $dlg_var(valid_clid) to "yes" if $var(number) is valid for $dlg_var(companyId), to "no" otherwise
route[VALIDATE_CLID_NUMBER] {

    sql_query("cb", "SELECT DDIE164 FROM DDIs WHERE companyId='$dlg_var(companyId)' AND DDIE164='$var(number)'", "rc");

    if ($dbr(rc=>rows) > 0) {
        xinfo("[$dlg_var(cidhash)] VALIDATE-CLID-NUMBER: $var(number) is VALID for company $dlg_var(companyId)\n");
        $dlg_var(valid_clid) = "yes";
    } else {
        xwarn("[$dlg_var(cidhash)] VALIDATE-CLID-NUMBER: $var(number) is NOT VALID for company $dlg_var(companyId)\n");
        $dlg_var(valid_clid) = "no";
    }

    sql_result_free("rc");
}

# Apply $var(transformation) transformations (if set) to $var(number)
# Sets result in $var(transformated)
route[APPLY_TRANSFORMATION] {
    $var(transformated) = $var(number);
    $avp(appliedrule) = $null;

    dp_translate("$(var(transformation){s.int})", "$var(number)/$var(transformated)");

    # If no rule applied, re-set value
    if ($avp(appliedrule) == $null)
        $var(transformated) = $var(number);

    xinfo("[$dlg_var(cidhash)] APPLY-TRANSFORMATION: Number after: $var(transformated) (applied rule: '$avp(appliedrule)')\n");
}

route[REQINIT] {
    # Easy dropping for scanners
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent|pplsip" || search("sipvicious")) {
        xwarn("REQINIT: Dropping scanner request ----> $rm from $si\n");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        xerr("REQINIT: Dropping malformed SIP message from $si:$sp\n");
        exit;
    }

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        xerr("REQINIT: Too many hops for SIP message from $si:$sp\n");
        send_reply("483","Too Many Hops");
        exit;
    }
}

route[GENERATE_PUBLISH] {
    sql_xquery("cb", "SELECT C.type FROM Companies C JOIN Domains D ON D.id=C.domainId WHERE D.domain='$fd'", "ra");
    if ($xavp(ra=>type) != 'vpbx') return; # Skip logic for non vpbx clients

    if ($var(is_from_inside)) {
        # Set X-Info-Callee as 'callee' instead of user in To header
        $avp(pubruri_callee)= "sip:" + $hdr(X-Info-Callee) + "@" + $fd;
    } else {
        sql_xquery("cb", "SELECT extension, externalIpCalls FROM kam_users WHERE name='$fU' AND domain='$fd'", "rp");
        if ($xavp(rp=>extension) == $null) return; # No PUBLISH for calls from non-terminals

        # Terminal calling
        # Set user extension as 'caller' instead of user in From header
        $avp(pubruri_caller)= "sip:" + $xavp(rp=>extension) + "@" + $fd;

        $dlg_var(caller) = $xavp(rp=>extension); # Set accounting dlg_var too

        # Is this user allowed to call from non-granted IPs?
        $avp(externalIpCalls) = $xavp(rp=>externalIpCalls);
    }
}

route[MAXCALLS_USER] {
    if (!$dlg_var(maxcallsUser)){
        xinfo("[$dlg_var(cidhash)] MAXCALLS-USER: '$tU@$td' has no call-limit, proceed\n");
        return;
    }

    get_profile_size("callsPerAor", "$tU@$td", "$var(currentCalls)");
    xinfo("[$dlg_var(cidhash)] MAXCALLS-USER: '$tU@$td' has $var(currentCalls) out of $dlg_var(maxcallsUser) active calls\n");

    if ($var(currentCalls) >= $dlg_var(maxcallsUser)) {
        xwarn("[$dlg_var(cidhash)] MAXCALLS-USER: Reject call\n");
        send_reply("486", "Maxcalls exceeded");
        exit;
    } else {
        $avp(AoR) = $tU + '@' + $td;
    }
}

route[REPLACES] {
    # Save CallID <-> AS relationship
    $sht(dialogs=>$ci::applicationserver) = 'sip:' + $si + ':6060';

    if (! is_present_hf("Replaces")) return;

    # AS sending an INVITE with REPLACE header, guess which AS is the proper destination
    xinfo("[$dlg_var(cidhash)] REPLACES: AS sending a INVITE with Replaces header, forward to proper AS\n");

    # Extract CallId from Replaces header
    $var(replace_uri) = $(hdr(Replaces){s.select,0,;});
    xinfo("[$dlg_var(cidhash)] REPLACES: Which AS is handling $(hdr(Replaces){s.select,0,;})?\n");

    if ($sht(dialogs=>$var(replace_uri)::applicationserver) != $null) {
        $du = $sht(dialogs=>$var(replace_uri)::applicationserver);
        xinfo("[$dlg_var(cidhash)] REPLACES: Forward to '$du'\n");
        $fu = 'sip:replacer@users.ivozprovider.local'; # Change From header too
        route(RELAY);
    } else {
        xerr("[$dlg_var(cidhash)] REPLACES: CallID not found, 500\n");
        send_reply("500", "CallID not found");
        exit;
    }
    # Note: this dialog won't be inserted into kam_acc_cdrs (INSERT fails) and that's OK
}

route[DISPATCH_TO_TRUNKS] {
    $du = "sip:trunks.ivozprovider.local:" + TRUNKS_SIP_PORT;

    # Add X-Info-Headers for trunks
    insert_hf("X-Info-BrandId: $dlg_var(brandId)\r\n");
    insert_hf("X-Info-CompanyId: $dlg_var(companyId)\r\n");
    insert_hf("X-Info-Type: $dlg_var(type)\r\n");

    if ($dlg_var(type) == "retail") {
        insert_hf("X-Info-RetailAccountId: $dlg_var(retailAccountId)\r\n");

        # Check if recordings are enabled for DDI
        sql_xquery("cb", "SELECT recordCalls FROM DDIs WHERE DDIE164='$dlg_var(caller)'", "ra");
        if ($xavp(ra=>recordCalls) == 'all' || $xavp(ra=>recordCalls) == 'outbound') {
            xerr("[$dlg_var(cidhash)] DISPATCH-TO-TRUNKS: Set X-Info-Record for $dlg_var(caller)\n");
            insert_hf("X-Info-Record: yes\r\n");
        }
    }
}

route[DISPATCH_TO_AS] {
    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Static routing to specific AS?
    if ($avp(distributeMethod) == 'static') {
        $du = "sip:" + $avp(asAddress) + ":6060";
        xinfo("[$dlg_var(cidhash)] DISPATCH-TO-AS: Company has static routing enabled\n");
    } else {
        if ($avp(distributeMethod) == 'hash') {
            $avp(hash) = $dlg_var(companyId);
            # hash over $avp(hash)
            xinfo("[$dlg_var(cidhash)] DISPATCH-TO-AS: Dispatch hashing '$avp(hash)'\n");
            $var(alg) = 7;
        } else {
            # round robin dispatching on ASs (distributeMethod == 'rr')
            xinfo("[$dlg_var(cidhash)] DISPATCH-TO-AS: dispatch to any AS (round robin)\n");
            $var(alg) = 4;
        }

        if(!ds_select_dst("1", "$var(alg)")) {
            xerr("[$dlg_var(cidhash)] DISPATCH-TO-AS: No destination found\n");
            send_reply("404", "No destination");
            exit;
        } else {
            xinfo("[$dlg_var(cidhash)] DISPATCH-TO-AS: $avp(AVP_CNT) destination(s) found\n");
            t_on_failure("MANAGE_FAILURE_AS");
        }
    }

    xinfo("[$dlg_var(cidhash)] DISPATCH-TO-AS: going to <$ru> via <$du>\n");

    # Save CallID <-> AS relationship
    $sht(dialogs=>$ci::applicationserver) = $du;
}

route[LOOKUP] {
    route(STATIC_LOCATION);
    if ($var(location) != 0) return;

    lookup("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(retail_forward) == 'yes') {
                xinfo("[$dlg_var(cidhash)] LOOKUP: 404 calling to retail account with call-forward configured");
                $avp(apply_cfwd) = 'yes';
                route(DISPATCH_TO_AS);
                return;
            }
            xerr("[$dlg_var(cidhash)] LOOKUP: Contact not found for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
        case -2:
            xerr("[$dlg_var(cidhash)] LOOKUP: Contacts found, but method not supported for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
        case -3:
            xerr("[$dlg_var(cidhash)] LOOKUP: Internal error during processing lookup for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
    };

    # Handle multiple contacts
    if (!t_load_contacts()) {
        xerr("[$dlg_var(cidhash)] LOOKUP: Error loading contacts for $rU\n");
        send_reply("500", "Server Internal Error - Cannot load contacts");
        exit;
    }

    # Load contact or contacts
    if (!t_next_contacts()) {
        xinfo("[$dlg_var(cidhash)] LOOKUP: t_next_contacts - One contact found for $tu, calling $ru\n");
    } else {
        xinfo("[$dlg_var(cidhash)] LOOKUP: t_next_contacts - Multiple contacts found for $tu, parallel forking\n");
    }

    if ($dlg_var(retail_forward) == 'yes') t_on_failure("MANAGE_FAILURE_RETAIL");
}

route[APPLY_RETAIL_CFW] {
    # Save From user in PAI if PAI not present
    if (!is_present_hf("P-Asserted-Identity")) {
        append_hf("P-Asserted-Identity: <$dlg_var(rcfw_newpaiuri)>\r\n");
    }

    # Save original caller as caller
    $dlg_var(caller) = $dlg_var(rcfw_newpaiuser);

    # Set retail account AoR as From header
    uac_replace_from("","$dlg_var(rcfw_newfromuri)");

    # Set called DDI in Diversion header
    add_diversion("deflection", "$dlg_var(rcfw_newdiversionuri)");

    # Modify R-URI with call forward target
    $ru = $dlg_var(rcfw_newruri);

    xinfo("[$dlg_var(cidhash)] APPLY-RETAIL-CFW: Call forward to $rU\n");
}

route[STATIC_LOCATION] {
    $var(location) = 0;

    sql_xquery("cb", "SELECT type FROM kam_users WHERE companyId=$dlg_var(companyId) AND name='$rU' AND domain='$rd'", "ra");
    if ($xavp(ra=>type) == 'friend') {
        $var(table) = 'Friends';
    } else if ($xavp(ra=>type) == 'retail') {
        $var(table) = 'RetailAccounts';
    } else if ($xavp(ra=>type) == 'residential') {
        $var(table) = 'ResidentialDevices';
    } else {
        $var(ddi_in) = 'no'; # Terminals need AoR in R-URI
        return;
    }

    sql_xquery("cb", "SELECT name, domain, directConnectivity, ip, port, transport, ddiIn FROM $var(table) t LEFT JOIN Domains D ON t.domainId=D.id WHERE t.name='$rU' AND D.domain='$rd'", "rb");
    $var(ddi_in) = $xavp(rb=>ddiIn);
    xinfo("[$dlg_var(cidhash)] STATIC-LOCATION: ddi_in: $var(ddi_in)\n");

    if ($xavp(rb=>directConnectivity) == 'no') return;

    $var(location) = "sip:" + $xavp(rb=>name) + '@' + $xavp(rb=>ip);

    if ($(xavp(rb=>port){s.len}) > 0 && $xavp(rb=>port) != "5060") {
        $var(location) = $var(location) + ':' + $xavp(rb=>port);
    }

    if ($xavp(rb=>transport) != "udp") {
        $var(location) = $var(location) + ';transport=' + $xavp(rb=>transport);
    }

    xinfo("[$dlg_var(cidhash)] STATIC-LOCATION: Call for static $xavp(ra=>type), route to '$var(location)'\n");
    $ru = $var(location);

    setbflag(FLB_NATB); # Assume behind NAT (port-forwarding direct connectivity)

    return;
}

route[GET_INFO_FROM_COMPANY] {
    sql_xquery("cb", "SELECT C.mediaRelaySetsId, CONCAT(C.transformationRuleSetId,0) AS caller_in, CONCAT(C.transformationRuleSetId,1) AS callee_in, CONCAT(C.transformationRuleSetId,2) AS caller_out, CONCAT(C.transformationRuleSetId,3) AS callee_out FROM Companies C JOIN Brands B ON B.id=C.brandId WHERE C.id='$dlg_var(companyId)'", "ra");

    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);

    $dlg_var(tr_caller_in) = $xavp(ra=>caller_in);
    $dlg_var(tr_callee_in) = $xavp(ra=>callee_in);
    $dlg_var(tr_caller_out) = $xavp(ra=>caller_out);
    $dlg_var(tr_callee_out) = $xavp(ra=>callee_out);
}

route[GET_INFO_FROM_CALLEE] {
    # Get needed information from To header
    sql_xquery("cb", "SELECT KU.type AS calleeType, KU.objectId, KU.maxCalls, KU.caller_in, KU.callee_in, KU.caller_out, KU.callee_out, C.mediaRelaySetsId, C.onDemandRecord FROM kam_users KU LEFT JOIN Companies C ON C.id=KU.companyId LEFT JOIN ApplicationServers AppS ON AppS.id=C.applicationServerId WHERE KU.name='$rU' AND KU.domain='$rd'", "ra");

    if ($xavp(ra=>calleeType) == 'terminal') {
        $dlg_var(userId) = $xavp(ra=>objectId); # user
    } else if($xavp(ra=>calleeType) == 'friend') {
        $dlg_var(friendId) = $xavp(ra=>objectId); # friend
    } else if($xavp(ra=>calleeType) == 'retail') {
        $dlg_var(retailAccountId) = $xavp(ra=>objectId); # retail
    } else {
        $dlg_var(residentialDeviceId) = $xavp(ra=>objectId); # residential
    }

    # Transformations
    $dlg_var(tr_caller_in) = $xavp(ra=>caller_in);
    $dlg_var(tr_callee_in) = $xavp(ra=>callee_in);
    $dlg_var(tr_caller_out) = $xavp(ra=>caller_out);
    $dlg_var(tr_callee_out) = $xavp(ra=>callee_out);

    if ($xavp(ra=>onDemandRecord) != '0') {
        $dlg_var(onDemandRecord) = '1';
    }

    # Remaining info
    $dlg_var(maxcallsUser) = $xavp(ra=>maxCalls);
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);

    # Get retail call-forward settings
    if ($dlg_var(type) == 'retail') {
        route(GET_RETAIL_CFW_SETTINGS);
    }
}

route[GET_RETAIL_CFW_SETTINGS] {
    sql_xquery("cb", "SELECT RA.name, D.domain, CONCAT(C.countryCode, CFS.numberValue) AS CfwTarget FROM RetailAccounts RA INNER JOIN Domains D ON RA.domainId=D.id INNER JOIN CallForwardSettings CFS ON CFS.retailAccountId=RA.id INNER JOIN Countries C ON C.id=CFS.numberCountryId WHERE CFS.enabled=1 AND CFS.callForwardType='userNotRegistered' AND RA.id='$dlg_var(retailAccountId)'", "ra");

    # Leave if no call forward configured
    if ($xavp(ra=>CfwTarget) == $null) return;

    $dlg_var(rcfw_newfromuri) =  "sip:" + $xavp(ra=>name) + '@' + $xavp(ra=>domain);
    $dlg_var(rcfw_newpaiuri) = "sip:" + $fU + '@' + $xavp(ra=>domain);
    $dlg_var(rcfw_newpaiuser) = $fU;
    $dlg_var(rcfw_newdiversionuri) = 'sip:' + $dlg_var(callee) + '@' + $xavp(ra=>domain);
    $dlg_var(rcfw_newruri) = "sip:" + $xavp(ra=>CfwTarget) + '@' + $xavp(ra=>domain);

    $dlg_var(retail_forward) = 'yes';
}

route[GET_INFO_FROM_CALLER] {
    if ($dlg_var(type) == 'wholesale') {
        route(GET_INFO_FROM_COMPANY);
    } else {
        route(GET_INFO_FROM_FROM);
    }
}

route[GET_INFO_FROM_FROM] {
    # Get needed information from terminal name
    sql_xquery("cb", "SELECT KU.type AS callerType, KU.objectId, KU.caller_in, KU.callee_in, KU.caller_out, KU.callee_out, C.mediaRelaySetsId, C.ipFilter, C.distributeMethod, AppS.ip AS asAddress, C.onDemandRecord FROM kam_users KU LEFT JOIN Companies C ON C.id=KU.companyId JOIN Brands B ON C.brandId=B.id LEFT JOIN ApplicationServers AppS ON AppS.id=C.applicationServerId WHERE KU.name='$fU' AND KU.domain='$fd'", "ra");

    if ($xavp(ra=>callerType) == 'terminal') {
        $dlg_var(userId) = $xavp(ra=>objectId); # user
    } else if($xavp(ra=>callerType) == 'friend') {
        $dlg_var(friendId) = $xavp(ra=>objectId); # friend
    } else if($xavp(ra=>callerType) == 'retail') {
        $dlg_var(retailAccountId) = $xavp(ra=>objectId); # retail
    } else {
        $dlg_var(residentialDeviceId) = $xavp(ra=>objectId); # residential
    }

    $dlg_var(tr_caller_in) = $xavp(ra=>caller_in);
    $dlg_var(tr_callee_in) = $xavp(ra=>callee_in);
    $dlg_var(tr_caller_out) = $xavp(ra=>caller_out);
    $dlg_var(tr_callee_out) = $xavp(ra=>callee_out);

    $avp(ipFilter) = $xavp(ra=>ipFilter);
    $avp(distributeMethod) = $xavp(ra=>distributeMethod);
    $avp(asAddress) = $xavp(ra=>asAddress);
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);

    if ($xavp(ra=>onDemandRecord) != '0') {
        $dlg_var(onDemandRecord) = '1';
    }
}

route[FILTER_BY_SCR_ADDR] {
    if (!$avp(ipFilter)) {
        xinfo("[$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: IP filter is disabled for company '$dlg_var(companyId)'\n");
        return;
    }

    # Company has IP check enabled

    if (allow_source_address($dlg_var(companyId))) {
        xinfo("[$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: Valid source $si for company '$dlg_var(companyId)'\n");
        return;
    }

    # Roadwarrior logic
    if ($dlg_var(type) == 'vpbx') {
        sql_xquery("cb", "SELECT externalIpCalls FROM kam_users WHERE name='$fU' AND domain='$fd'", "rp");
        $avp(externalIpCalls) = $xavp(rp=>externalIpCalls);
        if ($avp(externalIpCalls) > 0) {
            get_profile_size("outgoingCallsPerAor", "$fU@$fd", "$var(currentOutgoingCalls)");
            xinfo("[$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: '$fU@$fd' has $var(currentOutgoingCalls) out of $avp(externalIpCalls) outgoing calls\n");

            if ($var(currentOutgoingCalls) < $avp(externalIpCalls)) {
                xinfo("[$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: Allow roadwarrior call\n");
                set_dlg_profile("outgoingCallsPerAor", "$fU@$fd");
                return;
            }
        }
    }

    xwarn("[$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: $si is not valid for company '$dlg_var(companyId)'\n");
    if ($dlg_var(type) == "retail") {
        send_reply("403", "Forbidden (invalid IP)");
        exit;
    }
    $rU = 'ipnotallowed';
}

route[PARSE_X_HEADERS] {
    # Set callee
    $var(header) = 'X-Info-Callee';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(callee) = $var(header-value);

    if ($dlg_var(type) == 'retail') return; # No X-Call-Id for retail calls

    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(xcallid) = $var(header-value);
    xnotice("[$dlg_var(cidhash)] Related leg: $dlg_var(xcallid)\n");
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        xerr("[$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[IS_INTERNAL] {
    $avp(is_internal) = '0';
    if ($dlg_var(type) != "vpbx") return; # No internal concept for non-vpbx calls

    # Is extension in Extensions?
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isExtension FROM Extensions E WHERE number='$var(number)' AND companyId='$dlg_var(companyId)'", "ra");
    if ($xavp(ra=>isExtension) == '1') {
        $avp(is_internal) = '1';
        return;
    }

    # Is a friend?
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isFriend FROM FriendsPatterns WHERE friendId IN (SELECT id FROM Friends WHERE companyId='$dlg_var(companyId)') AND '$var(number)' REGEXP `regExp`", "ra");
    if ($xavp(ra=>isFriend) == '1') {
        $avp(is_internal) = '1';
        return;
    }

    # Not recognized as internal, must start with '+' if AS talking
    if ($(var(number){s.substr,0,1}) != '+' && $var(is_from_inside)) {
        xerr("[$dlg_var(cidhash)] IS-INTERNAL: Not internal number '$var(number)' not starting with '+', this shouldn't happen\n");
    }

    return;
}

# Authentication route
route[AUTH] {
    if (src_ip == myself || $var(is_from_inside)) return;
    if (!$var(is_from_inside) && allow_trusted($si, 'any') && $avp(trustedTag) != $null) return; # No AUTH for wholesale clients

    if (is_method("REGISTER") || from_uri==myself) {
        # authenticate requests
        if (!auth_check("$fd", "kam_users", "1")) {
            xinfo("[$dlg_var(cidhash)] AUTH: Auth needed\n");
            auth_challenge("$fd", "0");
            exit;
        }

        xinfo("[$dlg_var(cidhash)] AUTH: Authentication OK\n");
        # user authenticated - remove auth header
        consume_credentials();
    }

    # If caller is not local subscriber, reject (both AS and subscribers use my domain in from-domain)
    if (from_uri!=myself) {
        xerr("[$dlg_var(cidhash)] $fd is not my domain, 403 forbidden\n");
        send_reply("403","Forbidden");
        exit;
    }

    # Check R-URI is for my domain
    if (uri!=myself) {
        xerr("[$dlg_var(cidhash)] R-URI not for my domain, 404 Not here\n");
        send_reply("404", "Invalid domain in R-URI");
        exit;
    }

    # Domain strict checking
    if ( uri == myself && !is_uri_host_local() ) {
        xwarn("[$dlg_var(cidhash)] $rd is my IP but domains should be used, reject\n");
        send_reply("488", "Domain needed");
        exit;
    }

    if ( from_uri == myself && !is_from_local() ) {
        xwarn("[$dlg_var(cidhash)] $fd is my IP but domains should be used, reject\n");
        send_reply("488", "Domain needed");
        exit;
    }

    return;
}

# Handle within-dialog messages
route[WITHINDLG] {
    if (!$dlg_var(confirmed) && is_method("UPDATE|INVITE")) drop;

    route(ADAPT_CALLER);
    route(ADAPT_REFERTO);

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(RURIALIAS);
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        } else if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("REFER")) {
            route(REFER);
        } else if (is_method("INFO")) {
            route(INFO);
        } else if (is_method("MESSAGE")) {
            route(MESSAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
    } else {
        if (is_method("SUBSCRIBE") && uri == myself) {
            # in-dialog subscribe requests
            route(PRESENCE);
            exit;
        }

        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        send_reply("404","Not here");
    }
}

route[REFER] {
    if (is_present_hf("Refer-to") && $(hdr(Refer-to){s.len})) {
        xinfo("[$dlg_var(cidhash)] REFER: $fU transfers call to $hdr(Refer-to)\n");
        $dlg_var(referee) = $hdr(Refer-to);
    } else {
        xerr("[$dlg_var(cidhash)] REFER: No Refer-To header found, relay\n");
    }

    return;
}

route[INFO] {
    if (is_present_hf("Record")) {
        xinfo("[$dlg_var(cidhash)] INFO: On demand record using INFO, proceed\n");
        route(ONDEMANDRECORD);
    } else {
        xinfo("[$dlg_var(cidhash)] INFO: INFO without Record header, relay\n");
    }

    return;
}

route[MESSAGE] {
    if (!$var(is_from_inside)) return;

    if (search_body("on-demand-record")) {
        xinfo("[$dlg_var(cidhash)] MESSAGE: On demand record using MESSAGE, proceed\n");
        route(ONDEMANDRECORD);
    } else {
        xinfo("[$dlg_var(cidhash)] MESSAGE: MESSAGE without on-demand-record body, relay\n");
    }

    return;
}

route[ONDEMANDRECORD] {
    if (!$dlg_var(onDemandRecord)) {
        xwarn("[$dlg_var(cidhash)] ONDEMANDRECORD: On demand record not enabled, ignore\n");
        send_reply("403", "Forbidden");
        exit;
    }

    if ($dlg_var(recording) != 'yes') {
        xinfo("[$dlg_var(cidhash)] ONDEMANDRECORD: Start recording call\n");
        start_recording();
        $dlg_var(recording) = 'yes';

        send_reply("200", "Record On");
    } else {
        xinfo("[$dlg_var(cidhash)] ONDEMANDRECORD: Stop recording call\n");
        stop_recording();
        $dlg_var(recording) = 'no';

        send_reply("200", "Record Off");
    }

    exit;
}

# URI update for requests where alias found
route[RURIALIAS] {
    if(isdsturiset()) {
        return;
    }

    handle_ruri_alias();
    switch ($rc) {
    case -1:
        xerr("[$dlg_var(cidhash)] RURIALIAS: Failed to handle alias of R-URI $ru\n");
        send_reply("400", "Bad request");
        exit;
    case 1:
        xinfo("[$dlg_var(cidhash)] RURIALIAS: Alias parsed, routing $rm from $fu to $du\n");
        break;
    case 2:
        # ;alias not found
        break;
    };

    return;
}

# Relay request
route[RELAY] {
    if ($(du{uri.host}) != $null) {
        xinfo("[$dlg_var(cidhash)] RELAY: Relaying to $(du{uri.host}) (du, $dP)\n");
    } else {
        xinfo("[$dlg_var(cidhash)] RELAY: Relaying to $(ru{uri.host}) (ru)\n");
    }

    # Common for every transaction
    t_on_reply("MANAGE_REPLY");
    t_on_branch("MANAGE_BRANCH");

    if (!t_relay())
        sl_reply_error();

    exit;
}

route[ANTIFLOOD] {
#!ifdef WITH_ANTIFLOOD
    # Inside request
    if (src_ip == myself || $var(is_from_inside)) return;

    # Trusted sources
    if (allow_trusted($si, 'any')) {
        xinfo("[$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (IP added in kam_trusted)\n");
        return;
    }

    # Allowed sources by company
    $var(group) = allow_source_address_group();
    if ($var(group) != -1) {
        xinfo("[$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (allowed source for companyId '$var(group)')\n");
        return;
    }

    # Evaluate PIKE
    if($sht(ipban=>$si) != $null) {
        # ip is already blocked
        xerr("[$dlg_var(cidhash)] ANTIFLOOD: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
        exit;
    }
    if (!pike_check_req()) {
        xerr("[$dlg_var(cidhash)] ANTIFLOOD: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
        $sht(ipban=>$si) = 1;
        exit;
    }
#!endif

    return;
}

# Handle SIP registrations
route[REGISTER] {
    if(!is_method("REGISTER")) return;

    if(isflagset(FLT_NATS)) {
        setbflag(FLB_NATB);
        # Enable SIP NAT pinging
        if ($proto == 'udp') {
            xinfo("[$dlg_var(cidhash)] REGISTER: Enable UDP SIP OPTIONS pinging\n");
            setbflag(FLB_NATSIPPING);
        } else {
            xinfo("[$dlg_var(cidhash)] REGISTER: Enable TCP raw NAT keeper\n");
        }
    }

    # Store in kam_users_location_attrs used transport to retrieve it in lookup
    $xavp(ulattrs=>transport) = $proto;

    $var(contact_uri) = @contact.uri;
    save("kam_users_location");
    switch ($?) {
        case -1:
            xwarn("[$dlg_var(cidhash)] REGISTER: Something went wrong when saving location\n");
            sl_reply_error();
            break;
        case 1:
            xinfo("[$dlg_var(cidhash)] REGISTER: Contacts inserted ($tu: $var(contact_uri))\n");
            break;
        case 2:
            xinfo("[$dlg_var(cidhash)] REGISTER: Contacts updated ($tu: $var(contact_uri))\n");
            break;
        case 3:
            xinfo("[$dlg_var(cidhash)] REGISTER: Contacts deleted ($tu: $var(contact_uri))\n");
            break;
        case 4:
            xinfo("[$dlg_var(cidhash)] REGISTER: Contacts returned\n");
            break;
    };

    exit;
}

# Detect NAT
route[NATDETECT] {
    # 64 - Test if the source connection of signaling is WS
    if (nat_uac_test(64)) {
        route(WSFIX);
        return;
    }
    force_rport();

    if (nat_uac_test("18")) {
        xinfo("[$dlg_var(cidhash)] NATDETECT: NAT detected\n");
        setflag(FLT_NATS);

        if (is_method("REGISTER")) {
            fix_nated_register();
        } else if (is_method("SUBSCRIBE")) {
            fix_nated_contact();
        } else {
            if(is_first_hop()) {
                # Sets ;alias only if received ip and port differ from those in contact URI
                if (!add_contact_alias()) {
                   xerr("[$dlg_var(cidhash)] NATDETECT: Error in aliasing contact $ct\n");
                   send_reply("400", "Bad request");
                   exit;
                }
            }
        }
    }
}

route[WSFIX] {
    if ($dlg_var(type) == 'wholesale') {
       xerr("[$dlg_var(cidhash)] WSFIX: Wholesale using WSS\n");
       send_reply("400", "Invalid transport");
       exit;
    }
    xinfo("[$dlg_var(cidhash)] WSFIX: Websockets detected, fix contact\n");
    # Do NAT traversal stuff for requests from a WebSocket
    # connection - even if it is not behind a NAT!
    # This won't be needed in the future if Kamailio and the
    # WebSocket client support Outbound and Path.
    force_rport();
    if (is_method("REGISTER")) {
        fix_nated_register();
    } else if (!add_contact_alias()) {
        if($dlg_var(nolog) != "1") xerr("[$dlg_var(cidhash)] WSFIX: Error aliasing contact <$ct>\n");
        send_reply("400", "Bad Request");
        exit;
    }
    return;
}

# Handle NAT
route[NATMANAGE] {
    # RTP handling is always enforced
    route(RTPENGINE);

    # Set FLB_NATB? Only in within-dialog request with nat=yes on Route header initiated by us
    if (is_request() && has_totag() && check_route_param("nat=yes") && $var(is_from_inside)) {
       setbflag(FLB_NATB);
    }

    # Return unless FLT_NATS or FLB_NATB are set
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        return;
    }

    # Add nat=yes in record-route? Only in initial requests when called from branch_route
    if (is_request() && !has_totag() && t_is_branch_route()) {
        add_rr_param(";nat=yes");
    }

    # Add contact alias? Only to replies with NATB set and first hop
    if (is_reply() && isbflagset(FLB_NATB) && is_first_hop()) {
        # Sets ;alias only if received ip and port differ from those in contact URI
        if (!add_contact_alias()) {
           xerr("[$dlg_var(cidhash)] NATMANAGE: Error in aliasing contact $ct\n");
           send_reply("400", "Bad request");
           exit;
        }
    }

    if ($dlg_var(type) == 'retail' && !$var(is_from_inside)) {
        xinfo("[$dlg_var(cidhash)] NATMANAGE: Add X-Info-NAT header\n");
        insert_hf("X-Info-NAT: yes\r\n");
    }
}

# This route sets following dlg_vars: brandId, companyId, type
route[CLASSIFY] {
    if ($var(is_from_inside)) {
        $var(header) = 'X-Info-BrandId';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(brandId) = $var(header-value);

        $var(header) = 'X-Info-CompanyId';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(companyId) = $var(header-value);

        $var(header) = 'X-Info-Type';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(type) = $var(header-value);
    } else {
        if (allow_trusted($si, 'any') && $avp(trustedTag) != $null) {
            $dlg_var(type) = 'wholesale';
            $dlg_var(companyId) = $avp(trustedTag);
            sql_xquery("cb", "SELECT brandId FROM Companies WHERE id='$dlg_var(companyId)'", "ra");
            $dlg_var(brandId) = $xavp(ra=>brandId);
        } else {
            # Get needed information from From header
            sql_xquery("cb", "SELECT B.id AS brandId, C.id AS companyId, C.type FROM kam_users KU JOIN Companies C ON C.id=KU.companyId JOIN Brands B ON C.brandId=B.id WHERE KU.name='$fU' AND KU.domain='$fd'", "ra");

            $dlg_var(brandId) = $xavp(ra=>brandId);
            $dlg_var(companyId) = $xavp(ra=>companyId);
            $dlg_var(type) = $xavp(ra=>type);
        }
    }

    xinfo("[$dlg_var(cidhash)] CLASSIFY: '$dlg_var(type)' call (b$dlg_var(brandId):c$dlg_var(companyId))");
}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    if ($var(is_from_inside)) {
        # IvozProvider talking
        $dlg_var(direction) = 'inbound';

        # -- Set caller
        # dlg_var(caller) will be set in all cases in ADAPT_CALLER (except 404 in retail call forwards that will be set in APPLY_RETAIL_CFW)
    } else {
        # External world talking
        $dlg_var(direction) = 'outbound';

        # -- Set caller
        # Calls from terminals will have dlg_var(caller) set in GENERATE_PUBLISH
        # Calls from friends/residentials/retails with PAI/RPID have dlg_var(caller) set in ADAPT_CALLER
        # Calls from wholesale have dlg_var(caller) set in ADAPT_CALLER
        # Calls from friends/residentials without PAI/RPID will have dlg_var(caller) empty
        # Calls from retails without PAI/RPID will have dlg_var(caller) set to fallback DDI

        # -- Set caller
        $dlg_var(callee) = $rU;
    }

    $dlg_var(callid) = $ci;

    if (is_present_hf("Referred-by")) {
        $dlg_var(referrer) = $(hdr(Referred-by){nameaddr.uri}{uri.user});
    }
}

# Reply generic route (all replies goes through this route)
onreply_route {
    xnotice("[$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    route(IS_FROM_INSIDE);
}

# Reply generic route (additional, for all replies)
onreply_route[MANAGE_REPLY] {
    # Control call limit if necessary
    if ($avp(AoR) != $null && !is_in_profile("callsPerAor", "$avp(AoR)")) {
        set_dlg_profile("callsPerAor", "$avp(AoR)");
        get_profile_size("callsPerAor", "$avp(AoR)", "$var(currentCalls)");
        xinfo("[$dlg_var(cidhash)] MANAGE_REPLY: '$avp(AoR)' has $var(currentCalls) calls now\n");
    }

    # Account user's missed calls if ringing
    if (is_method("INVITE") && t_check_status("180") && !$var(is_from_inside)) {
        setflag(FLT_ACCMISSED);
    }

    if (is_present_hf("P-Asserted-Identity") || is_present_hf("Remote-Party-ID")) {
        route(ADAPT_CALLER);
    }

    if (is_method("INVITE") && t_check_status("3[0-9]{2}")) {
        route(ADAPT_CONTACT);
    }

    # Manage NAT
    if (t_check_status("[12][0-9]{2}")) {
        route(NATMANAGE);
    }

    # Manage WS
    if (nat_uac_test(64)) { # 64 - Test if the source connection of signaling is WS
        # Do NAT traversal stuff for replies to a WebSocket connection
        # - even if it is not behind a NAT!
        # This won't be needed in the future if Kamailio and the
        # WebSocket client support Outbound and Path.
        add_contact_alias();
    }
}

failure_route[MANAGE_FAILURE] {
    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(IS_FROM_INSIDE);
    route(NATMANAGE);

    if (t_is_canceled()) {
        xerr("[$dlg_var(cidhash)] MANAGE-FAILURE: t_is_canceled, exit here\n");
        exit;
    }
}

failure_route[MANAGE_FAILURE_RETAIL] {
    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-RETAIL: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(IS_FROM_INSIDE);
    route(NATMANAGE);

    if (t_is_canceled()) {
        xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-RETAIL: t_is_canceled, exit here\n");
        exit;
    }

    # Handle 408 to retail accounts and apply call-forward if necessary
    if (t_branch_timeout() && !t_branch_replied()) {
        xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-RETAIL: 408 calling to retail account with call-forward configured");
        $avp(apply_cfwd) = 'yes';
        route(DISPATCH_TO_AS);
        route(RELAY);
    }
}

failure_route[MANAGE_FAILURE_AS] {
    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(IS_FROM_INSIDE);
    route(NATMANAGE);

    if (t_is_canceled()) {
        xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS '$avp(AVP_DST)' as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            t_on_failure("MANAGE_FAILURE_AS");
            route(RELAY);
        } else {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Route for branching: Only for INVITEs and BYEs (fork-able)
branch_route[MANAGE_BRANCH] {

    #!ifdef WITH_MULTISOCKET
    if ($fs != $null && $fs != "udp:" + $sel(cfg_get.address.main) + ":5060") {
        $dlg_var(extra_socket) = $(fs{s.select,1,:});
        xwarn("Calling to a UAC through $dlg_var(extra_socket)\n");
    }
    #!endif

    route(IS_FROM_INSIDE);

    # Prepare call
    if ($var(is_from_inside) && !has_totag() && is_method("INVITE")) {
        if ($avp(apply_cfwd) == 'yes') {
            route(APPLY_RETAIL_CFW);
        } else {
            route(ADAPT_CALLER);
            route(ADAPT_DIVERSION);
            route(ADAPT_RURI_OUT);
        }
    }

    route(TRANSPORT_DETECT);
    route(NATMANAGE);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    if(isbflagset(FLB_WEBSOCKETS)) {
        xwarn("[$dlg_var(cidhash)] Answered dialog involves websockets\n");
        $dlg_var(ws) = 'yes';
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    xnotice("[$dlg_var(cidhash)] Dialog ended, delete keys from dialogs htable starting with $ci\n");
    sht_rm_name_re("dialogs=>$ci::.*");
}

onsend_route {
    if (is_method("ACK")) $dlg_var(confirmed) = '1';
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        if ($sel(cfg_get.dolog.xmlrpc)) xwarn("XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    if ($sel(cfg_get.dolog.xmlrpc)) xnotice("XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");
    route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[TRANSPORT_DETECT] {
    if (!is_method("INVITE")) return;

    if (is_request() && !has_totag()) {
        if ($rP == 'ws' || $rP == 'wss' || $proto == 'ws' || $proto == 'wss' || $xavp(ulattrs=>transport) == 'ws' || $xavp(ulattrs=>transport) == 'wss') {
            xwarn("[$dlg_var(cidhash)] TRANSPORT-DETECT: Websockets, set FLB_WEBSOCKETS\n");
            setbflag(FLB_WEBSOCKETS);
        }
    }
}

route[RTPENGINE] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;
    if (is_method("ACK") && !has_body("application/sdp")) return;
    if ($dlg_var(type) == 'wholesale' || $dlg_var(type) == 'retail') return;

    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        set_rtpengine_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    $var(common_opts) = 'replace-session-connection replace-origin';

    if (nat_uac_test("18") && !$var(is_from_inside)) {
        xinfo("[$dlg_var(cidhash)] RTPENGINE: NAT detected, do not trust SDP addresses\n");
        $var(symmetry) = 'SIP-source-address';
    } else {
        xinfo("[$dlg_var(cidhash)] RTPENGINE: No NAT detected, trust SDP addresses\n");
        $var(symmetry) = 'asymmetric trust-address';
    }

    if ($dlg_var(ws) == 'yes' || isbflagset(FLB_WEBSOCKETS)) {
        if ($proto == 'ws' || $proto == 'wss' ) {
            xinfo("[$dlg_var(cidhash)] RTPENGINE: Is through $proto, convert to udp\n");
            $var(wsopts) = 'ICE=remove RTP/AVP DTLS=no';
        } else {
            xinfo("[$dlg_var(cidhash)] RTPENGINE: Is through $proto (non-ws), convert to wss\n");
            $var(wsopts) = 'ICE=force RTP/SAVPF DTLS=passive';
        }
    } else {
        $var(wsopts) ='ICE=remove RTP/AVP';
    }

    $var(interfaces) = "";
    #!ifdef WITH_MULTISOCKET
    if ($Ri == $sel(cfg_get.address.main) && $dlg_var(extra_socket) != $null) {
        $var(interfaces) = "direction=" + $sel(cfg_get.address.main) + " direction=" + $dlg_var(extra_socket);
    }
    #!endif

    xinfo("[$dlg_var(cidhash)] RTPENGINE: rtpengine_manage [$var(common_opts) $var(symmetry) $var(wsopts) $var(interfaces)]\n");
    rtpengine_manage("$var(common_opts) $var(symmetry) $var(wsopts) $var(interfaces)");
}

route[PRESENCE] {
    if(!is_method("PUBLISH|SUBSCRIBE|NOTIFY")) return;

    if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
        send_reply("404", "No voicemail service");
        exit;
    }

    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }

    if(is_method("PUBLISH")) {
        handle_publish();
        t_release();
    } else if(is_method("SUBSCRIBE")) {
        record_route();
        handle_subscribe();
        t_release();
    } else if(is_method("NOTIFY")) {
        # Handle unsolicited NOTIFY messages (non-related to previous SUBSCRIBE)
        if (!$var(is_from_inside)) {
            xwarn("[$dlg_var(cidhash)] NOTIFY: Received $rm from not AS, 405 Method Not Allowed\n");
            send_reply("405", "Method Not Allowed");
            exit;
        }

        # Lookup contact and relay
        route(LOOKUP);
        route(RELAY);
    }
    exit;
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp == WS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xinfo("HTTP Request Received from $si:$sp\n");
    } else if ($Rp == WSS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xinfo("HTTPS Request Received from $si:$sp\n");
    } else {
        if ($sel(cfg_get.dolog.websocket)) xwarn("HTTP(S) request received on $Rp, port not allowed\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {
        # Validate Host - make sure the client is using the correct
        # alias for WebSockets
        # if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
        #     if ($sel(cfg_get.dolog.websocket)) xwarn("Bad host $hdr(Host)\n");
        #     xhttp_reply("403", "Forbidden, bad host", "", "");
        #     exit;
        # }

        # Optional... validate Origin - make sure the client is from an
        # authorized website.  For example,
        #
        # if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
        #     && $hdr(Origin) != "https://communicator.MY_DOMAIN") {
        #       if ($sel(cfg_get.dolog.websocket)) xwarn("Unauthorized client $hdr(Origin)\n");
        #       xhttp_reply("403", "Forbidden", "", "");
        #       exit;
        # }

        # Optional... perform HTTP authentication

        # ws_handle_handshake() exits (no further configuration file
        # processing of the request) when complete.
        if (ws_handle_handshake()) {
            # Optional... cache some information about the
            # successful connection
            if ($sel(cfg_get.dolog.websocket)) xinfo("Connection upgrade to websocket was successful\n");
            exit;
        }
    }

    if ($sel(cfg_get.dolog.websocket)) xwarn("HTTP(S) request received without Upgrade to Websocket header, 404\n");
    xhttp_reply("404", "Not found", "", "");
}

event_route[websocket:closed] {
    if ($sel(cfg_get.dolog.websocket)) xinfo("WebSocket connection from $si:$sp has closed\n");
}

event_route[htable:mod-init] {
    if (dns_query("trunks.ivozprovider.local", "kamtrunks")) {
        $var(trunksAddress) = $dns(kamtrunks=>addr);
        xinfo("trunks.ivozprovider.local: $var(trunksAddress)\n");
    } else {
        xerr("Problems resolving trunks.ivozprovider.local, aborting\n");
        abort();
    }
}

#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define XMLRPC_PORT 8000

# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags
 
# ACC Flags
#!define FLT_ACC 1
#!define FLT_ACCFAILED 2

# DLG_FLAG
#!define DLG_FLAG 3

# Set when processing REINVITE to skip some logics on answers
#!define FLT_REINVITE 4

# RELATED Flag (when set, aleg found for this call in this proxy)
#!define FLT_ISBLEG 5

# - options

#!define WITH_ANTIFLOOD

#!define WITH_MEDIALIBERATION
# Note: If defined, enable hack that avoids forwarding media liberation reINVITEs to endpoints

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

####### Global Parameters #########

listen=udp:IP:5060
listen=tcp:IP:5060
listen=tcp:IP:5061
listen=tcp:IP:XMLRPC_PORT

# -- Debug level
debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec Ivoz Provider v1.0"
user_agent_header="User-Agent: Irontec Ivoz Provider v1.0"

####### Runtime cfg values (kamcmd cfg.list) #########

# Log dialogs initiated by these SIP methods
dolog.invite    = 1 desc "If 1, log invite transactions"
dolog.register  = 1 desc "If 1, log register transactions"
dolog.publish   = 1 desc "If 1, log publish transactions"
dolog.subscribe = 1 desc "If 1, log subscribe transactions"
dolog.notify    = 1 desc "If 1, log notify transactions"
dolog.options   = 1 desc "If 1, log options transactions"
dolog.message   = 1 desc "If 1, log message transactions"
dolog.refer     = 1 desc "If 1, log refer transactions"

# Debug
dolog.xmlrpc    = 0 desc "If 1, debug XMLRPC"
dolog.printmsg_methods = 'NONE' desc "Print full SIP messages with these methods" # e.g. 'INVITE|REGISTER', 'NONE' to disable

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "mi_fifo.so"
loadmodule    "mi_rpc.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "sqlops.so"
loadmodule    "rtpproxy.so"
loadmodule    "cfg_rpc.so"
loadmodule    "dialog.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "acc.so"
loadmodule    "lcr.so"
loadmodule    "uac.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "xhttp.so"
#loadmodule    "jsonrpc-s.so"
#loadmodule    "json.so"
loadmodule    "domain.so"
loadmodule    "cfgutils.so"
loadmodule    "dialplan.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "permissions.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_SOCK)")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_mode", 3)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@trunks.ivozprovider.local")

# TLS
modparam("tls", "config", "/etc/kamailio/proxytrunks/tls.cfg")

# MI_FIFO
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_proxytrunks_fifo")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# El parametro clave es debug (por defecto a 2 en este cfg)
# Se imprime todo lo que tenga <= que este valor (valores posibles: 0 - infinito)
# 0: De WARN (incluido) para arriba
# 1: De NOTICE (incluido) para arriba
# 2: De INFO (incluido) para arriba
# 3: De DBG (incluido) para arriba
# 
# Se puede modificar on-the-fly con:
# kamcmd cfg.seti core debug X
# Y obtener el valor actual con:
# kamcmd cfg.get core debug

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxytrunks_ctl")

# RTPPROXY
modparam("rtpproxy", "db_url", DBURL)
modparam("rtpproxy", "table_name", "kam_rtpproxy")
modparam("rtpproxy", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpproxy", "nortpproxy_str", "a=sdpmangled:yes\r\n")

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# ACC
modparam("acc", "early_media", 1)
modparam("acc", "report_ack", 1) # Only for successful establishments
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 0)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "acc_time_column", "localtime")

# -- to syslog
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 2)
modparam("acc", "db_table_acc", "kam_trunks_acc")
modparam("acc", "cdrs_table", "kam_acc_cdrs")
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd; cseq=$cs")

# -- cdr accounting
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "proxy=$dlg_var(proxy);brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);peeringContractId=$dlg_var(peeringContractId);referrer=$dlg_var(referrer);referee=$dlg_var(referee)")

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "activeCalls; inboundCalls; outboundCalls")
# Destruye dialogo si no hay BYE (se reinicia a cada request)
#modparam("dialog", "default_timeout", 21600)
#modparam("dialog", "default_timeout", 90)
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
# Las incluye en mensajes creados por el modulo dialog (BYEs)
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n")
# Keep-alive (in-dialog OPTIONs)
#modparam("dialog", "ka_timer", 10)
#modparam("dialog", "ka_interval", 300)
# Interesante para: uac_auth()
modparam("dialog", "track_cseq_updates", 1)

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif

modparam("htable", "htable", "dialogs=>size=10;autoexpire=0")

# UAC
modparam("uac", "auth_realm_avp","$avp(realm)")
modparam("uac", "auth_username_avp","$avp(provideruser)")
modparam("uac", "auth_password_avp","$avp(secret)")
modparam("uac", "restore_mode","auto")
modparam("uac", "restore_dlg", 1)
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_db_table", "kam_trunks_uacreg")
modparam("uac", "reg_contact_addr", "reg_contact_addr")

# LCR
modparam("lcr", "db_url", DBURL)
modparam("lcr", "lcr_gw_table","LcrGateways")
modparam("lcr", "lcr_rule_table", "LcrRules")
modparam("lcr", "lcr_rule_target_table", "LcrRuleTargets")
modparam("lcr", "gw_name_column", "gw_name")
modparam("lcr", "ip_addr_column", "ip")
modparam("lcr", "lcr_id_column", "companyId")
modparam("lcr", "gw_uri_avp", "$avp(i:709)")
modparam("lcr", "ruri_user_avp", "$avp(i:500)")
modparam("lcr", "tag_avp", "$avp(lcr_tag)")
modparam("lcr", "flags_avp", "$avp(s:caller_method)")
modparam("lcr", "defunct_capability", 1)
modparam("lcr", "lcr_id_avp", "$avp(lcr_id_avp)")
modparam("lcr", "defunct_gw_avp", "$avp(defunct_gw_avp)")
modparam("lcr", "lcr_rule_hash_size", 1024)
modparam("lcr", "lcr_gw_count", 1024)
#modparam("lcr", "dont_strip_or_tag_flag", WTF)
modparam("lcr", "fetch_rows", 3000)
modparam("lcr", "ping_interval", 15) # Ping every 15 seconds
modparam("lcr", "ping_inactivate_threshold", 1) # Mark as inactive at first call of inactivate_gw()
modparam("lcr", "ping_valid_reply_codes", "403,404,405,501") # Mark as active when 2XX or these reply codes
modparam("lcr", "ping_from", "sip:pinger@localhost")
modparam("lcr", "lcr_count", 10)

# TM
modparam("tm", "fr_timer", 5000)

# SANITY
modparam("sanity", "autodrop", 0)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_trunks_domain")
modparam("domain", "domain_attrs_table", "kam_trunks_domain_attrs")
modparam("domain", "register_myself", 1)

# DIALPLAN
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "table_name", "kam_trunks_dialplan")
modparam("dialplan", "attrs_pvar", "$avp(s:appliedrule)")

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_trunks_address") # Not used
modparam("permissions", "trusted_table", "kam_pike_trusted") # IPs excluded from pike checking
modparam("permissions", "db_mode", 1)

####### Routing Logic ########

request_route {
    route(CONFIGURE_XLOG);

    if ($dlg_var(cidhash) == $null) {
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] Calculated hash for $ci\n");
    }

    if ($dlg_var(log)) xlog("L_NOTICE", "[$dlg_var(cidhash)] Request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");


    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) xlog("L_WARN", "Received message:\n\n$mb\n");

    if (is_method("OPTIONS")) {
        if ($dlg_var(log)) xlog("L_NOTICE", "[$dlg_var(cidhash)] Send 200 to '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");
        send_reply("200", "I'm here!");
        exit;
    }

    # per request initial checks
    route(REQINIT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] ----> $rm from $si\n");

        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RELAY);
        }

        exit;
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] In dialog request - has_to_tag\n");
        route(WITHINDLG);
    }

    ### only initial requests (no To tag)

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] NOT in dialog request - not has_to_tag: Initial transaction\n");

    # Manage retransmissions
    t_check_trans();

    # Only INVITE can start a dialog
    if (!is_method("INVITE")) {
        if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] $rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Remove preloaded route headers
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] Remove preloaded route headers\n");
    remove_hf("Route");

    # Setup accounting
    route(ACCOUNTING);

    # Manage dialog and set session-timers flag
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] dialog_manage()\n");
    dlg_manage();
    #dlg_set_property("ka-src");
    #dlg_set_property("ka-dst");

    # Add record-route to INVITE requests
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] Add record-route\n");
    record_route();

    # Easy routing:
    # (a) From ASs ----> Choose GW
    # (b) To my domains ----> Dispatch to AS
    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] Source: Known AS, route to corresponding GW\n");

        # AS provides needed info in X-INFO header
        route(PARSE_X_HEADERS);
        route(CONTROL_EXTERNAL_MAXCALLS);
        route(PROFILE_OUTBOUND_CALL);

        # Guess if this call is related to another one (due to call forward?)
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] Guess if this call is related to another one (due to call forward?)\n");
        route(RELATE_LEGS);

        # Route wisely
        route(CHOOSE_GW);
        route(RELAY);
    } else {
        if (uri==myself) {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] Someone talking to one of my domains, proceed\n");

            # X-HEADERS are for internal use only, they shouldn't be added by trunks
            remove_hf_re("^X-");

            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] Invoke DIALOGS_GET_INFO for initial INVITE from GW ($ci)\n");
            route(DIALOGS_GET_INFO);
            route(TRANSFORMATE_IN);
            route(GET_INFO_FROM_MATCHED_DDI);
            route(CONTROL_EXTERNAL_MAXCALLS);
            route(PROFILE_INBOUND_CALL);

            route(DISPATCH);
            route(RELAY);
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] $rd is not one of my domains, 404 Not Here\n");
            send_reply("404", "Not Here");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] Main script error, should NOT arrive this point.\n");
    drop;
}

route[CHOOSE_GW] {
    # Para saber que GWs matchean, se mira el RURI-User y el URI del llamante
    # El URI del llamante se puede coger de muchos sitios (From, PAI, RPID...)
    # (de momento, del From)
    $avp(caller_uri) = $fu;

    # Cargar GWs dentro del grupo lcr_id que no esten defunct
    # El primer campo es el lcr_id. Cada empresa tendra su lcr_id unico (que coincida con companyId, e.g.)
    # que hace que solo se tengan en cuenta las rutas que puede usar esa empresa
    # El 0 es un lcr_id especial que aplica a todas las empresas (rutas para llamadas de emergencia?)
    if (!load_gws($dlg_var(companyId), $rU, $avp(caller_uri))) {
        # No matchea nada, no puedo sacar la llamada
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] Cannot load gateways\n");
        sl_send_reply("500", "Server Internal Error - Cannot load gateways");
        exit;
    } else {
        # Al menos un gateway disponible, sigo adelante
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] CHOOSE-GW: Gateways loaded, evaluate rules!\n");
        route(FIRSTGW);
    }

    t_on_failure("MANAGE_FAILURE_GW"); # Ruta de fallo propia para llamadas a GW
    t_on_branch("MANAGE_BRANCH_GW");   # Ruta de branch propia para llamadas a GW
}

route[FIRSTGW] {
    # La seleccion del GW modifica RURI y Dest-URI, logo antes y despues
    # -- antes --
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] FIRSTGW: Antes: Dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] FIRSTGW: Antes: RURI $ru\n");

    # Selecciono GW evaluando reglas
    if (!next_gw()) {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] FIRSTGW: NO next GW");
        sl_send_reply("503", "No gateways");
        exit;
    }

    # -- despues --
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] FIRSTGW: Despues: Dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] FIRSTGW: Despues: RURI $ru\n");

    # Guardo valores para volver a setear en caso de 401/407 (ver FAILURE_ROUTE)
    $avp(nextgwruri) = $ru;
    $avp(nextgwdu) = $du;
    
    # Utilizo lcr_tag del GW para guardar el peeringContractId:auth_username:auth_password
    $avp(peeringContractId) = $(avp(lcr_tag){s.select,0,:});
    if (!$(avp(peeringContractId){s.len})) {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] [$dlg_var(cidhash)] FIRSTGW: Problems obtaining peeringContractId, exit!\n");
        exit;
    }

    # Meto los valores en los AVP-s que lee UAC
    $avp(provideruser) = $(avp(lcr_tag){s.select,1,:});
    $avp(secret) = $(avp(lcr_tag){s.select,2,:});
}

route[NEXTGW] {
    # La seleccion del GW modifica RURI y Dest-URI, logo antes y despues
    # -- antes --
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] NEXTGW: Antes: Dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] NEXTGW: Antes: RURI $ru\n");

    # Selecciono GW evaluando reglas
    if (!next_gw()) {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] NEXTGW: NO next GW, send current response");
        exit;
    }

    # -- despues --
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] NEXTGW: Despues: Dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] NEXTGW: Despues: RURI $ru\n");

    # Guardo valores para volver a setear en caso de 401/407 (ver FAILURE_ROUTE)
    $avp(nextgwruri) = $ru;
    $avp(nextgwdu) = $du;
    
    # Utilizo lcr_tag del GW para guardar el peeringContractId:auth_username:auth_password
    $avp(peeringContractId) = $(avp(lcr_tag){s.select,0,:});
    if (!$(avp(peeringContractId){s.len})) {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] [$dlg_var(cidhash)] NEXTGW: Problems obtaining peeringContractId, exit!\n");
        exit;
    }

    # Meto los valores en los AVP-s que lee UAC
    $avp(provideruser) = $(avp(lcr_tag){s.select,1,:});
    $avp(secret) = $(avp(lcr_tag){s.select,2,:});
}

route[PARSE_X_HEADERS] {
    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_OPTIONAL_X_HEADER);
    $dlg_var(xcallid) = $var(header-value);

    # -- xcallid is mandatory for every normal call.
    #    Check if X-Info-Special header is present with 'fax' value (current only exception)
    if ($(dlg_var(xcallid){s.len}) == 0) {
        $var(header) = 'X-Info-Special';
        route(PARSE_OPTIONAL_X_HEADER);
        if ($var(header-value) == 'fax') {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PARSE-X-HEADERS: Special case without xcallid: fax\n");
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] PARSE-X-HEADERS: Invalid $var(header) value ($var(header-value)) for call without xcallid\n");
            sl_send_reply("500", "x-callid is missing");
            exit;
        }
    }

    # Extract brandId
    $var(header) = 'X-Info-BrandId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(brandId) = $var(header-value);

    # Extract companyId
    $var(header) = 'X-Info-CompanyId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyId) = $var(header-value);

    # Extract companyName
    $var(header) = 'X-Info-CompanyName';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyName) = $var(header-value);

    # Extract MediaRelaySet (can be null and non-exist)
    $var(header) = 'X-Info-MediaRelaySet';
    route(PARSE_OPTIONAL_X_HEADER);
    $dlg_var(mediaRelaySetsId) = $var(header-value);

    # Extract externalMaxCalls
    $var(header) = 'X-Info-MaxCalls';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(externalMaxCalls) = $var(header-value);

    # Extract Record header
    $var(header) = 'X-Info-Record';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) == 'yes') {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PARSE-X-HEADERS: '$var(header)' header found, call will be recorded\n");
        $avp(recordCall) = 'yes';
    }
}

# Header might not be present and, if present, might be empty
route[PARSE_OPTIONAL_X_HEADER] {
    $var(header-value) = '';

    if (is_present_hf($var(header))) {
        if ($(hdr($var(header)){s.len})) {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header): $hdr($var(header))\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header): <empty>\n");
        }
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header) not present\n");
    }
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    $var(header-value) = '';

    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header): $hdr($var(header))\n");
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        sl_send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[PROFILE_OUTBOUND_CALL] {
    # Saliente / Entrante
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PROFILE-OUTBOUND-CALL: Type-> saliente\n");
    $dlg_var(profile) = "Outbound call";
    set_dlg_profile("outboundCalls", "$dlg_var(companyId)");
}

route[PROFILE_INBOUND_CALL] {
    # Saliente / Entrante
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PROFILE-INBOUND-CALL: Type-> entrante\n");
    $dlg_var(profile) = "Inbound call";
    set_dlg_profile("inboundCalls", "$dlg_var(companyId)");
}

route[PRINT_STATS] {
    # Global stats
    if(get_profile_size("activeCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) active calls\n");
    }

    if(get_profile_size("inboundCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) inbound calls\n");
    }

    if(get_profile_size("outboundCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) outbound calls\n");
    }

    # Company stats
    if(get_profile_size("activeCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) active calls\n");
    }

    if(get_profile_size("inboundCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) inbound calls\n");
    }

    if(get_profile_size("outboundCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) outbound calls\n");
    }
}

route[TRANSFORMATE_IN] {
    # Get all DDI candidates
    sql_query("cb", "SELECT d.DDIE164, t.callee_in, t.caller_in from DDIs AS d INNER JOIN PeeringContracts AS p ON d.peeringContractId = p.id LEFT JOIN TransformationRulesetGroupsTrunks t ON t.id=p.transformationRulesetGroupsTrunksId  WHERE '$rU' REGEXP CONCAT('[0-9]*', DDI) ORDER BY LENGTH(DDIE164) DESC", "ra");

    # Are there any candidates?
    if ($dbr(ra=>rows) == 0) {
        if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] TRANSFORMATE-IN: $rU not recognized in any company, 404 Not Found\n");
        send_reply("404", "Not Here");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] TRANSFORMATE-IN: There are $dbr(ra=>rows) DDI candidates, proceed\n");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] TRANSFORMATE-IN: Initial callee -> $rU\n");

    # Evaluate all candidates ($rU after transformation must be equal to candidate, otherwise it is rejected)
    $var(i) = 0;
    while ($var(i)<$dbr(ra=>rows)) {
        $var(candidate) = $dbr(ra=>[$var(i), 0]);
        $var(transformation) = $dbr(ra=>[$var(i), 1]);
        $var(number) = $rU;
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        if ($var(transformated) == $var(candidate)) {
            # We have a winner candidate!!
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] TRANSFORMATE-IN: Callee $rU is recognized as $var(candidate)\n");
            $rU = $var(candidate);
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] TRANSFORMATE-IN: Final callee -> $rU (should be E164)\n");

            # Transformate caller with corresponding transformation
            route(GET_CALLER); # Greps caller and sets it in $var(caller)
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] TRANSFORMATE-IN: Initial caller -> $var(caller)\n");
            $var(transformation) = $dbr(ra=>[$var(i), 2]);
            $var(number) = $var(caller);
            route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
            $var(caller) = $var(transformated);
            route(SET_CALLER); # Sets caller using $var(caller) value
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] TRANSFORMATE-IN: Final caller -> $var(caller) (should be E164)\n");

            # Free and leave
            sql_result_free("ra");
            return;
        }
        $var(i) = $var(i) + 1;
    }
    sql_result_free("ra");

    # No candidate succeeded after applying transformations
    if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] TRANSFORMATE-IN: No DDI candidate succeeded after applying transformations to $rU, 404 Not Found");
    send_reply("404", "Not Here");
    exit;
}

# Sets caller in $var(caller) seeking in PAI/RPID/From (in this order)
route[GET_CALLER] {
    # Where is my caller? PAI/RPID/From?
    if (is_present_hf("P-Asserted-Identity")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-CALLER: PAI present: $(ai{uri.user})\n");
        $var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-CALLER: RPID present: $(re{uri.user})\n");
        $var(caller) = $(re{uri.user});
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-CALLER: Nor PAI nor RPID present, only From ($fU)! :(\n");
        $var(caller) = $fU;
    }
}

# Sets caller in PAI/RPID/From using $var(caller) value
route[SET_CALLER] {
    # Set final caller in corresponding header
    if (is_present_hf("P-Asserted-Identity")) {
        remove_hf("Remote-Party-ID"); # If PAI present, RPID out
        if ($(ai{uri.user}) != $var(caller)) { # If new value differs from previous, change
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] SET-CALLER: Changing PAI to $var(caller)\n");
            remove_hf("P-Asserted-Identity");
            append_hf("P-Asserted-Identity: <sip:$var(caller)@$(ai{uri.host})>\r\n");
        }
    } else if (is_present_hf("Remote-Party-ID") && $(re{uri.user}) != $var(caller)) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] SET-CALLER: Changing RPID to $var(caller)\n");
        remove_hf("Remote-Party-ID");
        append_hf("Remote-Party-ID: <sip:$var(caller)@$(re{uri.host})>\r\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] SET-CALLER: Changing From to $var(caller)\n");
        $fU = $var(caller);
        $fn = $var(caller);
    }
}

# Sets $var(callee) and $var(caller)
route[TRANSFORMATE_OUT] {
    sql_xquery("cb", "SELECT callee_out, caller_out FROM PeeringContracts PC LEFT JOIN TransformationRulesetGroupsTrunks TR ON PC.transformationRulesetGroupsTrunksId=TR.id WHERE PC.id=$avp(peeringContractId)", "ra");

    # Transformate caller_out (set result in $var(caller))
    route(GET_CALLER); # Greps caller and sets it in $var(caller)
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] TRANSFORMATE-OUT: Initial caller -> $var(caller)\n");
    $var(transformation) = $xavp(ra=>caller_out);
    $var(number) = $var(caller);
    route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
    $var(caller) = $var(transformated);
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] TRANSFORMATE-OUT: Final caller -> $var(caller)\n");

    # Transformate callee_out
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] TRANSFORMATE-OUT: Initial callee -> $rU\n");
    $var(transformation) = $xavp(ra=>callee_out);
    $var(number) = $rU;
    route(APPLY_TRANSFORMATION);
    $var(callee) = $var(transformated);
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] TRANSFORMATE-OUT: Final caller -> $var(callee)\n");
}

# Apply $var(transformation) transformations (if set) to $var(number)
# Sets result in $var(transformated)
route[APPLY_TRANSFORMATION] {
    $var(transformated) = $var(number);

    if ($var(transformation) == $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] APPLY-TRANSFORMATION: No rule applied, return\n");
        return;
    }

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] APPLY-TRANSFORMATION: Number before transformation rule ($var(transformation)): $var(number)\n");
    dp_translate("$var(transformation)", "$var(number)/$var(transformated)");

    # If no rule applied, re-set value
    if ($avp(appliedrule) == $null)
        $var(transformated) = $var(number);

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] APPLY-TRANSFORMATION: Number after: $var(transformated) (applied rule: $avp(appliedrule))\n");
}

route[GET_INFO_FROM_MATCHED_DDI] {
    sql_xquery("cb", "SELECT d.DDIE164 AS DDI, c.name AS companyName, c.id AS companyId, c.mediaRelaySetsId, c.brandId AS brandId, c.externalMaxCalls, d.routeType, CS.calling_code AS company_cc, d.recordCalls FROM DDIs d JOIN Companies c ON d.companyId=c.id LEFT JOIN Countries CS ON CS.Id=c.countryId WHERE d.DDIE164='$rU'", "ra");

    # Matched DDI
    $dlg_var(DDI) = $xavp(ra=>DDI);

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: brandId: $xavp(ra=>brandId)\n");
    $dlg_var(brandId) = $xavp(ra=>brandId);

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: companyId: $xavp(ra=>companyId)\n");
    $dlg_var(companyId) = $xavp(ra=>companyId);

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: companyName: $xavp(ra=>companyName)\n");
    $dlg_var(companyName) = $xavp(ra=>companyName);

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: externalMaxCalls: $xavp(ra=>externalMaxCalls)\n");
    $dlg_var(externalMaxCalls) = $xavp(ra=>externalMaxCalls);

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: recordCalls: $xavp(ra=>recordCalls)\n");
    if ($xavp(ra=>recordCalls) == 'inbound' || $xavp(ra=>recordCalls) == 'all') {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: Call will be recorded\n");
        $avp(recordCall) = 'yes';
    }

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: routeType: $xavp(ra=>routeType)\n");
    $dlg_var(routeType) = $xavp(ra=>routeType);

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: company_cc: $xavp(ra=>company_cc)\n");
    $dlg_var(company_cc) = $xavp(ra=>company_cc);
    if ($dlg_var(company_cc) == $null) {
        if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: company_cc not set, set to default calling code (spain, 34)\n");
        $dlg_var(company_cc) = 34;
    }

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: mediaRelaySetsId: $xavp(ra=>mediaRelaySetsId)\n");
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
}

route[MEDIALIBERATION] {
#!ifdef WITH_MEDIALIBERATION
    if (is_method("ACK") && $dlg_var(discardack) == '1') {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MEDIALIBERATION: Drop ACK, magic part 2 of 2!\n");
        $dlg_var(discardack) = $null;
        exit;
    }

    if (is_method("INVITE|UPDATE") && has_body("application/sdp") && ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MEDIALIBERATION: Re-$rm from AS, evaluate doing magic\n");
        if (!sdp_get_line_startswith("$avp(cline)", "c=IN IP4 " + $si)) {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MEDIALIBERATION: RTPproxy on SDP, start magic!\n");
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MEDIALIBERATION: Mangle RTPproxy ports and reply 200, magic part 1 of 2!\n");
            if (is_method("INVITE"))
                $dlg_var(discardack) = '1'; # Set dlg_flag to discard subsequent ACK
            route(RTPRELAY); # Call RTPRELAY to link ports accordingly
            send_reply("200", "I agree");
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MEDIALIBERATION: SDP does not contain RTPproxy ($avp(cline)), abort magic\n");
        }
    }
#!endif
    return;
}

# Handle within-dialog messages
route[WITHINDLG] {
    # Do not forward media liberation reinvite
    route(MEDIALIBERATION);

    # Set FLT_REINVITE if within dialog invite (reinvite)
    if (is_method("INVITE")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] WITHINDLG: Setting FLT_REINVITE flag\n");
        setflag(FLT_REINVITE);
        # uac_replace_from does not maintain display_name in subsequent transactions
        $fn = $dlg_var(newfromdisplay);
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        } else if ( is_method("ACK") ) {
            # ACK is forwarded statelessy
            route(RTPRELAY);
        }
        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        sl_send_reply("403","Not here");
    }
    exit;
}

route[DISPATCH] {
    # round robin dispatching on ASs
    if(!ds_select_dst("1", "4")) {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] DISPATCH: No destination found\n");
        send_reply("404", "No destination");
        exit;
    }
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du>\n");
    t_on_failure("MANAGE_FAILURE_AS");
}

# Relay request
route[RELAY] {
    if ($(du{uri.host}) != $null)
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] RELAY: Relaying to $(du{uri.host}) (du, $dP)\n");
    else
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] RELAY: Relaying to $(ru{uri.host}) (ru)\n");

    if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    if(!t_is_set("branch_route"))  t_on_branch("MANAGE_BRANCH");
    if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");

    if (!t_relay())
        sl_reply_error();

    exit;
}

# Initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
    # flood detection from same IP and traffic ban for a while
    #
    # Excluded from pike:
    #   - my ip excluded
    #   - AS-es excluded
    #   - IPs in trusted table
    if (allow_trusted($si, 'any')) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] REQINIT: $si is not checked against antiflood (IP added in antiflood trusted IPs)\n");
    } else if (src_ip==myself || ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] REQINIT: $si is not checked against antiflood (AS or myself talking)\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] REQINIT: $si will be checked against antiflood\n");
        if($sht(ipban=>$si) != $null) {
            # ip is already blocked
            if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] REQINIT: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] REQINIT: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
#!endif

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] REQINIT: Too many hops for SIP message from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] REQINIT: Malformed SIP message from $si:$sp\n");
        exit;
    }

    # Easy dropping for sipvicious scans
    if (search("sipvicious")) {
        if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] REQINIT: DROPPED SIPVICIOUS ----> $rm from $si\n");
        exit;
    }
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] REQINIT: All checks passed, continue...\n");
}

# Configure xlog
route[CONFIGURE_XLOG] {
    # Evaluate only once for SIP methods than can initiate transaction
    if ($dlg_var(log) == "0" || $dlg_var(log)) return;

    $dlg_var(log) = "0";

    if (is_method("INVITE") && $sel(cfg_get.dolog.invite)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REGISTER") && $sel(cfg_get.dolog.register)) {
        $dlg_var(log) = "1";
    }

    if (is_method("PUBLISH") && $sel(cfg_get.dolog.publish)) {
        $dlg_var(log) = "1";
    }

    if (is_method("SUBSCRIBE") && $sel(cfg_get.dolog.subscribe)) {
        $dlg_var(log) = "1";
    }

    if (is_method("NOTIFY") && $sel(cfg_get.dolog.notify)) {
        $dlg_var(log) = "1";
    }

    if (is_method("OPTIONS") && $sel(cfg_get.dolog.options)) {
        $dlg_var(log) = "1";
    }

    if (is_method("MESSAGE") && $sel(cfg_get.dolog.message)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REFER") && $sel(cfg_get.dolog.refer)) {
        $dlg_var(log) = "1";
    }

    return;
}

route[DIALOGS_GET_INFO] {
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] DIALOGS-GET-INFO: Set source_ip to $si\n");
    $sht(dialogs=>$ci::source_ip) = $si;

    if (sdp_content()) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] DIALOGS-GET-INFO: Has SDP, check por m= and c= lines\n");

        if(sdp_get_line_startswith("$avp(cline)", "c=")) {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] DIALOGS-GET-INFO: Set media_ip to $(avp(cline){s.select,2, })\n");
            $sht(dialogs=>$ci::media_ip) = $(avp(cline){s.select,2, });
        }

        if (sdp_get_line_startswith("$avp(mline)", "m=")) {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] DIALOGS-GET-INFO: Set media_port to $(avp(mline){s.select,1, })\n");
            $sht(dialogs=>$ci::media_port) = $(avp(mline){s.select,1, });
        }
    }
}

route[RELATE_LEGS] {
    if ($sht(dialogs=>$dlg_var(xcallid)::source_ip) != '') {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] RELATE-LEGS: $ci aleg is $dlg_var(xcallid), set FLT-ISBLEG\n");
        setflag(FLT_ISBLEG);
        $sht(dialogs=>$ci::aleg) = $dlg_var(xcallid);

        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] RELATE-LEGS: $dlg_var(xcallid) bleg is $ci\n");
        $sht(dialogs=>$dlg_var(xcallid)::bleg) = $ci;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] RELATE-LEGS: $dlg_var(xcallid) not present in dialogs htable, skip\n");
    }
}

route[DIALOGS_COPY_INFO] {
    # If aleg found for this dialog, copy keys from each one to another
    if (isflagset(FLT_ISBLEG)) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] DIALOGS-COPY-INFO: aleg found for $ci, copy remote keys and vice versa\n");
        $avp(aleg) = $sht(dialogs=>$ci::aleg);
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] DIALOGS-COPY-INFO: aleg not found for $ci, return\n");
        return;
    }

    # Copy leg1 ($avp(aleg)) info to leg2 ($ci) with remote prefix
    $sht(dialogs=>$ci::remote_source_ip) = $sht(dialogs=>$avp(aleg)::source_ip);
    $sht(dialogs=>$ci::remote_media_ip) = $sht(dialogs=>$avp(aleg)::media_ip);
    $sht(dialogs=>$ci::remote_media_port) = $sht(dialogs=>$avp(aleg)::media_port);

    # Copy leg2 ($ci) info to leg1 ($avp(aleg)) with remote prefix
    $sht(dialogs=>$avp(aleg)::remote_source_ip) = $sht(dialogs=>$ci::source_ip);
    $sht(dialogs=>$avp(aleg)::remote_media_ip) = $sht(dialogs=>$ci::media_ip);
    $sht(dialogs=>$avp(aleg)::remote_media_port) = $sht(dialogs=>$ci::media_port);

    # Try to guest if directmedia seems possible
    if ($sht(dialogs=>$ci::source_ip) == $sht(dialogs=>$ci::remote_source_ip)) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] DIALOGS-COPY-INFO: Source IP of both endpoints is equal, directmedia seems legit\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] DIALOGS-COPY-INFO: Source IP of both endpoints is NOT equal, directmedia NOT possible\n");
    }
}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    # Set proxy value
    $dlg_var(proxy) = 'PSTN';

    # Where is my caller? Order: PAI, RPID, From
    if (is_present_hf("P-Asserted-Identity")) {
        $dlg_var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        $dlg_var(caller) = $(re{uri.user});
    } else {
        $dlg_var(caller) = $fU;
    }

    $dlg_var(callee) = $rU;
    $dlg_var(callid) = $ci;
    if (is_present_hf("Diversion")) {
        $dlg_var(diversion) = $(di{uri.user});

        # Extract X-Info-ForwardExt: (internal extension for outbound fw)
        $var(header) = 'X-Info-ForwardExt';
        route(PARSE_OPTIONAL_X_HEADER);
        if ($(var(header-value){s.len}) > 0 && $var(header-value) != $(di{uri.user})) {
            $dlg_var(diversion) = $dlg_var(diversion) + ' (' + $var(header-value) + ')';
        }
    }

    if (is_present_hf("Referred-by")) {
        $dlg_var(referrer) = $(hdr(Referred-by){nameaddr.uri}{uri.user});
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] Call due to bxfer from $dlg_var(referrer)\n");
        remove_hf("Referred-by");
    }

}

# Reply generic route (all replies goes through this route)
onreply_route {
    route(CONFIGURE_XLOG);
    if ($dlg_var(log)) xlog("L_NOTICE", "[$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ( $rm =~ $sel(cfg_get.dolog.printmsg_methods) ) xlog("L_WARN", "Received reply:\n\n$mb\n");
}

# Reply generic route (additional, for all replies)
onreply_route[MANAGE_REPLY] {
    # Manage RTP
    if ($rs =~ "[12][0-9][0-9]") {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE_REPLY: Non-error reply $rs, call RTPRELAY\n");
        route(RTPRELAY);
    }
}

# Manage failure replies (only for failure response codes, executed after previous 2 routes)

# -- Failure route for GWs
failure_route[MANAGE_FAILURE_GW] {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Call RTPRELAY\n");
    route(RTPRELAY);

    if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] MANAGE-FAILURE-GW: t_is_canceled, exit here\n");
        exit;
    }

    if (isflagset(FLT_REINVITE)) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Skip block logic as it is an error answer to a REINVITE\n");
        exit;
    }

    if (t_check_status("(401)|(407)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code al canto, hay que hacer auth con este provider!\n");

        # Cosa rara de cojones: cuando llega un 401/407 despues de haber hecho un balanceo a otro GW porque el primero
        # no responde, se hereda $du y $ru del primer branch (del fallido). Esto provoca que el INVITE con auth que genera
        # uac_auth() no se mande al segundo GW, sino al primero (que ya esta fuera de todo esto).
        # Solucion temporal despues de volverme loco: resetear du y ru a los valores obtenidos en la ultima invocacion a NEXTGW
        $du = $avp(nextgwdu);
        $ru = $avp(nextgwruri);

        # Nos preparamos para la autenticacion
        #   username:  lo recoge de $avp(provideruser) seteado en NEXTGW
        #   password:  la recoge de $avp(secret) tirando de DB, mas abajo
        #   realm:     la recoge del 401/407 seteando a ''
        $avp(realm) = '';

        # Si $avp(secret) se ha seteado, tenemos credenciales para intentar autenticacion
        if (is_avp_set("$avp(secret)")) {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Secret loaded from AVP, sounds good\n");
            # Envia INVITE con AUTH (y fakea CSeq)
            uac_auth();
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] MANAGE-FAILURE-GW: No secret available for $avp(newfrom), defunct_gw and try another one\n");
            defunct_gw(36000); # No credentials available, defunct gw 4ever and trigger alarm
            route(NEXTGW);
        }
    # FIXME: Which reply codes should avoid failover?
    } else if (t_check_status("486")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Destiny busy (reply code: $T_reply_code)\n");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Error al sacar la llamada (reply code: $T_reply_code)\n");
        # FIXME: Which reply codes should inactivate current GW??
        if (t_check_status("408")) {
            if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] $T_reply_code: Inactivate GW\n");
            inactivate_gw(); # Inactivate GW temporally (until it answers OPTIONS)
        }
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] Try next GW\n");
        route(NEXTGW);
    }

    t_on_failure("MANAGE_FAILURE_GW"); # Ruta de fallo propia para llamadas a GW
    t_on_branch("MANAGE_BRANCH_GW");   # Ruta de branch propia para llamadas a GW
    route(RELAY);
}

failure_route[MANAGE_FAILURE] {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-FAILURE: Call RTPRELAY\n");
    route(RTPRELAY);

    if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] MANAGE-FAILURE: This route should NOT be used, main logic error\n");
    exit;
}

failure_route[MANAGE_FAILURE_AS] {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-FAILURE-AS: Call RTPRELAY\n");
    route(RTPRELAY);

    if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    if (isflagset(FLT_REINVITE)) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-FAILURE-AS: Skip block logic as it is an error answer to a REINVITE\n");
        return;
    }

    # next DST - only for 500 or local timeout
    if (t_check_status("(5[0-9][0-9])|(404)") or (t_branch_timeout() and !t_branch_replied())) {
        ds_mark_dst("ip");
        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    # AS responde algo inesperado, abortamos failover y enviamos 408 Timeout
    if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] MANAGE-FAILURE-AS: Something went wrong, AS seems bugged!\n");
    exit;
}

# Route for branching to GWs: Only for INVITEs and BYEs (fork-able)

# -- Branch route for GWs
branch_route[MANAGE_BRANCH_GW] {
    if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: New branch [$T_branch_idx] to $ru\n");

    # Manage RTP
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: Call RTPRELAY for $ci\n");
    route(RTPRELAY);

    # In initial request, adapt From, To, PAI and RPID to what selected gateway expects
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: Adapt From, To, PAI and RPID to what selected gateway expects\n");

    # avp(caller_method): bitwise flag ABC (in DB integer from 0-7)
    # A: auth_username as from_user flag (4)
    # B: RPID flag (2)
    # C: PAI flag (1)
    #
    # e.g. 5: Use auth_username as from_user and use PAI header

    # Asterisk must never send PAI header when talking to proxytrunks
    if (is_present_hf("P-Asserted-Identity")) {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: Received P-Asserted-Identity header from AS, this should NEVER happen\n");
    }

    # Asterisk should never send RPID header when talking to proxytrunks
    if (is_present_hf("Remote-Party-ID")) {
        if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: Received Remote-Party-ID header from AS, this should NEVER happen\n");
    }

    # Get transformed caller (From) and callee (in $var(calle) and $var(caller))
    route(TRANSFORMATE_OUT);
    $rU = $var(callee);

    # Caller after transformations
    $avp(newfromuser) = $var(caller);
    $avp(newfromdomain) = $Ri; # Use bind ip as from domain
    $avp(newfromuri) = 'sip:' + $avp(newfromuser) + '@' + $avp(newfromdomain);
    # Keep this in dlg_var as uac_replace_from does not work for display name
    $dlg_var(newfromdisplay) = '"' + $avp(newfromuser) + '"'; # "Like this" (entrecomillado)

    # Use PAI?
    if (avp_check("$avp(caller_method)", "and/i:0x01")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: Set PAI to: $dlg_var(newfromdisplay) <$avp(newfromuri)>\n");
        append_hf("P-Asserted-Identity: $dlg_var(newfromdisplay) <$avp(newfromuri)>\r\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: Do not use PAI\n");
    }

    # Use RPID?
    if (avp_check("$avp(caller_method)", "and/i:0x02")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: Set RPID to: $dlg_var(newfromdisplay) <$avp(newfromuri)>\n");
        append_hf("Remote-Party-ID: $dlg_var(newfromdisplay) <$avp(newfromuri)>;privacy=off;screen=no\r\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: Do not use RPID\n");
    }

    # Use auth_username as from_user and ruri_domain as from_domain?
    if (avp_check("$avp(caller_method)", "and/i:0x04")) {
        $avp(newfromuri) = "sip:" + $avp(provideruser) + '@' + $rd;
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: Use auth_username as from_user and ruri_domain as from_domain: $avp(newfromuri)\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: Do not use auth_username as from_user and ruri_domain as from_domain\n");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: New from: $dlg_var(newfromdisplay) <$avp(newfromuri)>\n");
    uac_replace_from('$dlg_var(newfromdisplay)', "$avp(newfromuri)"); # Cambio el From (se auto cambiara en la respuesta)

    # To should be equal to RURI
    $avp(newto) = $ru;
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE-BRANCH-GW: New to: $avp(newto)\n");
    uac_replace_to("$avp(newto)"); # Cambio el To (se auto cambiara en la respuesta)
}

# -- Branch route for ASs
branch_route[MANAGE_BRANCH] {
    if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] MANAGE_BRANCH: New branch [$T_branch_idx] to $ru\n");

    # Manage RTP
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] MANAGE_BRANCH: Call RTPRELAY for $ci\n");
    route(RTPRELAY);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] 200 OK from AS, incoming call from GW to AS $si ($ci)\n");
    } else {
        $dlg_var(peeringContractId) = $avp(peeringContractId);
        if (!$(dlg_var(peeringContractId){s.len})) {
            if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] [$dlg_var(cidhash)] Problems obtaining peeringContractId, THIS CALL WILL NOT BE BILLED ($ci)!\n");
        }

        # Call to DIALOGS_GET_INFO and DIALOGS_COPY_INFO only for 200 OK from GW
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] 200 OK from GW, outgoing call to GW $si ($ci)\n");
        route(DIALOGS_GET_INFO);
        route(DIALOGS_COPY_INFO);
    }

    # New dialog, print stats
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PRINT-STATS: $dlg_var(profile) established for '$dlg_var(companyName)' (id: $dlg_var(companyId)) [$ci]\n");
    route(PRINT_STATS);
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] Dialog ended, delete keys from dialogs htable starting with $ci\n");
    sht_rm_name_re("dialogs=>$ci::*");

    # Dialog end, print stats
    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] PRINT-STATS: $dlg_var(profile) ended for '$dlg_var(companyName)' (id: $dlg_var(companyId)) [$ci]\n");
    route(PRINT_STATS);
}

event_route[dispatcher:dst-down] {
    if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] Destination down: $rm $ru ($du)\n");
}

event_route[dispatcher:dst-up] {
    if ($dlg_var(log)) xlog("L_ERR", "[$dlg_var(cidhash)] Destination up: $rm $ru\n");
}

# Executed for request generated by Kamailio
event_route[tm:local-request] {
    xlog("L_NOTICE","Kamailio generated request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");

    // UACREG sends REGISTER requests whose Contact domain must be addapted
    if ($rm == "REGISTER") {
        xlog("L_INFO", "UAC generated REGISTER, adapt Contact domain\n");
        subst_hf("Contact", "/reg_contact_addr/$sndfrom(ip):$sndfrom(port)/", "a");
    }
}

onsend_route {
    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) {
        if (is_request())
            xlog("L_WARN", "[$dlg_var(cidhash)] Sent request:\n\n$snd(buf)\n");
        else
            xlog("L_WARN", "[$dlg_var(cidhash)] Sent reply:\n\n$snd(buf)\n");
    }
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_WARN", "XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");

    # Ejemplo de lo que recibo de RTPengine:
    #    POST /RPC2 HTTP/1.1.
    #    Host: 5.196.32.135:5060.
    #    Accept: */*.
    #    Content-Type: text/xml.
    #    User-Agent: Xmlrpc-c/1.33.14 Curl/7.38.0.
    #    Content-Length: 210.
    #    
    #    <?xml version="1.0" encoding="UTF-8"?>
    #    <methodCall>
    #    <methodName>teardown</methodName>
    #    <params>
    #    <param><value><string>9c7bc06a-5d29-4bf0-8b89-faafd3da4f50</string></value></param>
    #    </params>
    #    </methodCall>

    # apa del siglo para extraer de ese POST algo XML-alike para luego parsearlo con xmlops
    $var(x) = $(mb{s.select,-1,?}); # Busco la ultima '?' y me quedo de ahi en adelante
    $xml(x=>doc) = $(var(x){s.substr,1,0}); # Me quito '>\n' del principio y lo que queda es XML-alike

    # Extraigo methodName
    $var(methodName) = $xml(x=>xpath:/methodCall/methodName/text());
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: methodName: $var(methodName)\n");

    # Llamo a la ruta adecuada en funcion del comando
    if ($var(methodName) == "teardown")
        route(RTPTIMEOUT);
    else
        route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "GENERIC_XMLRPC_COMMAND: XMLRPC generic command from allowed IP ($si), dispatch!\n");

    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

#TODO (load json & jsonrpc-s modules to work)
route[RTPTIMEOUT] {
    return;
#    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "RTPTIMEOUT: RTPengine wants to hangup a call\n");
#    $var(callid) = $xml(x=>xpath:/methodCall/params/param/value/string/text());
#    $var(fromtag) = $sht(dialogs=>$var(callid)::from_tag);
#
#    # Logica que obtiene $var(h_entry) y $var(h_id) partiendo de $var(callid) y del from_tag guardado en htable(dialogs)
#    jsonrpc_exec('{ "jsonrpc" : "2.0" , "method" : "dlg.dlg_list" , "params" : [ "$var(callid)" , "$var(fromtag)" ], "id" : 1}');
#    $var(json) = $jsonrpl(body);
#
#    # Extraemos json del resultado
#    json_get_field("$var(json)", "result", "$var(result)");
#    json_get_field("$var(result)", "h_entry", "$var(h_entry)");
#
#    # Extraemos h_entry y h_id
#    json_get_field("$var(result)", "h_id", "$var(h_id)");
#
#    # Matamos dialogo con ese h_entry y ese h_id
#    jsonrpc_exec('{ "jsonrpc" : "2.0" , "method" : "dlg.end_dlg" , "params" : [ $var(h_entry) , $var(h_id) ], "id" : 2 }');
#
#    if ($sel(cfg_get.dolog.xmlrpc)) {
#        if ($jsonrpl(code) == "200") {
#            xlog("L_INFO", "RTPTIMEOUT: Dialog ended: $jsonrpl(code) $jsonrpl(text)\n");
#        } else {
#            xlog("L_ERR", "RTPTIMEOUT: Problems killing dialog: $jsonrpl(code) $jsonrpl(text)\n");
#        }
#    }
#
#    xmlrpc_reply("200", "Thanks for all the fish");
}

route[RTPRELAY] {
    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] RTPRELAY: Custom rtpproxy set: $dlg_var(mediaRelaySetsId)\n");
        set_rtp_proxy_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    rtpproxy_manage("coarf");

    if (is_request() && is_method("INVITE") && !has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] RTPRELAY: Chosen RTPproxy instance $var(RTP_INSTANCE)\n");
    }

    if ($avp(recordCall) == 'yes') {
        # Initial INVITE
        if (is_request() && !has_totag()) {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] RTPRELAY: Enable recording for this call (initial $rm)\n");
            start_recording();
        }

        # 200 OK to initial INVITE
        if (is_reply() && $rs =~ "2[0-9][0-9]") {
            if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] RTPRELAY: Enable recording for this call ('$rs $rr' for initial $rm)\n");
            start_recording();
        }
    }
}

route[CONTROL_EXTERNAL_MAXCALLS] {
    if (get_profile_size("activeCalls", "$dlg_var(companyId)", "$avp(activeCalls)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] CONTROL-EXTERNAL-MAXCALLS: Currently, the company $dlg_var(companyName) (companyId: $dlg_var(companyId)) has $avp(activeCalls) active external calls\n");
    }

    if ($dlg_var(externalMaxCalls) == 0) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] CONTROL-EXTERNAL-MAXCALLS: Maxcalls not active for company $dlg_var(companyName) (companyId: $dlg_var(companyId)), count anyway\n");
        set_dlg_profile("activeCalls", "$dlg_var(companyId)");
        return;
    }

    if ($avp(activeCalls) < $dlg_var(externalMaxCalls)) {
        if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] CONTROL-EXTERNAL-MAXCALLS: Call allowed, increment external-call counter to company $dlg_var(companyName) (companyId: $dlg_var(companyId))\n");
        set_dlg_profile("activeCalls", "$dlg_var(companyId)");
    } else {
        if ($dlg_var(log)) xlog("L_WARN", "[$dlg_var(cidhash)] CONTROL-EXTERNAL-MAXCALLS: Call NOT allowed, 403 Forbidden\n");
        sl_send_reply("403","Maxcalls exceeded");
        exit;
    }
}


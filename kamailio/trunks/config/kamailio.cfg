#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define SIP_PORT 5060
#!define SIPS_PORT 5061
#!define XMLRPC_PORT 8001

# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# ACC Flags
#!define FLT_ACC 1
#!define FLT_ACCFAILED 2

# DLG_FLAG
#!define DLG_FLAG 3

# - options
#!define WITH_ANTIFLOOD

#!define DELAY_MEDIALIBERATION
# Note: If defined, Kamailio delays Asterisk initial media liberation for 1 second (only on outbound calls)

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

# Maximum call duration: 3 hours
#!define MAX_DIALOG_TIMEOUT 10800

####### Global Parameters #########

listen=udp:IP:SIP_PORT
listen=tcp:IP:SIP_PORT
listen=tls:IP:SIPS_PORT
listen=tcp:IP:XMLRPC_PORT

# -- Debug level
# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# If debug level of message is lower than current debug parameter, it gets printed
# Current value: 2 (INFO and higher)
#
# This setting can me modified/seen live running:
# kamcmd-proxyusers cfg.seti core debug X
# kamcmd-proxyusers cfg.get core debug

debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes
version_table="kam_version"

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec IvozProvider v2.7"
user_agent_header="User-Agent: Irontec IvozProvider v2.1"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "sqlops.so"
loadmodule    "rtpengine.so"
loadmodule    "cfg_rpc.so"
loadmodule    "dialog.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "acc.so"
loadmodule    "lcr.so"
loadmodule    "uac.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "domain.so"
loadmodule    "cfgutils.so"
loadmodule    "dialplan.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "permissions.so"
loadmodule    "diversion.so"
loadmodule    "evapi.so"
loadmodule    "json.so"
loadmodule    "jansson.so"
loadmodule    "jsonrpcs.so"
loadmodule    "http_client.so"
loadmodule    "ipops.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# JSONRPC-S
modparam("jsonrpcs", "fifo_name", "/tmp/kamailio_proxytrunks_fifo")

# HTTP_CLIENT
modparam("http_client", "httpcon", "cgrates=>http://trunks.ivozprovider.local:2080")
modparam("http_client", "connection_timeout", 2)

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_DSSOCKET)")
modparam("dispatcher", "attrs_avp", "$avp(DSATTRS)")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 2)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@trunks.ivozprovider.local")
modparam("dispatcher", "hash_pvar", "$avp(hash)")

# TLS
modparam("tls", "config", "/etc/kamailio/proxytrunks/tls.cfg")
modparam("tls", "tls_log", 1)

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxytrunks_ctl")

# RTPENGINE
modparam("rtpengine", "db_url", DBURL)
modparam("rtpengine", "table_name", "kam_rtpengine")
modparam("rtpengine", "setid_avp", "$avp(setid)")
modparam("rtpengine", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpengine", "setid_default", 0)

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# ACC
# -- transactions to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- cdr accounting to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 0)
modparam("acc", "cdrs_table", "kam_trunks_cdrs")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);carrierId=$dlg_var(carrierId);direction=$dlg_var(direction);bounced=$dlg_var(bounced);cgrid=$dlg_var(cgrid)")
modparam("acc", "cdr_extra_nullable", 1)

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "activeCallsCompany; activeCallsBrand")
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "track_cseq_updates", 1)
modparam("dialog", "detect_spirals", 0)
modparam("dialog", "default_timeout", MAX_DIALOG_TIMEOUT)

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif
modparam("htable", "htable", "cgrconn=>size=1;")

# UAC
modparam("uac", "auth_realm_avp","$avp(auth_realm)")
modparam("uac", "auth_username_avp","$avp(auth_user)")
modparam("uac", "auth_password_avp","$avp(auth_secret)")
modparam("uac", "restore_mode","auto")
modparam("uac", "restore_dlg", 1)
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_db_table", "kam_trunks_uacreg")
modparam("uac", "reg_contact_addr", "reg_contact_addr")
modparam("uac", "reg_timer_interval", 60)
modparam("uac", "reg_retry_interval", 300)

# LCR
modparam("lcr", "db_url", DBURL)
modparam("lcr", "lcr_gw_table","kam_trunks_lcr_gateways")
modparam("lcr", "lcr_rule_table", "kam_trunks_lcr_rules")
modparam("lcr", "lcr_rule_target_table", "kam_trunks_lcr_rule_targets")
modparam("lcr", "gw_name_column", "gw_name")
modparam("lcr", "ip_addr_column", "ip")
modparam("lcr", "lcr_id_column", "lcr_id")
modparam("lcr", "gw_uri_avp", "$avp(gw_uri_avp)")
modparam("lcr", "ruri_user_avp", "$avp(ruri_user_avp)")
modparam("lcr", "flags_avp", "$avp(s:carrierServerId)")
modparam("lcr", "flags_column", "carrierServerId")
modparam("lcr", "defunct_capability", 1)
modparam("lcr", "lcr_id_avp", "$avp(lcr_id_avp)")
modparam("lcr", "defunct_gw_avp", "$avp(defunct_gw_avp)")
modparam("lcr", "lcr_rule_hash_size", 1024)
modparam("lcr", "lcr_gw_count", 1024)
modparam("lcr", "fetch_rows", 3000)
modparam("lcr", "ping_interval", 15) # Ping every 15 seconds
modparam("lcr", "ping_inactivate_threshold", 1) # Mark as inactive at first call of inactivate_gw()
modparam("lcr", "ping_valid_reply_codes", "403,404,405,501") # Mark as active when 2XX or these reply codes
modparam("lcr", "ping_from", "sip:pinger@localhost")
modparam("lcr", "lcr_count", 1)
modparam("lcr", "dont_strip_or_prefix_flag", 1)
modparam("lcr", "rule_id_avp", "$avp(lcr_rule_id)")

# TM
modparam("tm", "fr_timer", 5000)
modparam("tm", "retr_timer1", 500)

# SANITY
modparam("sanity", "autodrop", 0)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_trunks_domain")
modparam("domain", "domain_attrs_table", "kam_trunks_domain_attrs")
modparam("domain", "register_myself", 1)

# DIALPLAN
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "table_name", "kam_dialplan")
modparam("dialplan", "attrs_pvar", "$avp(s:appliedrule)")

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_trunks_address") # Allowed addresses per DDI provider
modparam("permissions", "trusted_table", "kam_trusted") # IPs excluded from pike checking and wholesale IPs
modparam("permissions", "db_mode", 1)
modparam("permissions", "peer_tag_avp", "$avp(trustedTag)")

####### Routing Logic ########

request_route {
    route(REQINIT);

    route(IS_FROM_INSIDE);

    # Calculate cidhash if not set
    if ($dlg_var(cidhash) == $null)
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});

    if (is_method("OPTIONS")) {
        force_rport();
        send_reply("200", "I'm here!");
        exit;
    }

    xnotice("[$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($proto:$si:$sp) [$ci]\n");

    route(ANTIFLOOD);

    # CANCEL processing
    if (is_method("CANCEL")) {
        xinfo("[$dlg_var(cidhash)] ----> $rm from $si\n");
        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RTPENGINE);
            route(RELAY);
        }

        xerr("[$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # Manage retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    ### only initial requests (no To tag)

    # Only INVITE can start a dialog
    if (!is_method("INVITE")) {
        xwarn("[$dlg_var(cidhash)] $rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Remove preloaded route headers
    remove_hf("Route");

    # Manage dialog
    dlg_manage();

    # Calculate cidhash if not set
    if ($dlg_var(cidhash) == $null)
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});

    # Transformate numbers for calls from carriers
    if (!$var(is_from_inside)) {
        route(GET_TRANSFORMATIONS_IN);
        route(TRANSFORMATE_IN);
    }

    # Inspect new request
    route(CLASSIFY);

    # Get codec capabilities for call
    route(GET_CODEC_INFO);

    # Setup accounting
    route(ACCOUNTING);

    # Add record-route to INVITE requests
    record_route();

    # Easy routing
    # (a) From inside world
    # (b) From outside world
    if ($var(is_from_inside)) {
        xinfo("[$dlg_var(cidhash)] IvozProvider calling, route to corresponding GW\n");

        route(PARSE_X_HEADERS);
        route(SAVE_CONTACT);
        route(GET_INFO_FROM_COMPANY);

        #!ifdef DELAY_MEDIALIBERATION
        $dlg_var(initial_reinvite) = 'pending';
        #!endif

        # Check if this call is to one of our DDIs
        route(CHECK_BOUNCE);

        # Call RTPENGINE before branching (avoids call in failure routes)
        route(RTPENGINE);

        # Evaluate routing logic
        route(LOAD_GWS);

        # Check if this call requires rater acceptance
        route(CHECK_RATER);

        if ($var(needsRater) == 1) {
            route(CGRATES_AUTH_REQUEST);
        } else {
            route(SELECT_NEXT_GW);
            route(RELAY);
        }
    } else {
        if (uri == myself) {
            xinfo("[$dlg_var(cidhash)] Someone calling to my domain, dispatch to next hop\n");
            remove_hf_re("^X-"); # Remove X-HEADERS from carriers
            route(GET_INFO_FROM_MATCHED_DDI);
            route(CONTROL_MAXCALLS);
            route(DISPATCH);
            route(SETUP_KAMUSERS_CALL);
            route(RTPENGINE);
            route(RELAY);
        } else {
            xerr("[$dlg_var(cidhash)] $rd is not one of my domains, 404 Not Here\n");
            send_reply("404", "Not Here");
            exit;
        }
    }

    xerr("[$dlg_var(cidhash)] Main script error, should NOT arrive this point.\n");
    drop;
}

# This route sets $var(is_from_inside): 1 / 0
#   - 1: request/response comes from the inside
#   - 0: request/response comes from the outside world
route[IS_FROM_INSIDE] {
    if (ds_is_from_list("1") || $si == $var(usersAddress)) {
        $var(is_from_inside) = 1;
    } else {
        $var(is_from_inside) = 0;
    }
}

route[CHECK_BOUNCE] {
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isMine FROM DDIs WHERE DDIE164='$rU'", "ra");
    if ($xavp(ra=>isMine) == '1') {
        xinfo("[$dlg_var(cidhash)] CHECK-BOUNCE: Call is to one of my DDIs\n");
        $dlg_var(bounced) = '1';
    }
}

route[REQINIT] {
    # Easy dropping for scanners
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent" || search("sipvicious")) {
        xwarn("REQINIT: Dropping scanner request ----> $rm from $si\n");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        xerr("REQINIT: Dropping malformed SIP message from $si:$sp\n");
        exit;
    }

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        xerr("REQINIT: Too many hops for SIP message from $si:$sp\n");
        send_reply("483","Too Many Hops");
        exit;
    }
}

route[LOAD_GWS] {
    $var(filter) = 'b' + $dlg_var(brandId) + 'c' + $dlg_var(companyId);
    if ($avp(fax)) {
        load_gws(1, 'fax', $var(filter));
        if ($avp(gw_uri_avp) != $null) {
            xwarn("[$dlg_var(cidhash)] LOAD-GWS: Fax specific route found\n");
        }
    }

    if ($avp(gw_uri_avp) == $null) {
        $var(prefix) = $dlg_var(routingTag) + $rU;
        load_gws(1, $var(prefix), $var(filter));
    }

    if ($avp(gw_uri_avp) != $null) {
        # At least one gateway loaded, continue

        # Print GWs added by Kamailio lcr module
        $var(i) = 0;
        xinfo("[$dlg_var(cidhash)] LOAD-GWS: Carriers added by Kamailio lcr module\n");
        while(is_avp_set("$(avp(gw_uri_avp)[$var(i)])")) {
            xinfo("[$dlg_var(cidhash)] LOAD-GWS: [$var(i)]: $(avp(gw_uri_avp)[$var(i)])\n");
            $var(i) = $var(i) + 1;
        }

        # Lookup for dummy GWs and replace them with CGRateS LCR gateways
        $var(i) = 0;
        while(is_avp_set("$(avp(gw_uri_avp)[$var(i)])")) {
            $var(rule_id) = $(avp(gw_uri_avp)[$var(i)]{s.select,-1,|});
            $var(gw_hostname) = $(avp(gw_uri_avp)[$var(i)]{s.select,6,|});
            if ($var(gw_hostname) == "dummy.ivozprovider.local") {
                xinfo("[$dlg_var(cidhash)] REPLACE-DUMMY-GWS: Dummy GW found, replace it with LCR gateways");
                route(ADD_LCR_CARRIERS);
            } else {
                $avp(new_gw_uri_avp) = $(avp(gw_uri_avp)[$var(i)]);
            }
            $var(i) = $var(i) + 1;
        }

        $(avp(gw_uri_avp)[*]) = $null;
        avp_copy("$avp(new_gw_uri_avp)", "$avp(gw_uri_avp)/gd");

        # Print final GWs (static + dynamic)
        $var(i) = 0;
        xinfo("[$dlg_var(cidhash)] LOAD-GWS: Final carriers (static + dynamic rules)\n");
        while(is_avp_set("$(avp(gw_uri_avp)[$var(i)])")) {
            xinfo("[$dlg_var(cidhash)] LOAD-GWS: [$var(i)]: $(avp(gw_uri_avp)[$var(i)])\n");
            $var(i) = $var(i) + 1;
        }
    } else {
        xerr("[$dlg_var(cidhash)] LOAD-GWS: No valid gateway for '$rU' for company '$dlg_var(companyId)'\n");
        send_reply("500", "Server Internal Error - No gateways");
        exit;
    }
}

route[CHECK_RATER] {
    # Loop over $avp(gw_uri_avp): if non-externally-rating GW found, set $var(needsRater) to 1 and leave
    $var(needsRater) = 0;

    $var(m) = 0;
    while(is_avp_set("$(avp(gw_uri_avp)[$var(m)])")) {
        $var(carrierServerId) = $(avp(gw_uri_avp)[$var(m)]{s.select,10,|});

        sql_xquery("cb", "SELECT C.externallyRated FROM CarrierServers CS JOIN Carriers C ON CS.carrierId=C.id WHERE CS.id=$var(carrierServerId)", "ra");

        if ($xavp(ra=>externallyRated) != '1') {
            $var(needsRater) = 1;
            break;
        }

        $var(m) = $var(m) + 1;
    }

    xinfo("[$dlg_var(cidhash)] CHECK-RATER: needsRater -> $var(needsRater)");
}

# This route calls ADD_LCR_CARRIER for each Carrier in $avp(carriers)
route[ADD_LCR_CARRIERS] {
    # Prepare CGRateS request
    $var(cgrTenant) = 'b' + $dlg_var(brandId);
    $var(cgrAccount) = 'c' + $dlg_var(companyId);
    $var(cgrDestination) = $rU;

    if ($dlg_var(routingTagId) != $null) {
        $var(cgrSubject) = $dlg_var(routingTag);
    } else {
        $var(cgrSubject) = "";
    }

    sql_xquery("cb", "SELECT outgoingRoutingId FROM kam_trunks_lcr_rules WHERE id='$var(rule_id)'", "ra");
    $var(cgrCategory) = "or" + $xavp(ra=>outgoingRoutingId);

    xinfo("[$dlg_var(cidhash)] GET-LCR-CARRIERS: Ask CGRateS for LCR carriers ($var(cgrTenant):$var(cgrAccount):$var(cgrSubject):$var(cgrDestination):$var(cgrCategory))");

    # Ask CGRateS for LCR carriers
    $var(rc) = http_connect("cgrates", "/jsonrpc", "application/json", "{\"method\":\"ApierV1.GetLcr\",\"params\":[{\"Tenant\":\"$var(cgrTenant)\",\"Category\":\"$var(cgrCategory)\",\"Account\":\"$var(cgrAccount)\",\"Subject\":\"$var(cgrSubject)\",\"Destination\":\"$var(cgrDestination)\"}],\"id\":1}", "$avp(response)");
    xinfo("[$dlg_var(cidhash)] GET-LCR-CARRIERS: API-server HTTP connection result code: $var(rc)\n");
    xinfo("[$dlg_var(cidhash)] GET-LCR-CARRIERS: API-server HTTP connection response: $avp(response)\n");

    json_get_field("$avp(response)", "error", "$var(errorField)");
    if ($var(rc) != "200" || $var(errorField) != '') {
        xerr("[$dlg_var(cidhash)] GET-LCR-CARRIERS: Error non-empty or non-200 retcode");
        return;
    }
    json_get_field("$avp(response)", "result", "$var(resultField)");

    $var(count) = 0;
    jansson_array_size("Suppliers", $var(resultField), "$var(size)");
    while($var(count) < $var(size)) {
        jansson_get("Suppliers[$var(count)]", $var(resultField), "$var(v)");
        json_get_field("$var(v)", "Supplier", "$var(carrier)");
        xinfo("[$dlg_var(cidhash)] GET-LCR-CARRIERS: Add carrier $var(carrier)");

        $var(carrierId) = $(var(carrier){s.numeric});
        route(ADD_LCR_CARRIER);

        $var(count) = $var(count) + 1;
    }
}

# This route calls ADD_LCR_CARRIERSERVER for each carrierServer in $var(carrierId)
route[ADD_LCR_CARRIER] {
    sql_query("cb", "SELECT id FROM CarrierServers WHERE carrierId=$var(carrierId)", "ra");

    if ($dbr(ra=>rows) == 0) {
        xwarn("[$dlg_var(cidhash)] ADD-LCR-CARRIERS: No CarrierServers found for carrierId '$var(carrierId)'\n");
        return;
    }

    $var(k) = 0;
    while ($var(k)<$dbr(ra=>rows)) {
        $var(carrierServerId) = $dbr(ra=>[$var(k), 0]);
        route(ADD_LCR_CARRIERSERVER);
        $var(k) = $var(k) + 1;
    }

    sql_result_free("ra");
}

# This route adds one entry to $avp(new_gw_uri_avp) for CarrierServer in $var(carrierServerId)
route[ADD_LCR_CARRIERSERVER]{
    sql_xquery("cb", "SELECT uri_scheme, IFNULL(ip, '') AS ip, IFNULL(hostname, '') AS hostname, port, transport FROM kam_trunks_lcr_gateways WHERE carrierServerId=$var(carrierServerId)", "ra");

    if ($xavp(ra=>scheme) == '2') {
        $var(scheme) = 'sips:';
    } else {
        $var(scheme) = 'sip:';
    }

    if ($xavp(ra=>transport) == '2') {
        $var(transport) = ';transport=tcp';
    } else if ($xavp(ra=>transport) == '3') {
        $var(transport) = ';transport=tls';
    } else {
        $var(transport) = ';transport=udp';
    }

    avp_printf("$avp(avp_new_entry)", "0|$var(scheme)|0|||$xavp(ra=>ip)|$xavp(ra=>hostname)|$xavp(ra=>port)||$var(transport)|$var(carrierServerId)|$var(rule_id)");
    xinfo("[$dlg_var(cidhash)] ADD-LCR-CARRIERSERVER: New entry in gw_uri_avp for CarrierServer [$var(carrierServerId)]: '$avp(avp_new_entry)'");

    $avp(new_gw_uri_avp) = $avp(avp_new_entry);
}

route[SELECT_NEXT_GW] {
    # Evaluate gateway rules
    if (!next_gw()) {
        xerr("[$dlg_var(cidhash)] SELECT-NEXT-GW: NO next GW, send 503 No gateways");
        send_reply("503", "No gateways");
        exit;
    }

    # GW selection may modify both $ru and $du
    xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: New dest-URI $du\n");
    xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: New RURI $ru\n");

    # Skip GW if has an unresolvable domain
    if(!is_ip("$nh(d)")) {
        if (!dns_query("$nh(d)", "nextgwaddr")) {
            xwarn("[$dlg_var(cidhash)] SELECT-NEXT-GW: Not resolvable domain '$nh(d)', skip GW");
            route(SELECT_NEXT_GW);
        } else {
            xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: Resolvable domain '$nh(d)' ($dns(nextgwaddr=>addr)) in GW, proceed");
        }
    }

    # Obtain info about selected GW
    sql_xquery("cb", "SELECT C.externallyRated, C.calculateCost, CS.sendPAI, CS.sendRPID, CS.authNeeded, CS.authUser, CS.authPassword, CS.carrierId, CS.fromUser, CS.fromDomain FROM CarrierServers CS JOIN Carriers C ON CS.carrierId=C.id WHERE CS.id=$avp(carrierServerId)", "ra");

    if ( $(xavp(ra=>carrierId){s.len}) ) {
        $dlg_var(carrierId) = $xavp(ra=>carrierId);
        $dlg_var(calculateCost) = $xavp(ra=>calculateCost);
        xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: carrierId: $dlg_var(carrierId)\n");
    } else {
        xerr("[$dlg_var(cidhash)] SELECT-NEXT-GW: Error obtaining 'carrierId' for carrierServerId '$avp(carrierServerId)'\n");
        send_reply("500", "Server Internal Error");
        exit;
    }

    if ($xavp(ra=>externallyRated) == '1') {
        # Externally rating GW
        $dlg_var(cgrid) = $null;
        dlg_set_timeout(MAX_DIALOG_TIMEOUT);
    } else {
        # CGRateS GW
        if ($dlg_var(cgrDeclined) == 'yes') {
            # CGRateS already asked and declined
            route(SELECT_NEXT_GW);
        } else {
            # CGRateS already asked and approved
            $dlg_var(cgrid) = $dlg_var(cgridPersist);
            dlg_set_timeout($dlg_var(CgrMaxSessionTime));
        }
    }

    if ($xavp(ra=>authNeeded) == 'yes') {
        if ( $(xavp(ra=>authUser){s.len}) ) {
            $avp(auth_user) = $xavp(ra=>authUser);
        } else {
            xwarn("[$dlg_var(cidhash)] SELECT-NEXT-GW: Error obtaining 'provideruser' for carrierServerId '$avp(carrierServerId)'\n");
        }

        if ( $(xavp(ra=>authPassword){s.len}) ) {
            $avp(auth_secret) = $xavp(ra=>authPassword);
        } else {
            xwarn("[$dlg_var(cidhash)] SELECT-NEXT-GW: Error obtaining 'secret' for carrierServerId '$avp(carrierServerId)'\n");
        }
    } else {
        $avp(auth_user) = $null;
        $avp(auth_secret) = $null;
    }

    if ( $(xavp(ra=>fromUser){s.len}) ) {
        $avp(from_user) = $xavp(ra=>fromUser);
    } else {
        $avp(from_user) = $null;
    }

    if ( $(xavp(ra=>fromDomain){s.len}) ) {
        $avp(from_domain) = $xavp(ra=>fromDomain);
    } else {
        $avp(from_domain) = $null;
    }

    $avp(send_pai) = $xavp(ra=>sendPAI);
    $avp(send_rpid) = $xavp(ra=>sendRPID);

    # Reset auth flag
    $avp(auth_done) = '0';

    # Obtain info about selected route (prefix and clid)
    sql_xquery("cb", "SELECT O.prefix, O.forceClid, CONCAT(C.countryCode, O.clid) AS finalClid FROM kam_trunks_lcr_rules KTLR JOIN OutgoingRouting O ON O.id=KTLR.outgoingRoutingId LEFT JOIN Countries C ON C.id=O.clidCountryId WHERE KTLR.id=$avp(lcr_rule_id)", "rb");
    if ( $(xavp(rb=>prefix){s.len})) {
        $dlg_var(route_prefix) = $xavp(rb=>prefix);
    } else {
        $dlg_var(route_prefix) = $null;
    }

    if ($xavp(rb=>forceClid) == '1') {
        $dlg_var(route_clid) = $xavp(rb=>finalClid);
    } else {
        $dlg_var(route_clid) = $null;
    }

    xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: Route prefix: $dlg_var(route_prefix)");
    xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: Route clid: $dlg_var(route_clid)");

    # Set failure and branch route
    t_on_failure("MANAGE_FAILURE_GW");
    t_on_branch("MANAGE_BRANCH_GW");
}

route[PARSE_X_HEADERS] {
    # Extract routing tag
    $var(header) = 'X-Info-RoutingTag';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') {
        xinfo("[$dlg_var(cidhash)] X-HEADERS-OTHER: '$var(header)' header found: $var(header-value)\n");
        $dlg_var(routingTag) = $var(header-value);
    }

    # Extract routing tag Id
    $var(header) = 'X-Info-RoutingTagId';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') {
        xinfo("[$dlg_var(cidhash)] X-HEADERS-OTHER: '$var(header)' header found: $var(header-value)\n");
        $dlg_var(routingTagId) = $var(header-value);
    }

    # Extract Record header
    $var(header) = 'X-Info-Record';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) == 'yes') {
        xinfo("[$dlg_var(cidhash)] X-HEADERS-OTHER: '$var(header)' header found, call will be recorded\n");
        $avp(recordCall) = 'yes';
    }

    if ($dlg_var(type) == 'wholesale' || $dlg_var(type) == 'retail') return;

    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(xcallid) = $var(header-value);

    # -- xcallid is mandatory for every normal call.
    #    Check if X-Info-Special header is present with 'fax' value (current only exception)
    if ($(dlg_var(xcallid){s.len}) == 0) {
        $var(header) = 'X-Info-Special';
        route(PARSE_OPTIONAL_X_HEADER);
        if ($var(header-value) == 'fax') {
            xinfo("[$dlg_var(cidhash)] X-HEADERS-OTHER: Special case without xcallid: fax\n");
            $avp(fax) = '1';
        } else {
            xerr("[$dlg_var(cidhash)] X-HEADERS-OTHER: Invalid $var(header) value ($var(header-value)) for call without xcallid\n");
            send_reply("500", "x-callid is missing");
            exit;
        }
    } else {
        xnotice("[$dlg_var(cidhash)] X-HEADERS-OTHER: Related leg: $dlg_var(xcallid)\n");
    }
}

# Header might not be present and, if present, might be empty
route[PARSE_OPTIONAL_X_HEADER] {
    if (is_present_hf($var(header))) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        $var(header-value) = '';
    }
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        xerr("[$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[TRANSFORMATE_WITHINDLG] {
    if (!is_method("INVITE|UPDATE")) return;
    if (!is_present_hf("P-Asserted-Identity") && !is_present_hf("remote-party-id")) return;

    if ($var(is_from_inside)) {
        route(TRANSFORMATE_OUT);
    } else {
        route(TRANSFORMATE_IN);
    }
}

# Get incoming tranformations (sets tr_* dlg_vars)
route[GET_TRANSFORMATIONS_IN] {
    if (src_ip == myself) return; # Bounced calls already in E.164

    # Get all DDI candidates
    sql_query("cb", "SELECT D.DDIE164, CONCAT(DP.transformationRuleSetId, 1) AS callee_in, CONCAT(DP.transformationRuleSetId, 0) AS caller_in, CONCAT(DP.transformationRuleSetId, 2) AS caller_out, CONCAT(DP.transformationRuleSetId, 3) AS callee_out FROM DDIProviderAddresses DPA INNER JOIN DDIProviders DP ON DPA.ddiProviderId=DP.id INNER JOIN DDIs D ON D.ddiProviderId=DP.id WHERE ip='$si'", "ra");

    # Are there any candidates?
    if ($dbr(ra=>rows) == 0) {
        xwarn("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: $rU not recognized in any company, 404 Not Found\n");
        send_reply("404", "Not Here");
        exit;
    } else {
        xinfo("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: There are $dbr(ra=>rows) DDI candidates, proceed\n");
    }

    # Evaluate all candidates ($rU after transformation must be equal to candidate, otherwise it is rejected)
    $var(i) = 0;
    while ($var(i)<$dbr(ra=>rows)) {
        $var(candidate) = $dbr(ra=>[$var(i), 0]);
        $var(transformation) = $dbr(ra=>[$var(i), 1]);
        $var(number) = $rU;
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        if ($var(transformated) == $var(candidate)) {
            # We have a winner candidate!!
            xinfo("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: Callee $rU is recognized as $var(candidate) (should be E164)\n");

            # Save transformations for further application
            $dlg_var(tr_callee_in) = $dbr(ra=>[$var(i), 1]);
            $dlg_var(tr_caller_in) = $dbr(ra=>[$var(i), 2]);
            $dlg_var(tr_caller_out) = $dbr(ra=>[$var(i), 3]);
            $dlg_var(tr_callee_out) = $dbr(ra=>[$var(i), 4]);

            # Free and leave
            sql_result_free("ra");
            return;
        }
        $var(i) = $var(i) + 1;
    }

    sql_result_free("ra");

    # No candidate succeeded after applying transformations
    xwarn("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: No DDI candidate succeeded after applying transformations to $rU, 404 Not Found");
    send_reply("404", "Not Here");
    exit;
}

# This route apply transformations to rU, PAI and Diversion to E.164
route[TRANSFORMATE_IN] {
    if ($dlg_var(tr_caller_in) != $null) {
        route(GET_CALLER); # Greps caller and sets it in $var(number)
        $var(transformation) = $dlg_var(tr_caller_in);
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        route(SET_CALLER); # Sets caller using $var(transformated) value
    }

    if (has_totag()) return; # in-dialog messages only need pai/rpid mangling

    if ($dlg_var(tr_callee_in) != $null) {
        $var(transformation) = $dlg_var(tr_callee_in);
        $var(number) = $rU;
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        $rU = $var(transformated);
    }

    if ($dlg_var(tr_caller_in) != $null) {
        # Apply the same transformation to first Diversion header
        if (is_present_hf("Diversion")) {
            $var(number) = $(di{uri.user});
            if ($var(number) != $null) {
                $avp(reason) = @hf_value.diversion[0].param['reason'];
                if ($avp(reason) == $null) {
                    xinfo("[$dlg_var(cidhash)] TRANSFORMATE-IN: No reason extracted, set 'deflection'\n");
                    $avp(reason) = 'deflection';
                }

                xinfo("[$dlg_var(cidhash)] TRANSFORMATE-IN: Initial diversion -> $var(number)\n");
                $var(transformation) = $dlg_var(tr_caller_in);
                route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)

                remove_hf_value("Diversion[0]");
                add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $(di{uri.host}));
            }
        }
    }
}

# Sets caller in $var(number) seeking in PAI/RPID/From (in this order)
route[GET_CALLER] {
    # Where is my caller? PAI/RPID/From?
    if (is_present_hf("P-Asserted-Identity")) {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: PAI present: $(ai{uri.user})\n");
        $var(number) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: RPID present: $(re{uri.user})\n");
        $var(number) = $(re{uri.user});
    } else {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: Nor PAI nor RPID present, only From ($fU)! :(\n");
        $var(number) = $fU;
    }
}

# Sets caller in PAI/RPID/From using $var(transformated) value
route[SET_CALLER] {
    # Initial requests
    if (!has_totag()) {
        if ($var(is_from_inside)) {
            # Initial request to GW need special caller mangling

            # Set caller for carrier
            $var(newfromdomain) = $Ri; # Use bind ip as from domain
            $var(newfromuri) = 'sip:' + $var(transformated) + '@' + $var(newfromdomain);

            # Use PAI?
            remove_hf("P-Asserted-Identity");
            if ($avp(send_pai)) {
                xinfo("[$dlg_var(cidhash)] SET-CALLER: Set PAI to: $var(newfromuri)\n");
                append_hf("P-Asserted-Identity: <$var(newfromuri)>\r\n");
            }

            # Use RPID?
            remove_hf("Remote-Party-ID");
            if ($avp(send_rpid)) {
                xinfo("[$dlg_var(cidhash)] SET-CALLER: Set RPID to: $var(newfromuri)\n");
                append_hf("Remote-Party-ID: $var(newfromuri);privacy=off;screen=no\r\n");
            }

            # Set GW from_user and from_domain if necessary
            if ($avp(from_user) != $null) $var(transformated) = $avp(from_user);
            if ($avp(from_domain) != $null) $var(newfromdomain) = $avp(from_domain);
            $var(newfromuri) = "sip:" + $var(transformated) + '@' + $var(newfromdomain);
            xinfo("[$dlg_var(cidhash)] SET-CALLER: New from: $var(newfromuri)\n");
            uac_replace_from("", "$var(newfromuri)"); # Change From header for GW
        } else {
            # Initial request from GW
            if ($fU != $var(transformated)) {
                $var(newfromuri) = 'sip:' + $var(transformated) + '@' + $fd;
                uac_replace_from("", "$var(newfromuri)"); # Change From header for GW
            }
        }
    }

    # All in-dialog requests + all requests from GWs
    if (!$var(is_from_inside) || has_totag()) {
        if (is_present_hf("P-Asserted-Identity")) {
            if ($(ai{uri.user}) != $var(transformated)) { # If new value differs from previous, change
                remove_hf("P-Asserted-Identity");
                append_hf("P-Asserted-Identity: <sip:$var(transformated)@$(ai{uri.host})>\r\n");
            }
        }

        if (is_present_hf("Remote-Party-ID")) {
            if ($(re{uri.user}) != $var(transformated)) { # If new value differs from previous, change
                remove_hf("Remote-Party-ID");
                append_hf("Remote-Party-ID: <sip:$var(transformated)@$(re{uri.host})>\r\n");
            }
        }
    }
}

route[GET_TRANSFORMATIONS_OUT] {
    sql_xquery("cb", "SELECT CONCAT(transformationRuleSetId, 0) AS caller_in, CONCAT(transformationRuleSetId, 1) AS callee_in, CONCAT(transformationRuleSetId, 2) AS caller_out, CONCAT(transformationRuleSetId, 3) AS callee_out FROM Carriers WHERE id=$dlg_var(carrierId)", "ra");

    $dlg_var(tr_caller_in) = $xavp(ra=>caller_in);
    $dlg_var(tr_callee_in) = $xavp(ra=>callee_in);
    $dlg_var(tr_caller_out) = $xavp(ra=>caller_out);
    $dlg_var(tr_callee_out) = $xavp(ra=>callee_out);

    return;
}

# Transformate all numbers to GW format
route[TRANSFORMATE_OUT] {
    if ($dlg_var(bounced) == '1') return; # Skip transformation in bounced calls

    if ($dlg_var(route_clid) == $null) {
        route(GET_CALLER); # Greps caller and sets it in $var(number)
    } else {
        xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: Route force clid '$dlg_var(route_clid)'");
        $var(number) = $dlg_var(route_clid);
    }
    $var(transformation) = $dlg_var(tr_caller_out);
    route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
    route(SET_CALLER);

    # in-dialog messages only need pai/rpid mangling
    if (has_totag()) return;

    # Transformate callee_out
    xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: Initial callee -> $rU\n");
    $var(transformation) = $dlg_var(tr_callee_out);
    $var(number) = $rU;
    route(APPLY_TRANSFORMATION);
    $rU = $var(transformated);
    if ($dlg_var(route_prefix) != $null) {
        xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: Add route prefix '$dlg_var(route_prefix)'");
        $rU = $dlg_var(route_prefix) + $rU;
    }
    xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: New to: $ru\n");
    uac_replace_to("$ru");

    # Transformate first Diversion header
    if (is_present_hf("Diversion")) {
        $var(number) = $(di{uri.user});
        if ($var(number) != $null) {
            $avp(reason) = @hf_value.diversion[0].param['reason'];
            if ($avp(reason) == $null) {
                xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: No reason extracted, set 'deflection'\n");
                $avp(reason) = 'deflection';
            }

            xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: Initial diversion -> $var(number)\n");
            $var(transformation) = $xavp(ra=>caller_out);
            route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)

            remove_hf_value("Diversion[0]");
            add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $dlg_var(companyDomain));
        }
    }
}

# Apply $var(transformation) transformations (if set) to $var(number)
# Sets result in $var(transformated)
route[APPLY_TRANSFORMATION] {
    $var(transformated) = $var(number);
    $avp(appliedrule) = $null;

    dp_translate("$(var(transformation){s.int})", "$var(number)/$var(transformated)");

    # If no rule applied, re-set value
    if ($avp(appliedrule) == $null)
        $var(transformated) = $var(number);

    xinfo("[$dlg_var(cidhash)] APPLY-TRANSFORMATION: Number after: $var(transformated) (applied rule: '$avp(appliedrule)')\n");
}

route[GET_INFO_FROM_MATCHED_DDI] {
    sql_xquery("cb", "SELECT c.mediaRelaySetsId, c.maxCalls AS maxCallsCompany, b.maxCalls AS maxCallsBrand, d.recordCalls, c.distributeMethod, AppS.ip AS asAddress FROM DDIs d JOIN Companies c ON d.companyId=c.id LEFT JOIN ApplicationServers AppS ON AppS.id=c.applicationServerId JOIN Brands b ON c.brandId=b.id WHERE d.DDIE164='$rU'", "ra");

    # Matched DDI
    $dlg_var(maxCallsCompany) = $xavp(ra=>maxCallsCompany);
    $dlg_var(maxCallsBrand) = $xavp(ra=>maxCallsBrand);

    # Recording settings
    if ($xavp(ra=>recordCalls) == 'inbound' || $xavp(ra=>recordCalls) == 'all') {
        $avp(recordCall) = 'yes';
    }

    # Distribute method
    $dlg_var(distributeMethod) = $xavp(ra=>distributeMethod);
    $avp(asAddress) = $xavp(ra=>asAddress);

    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
}

route[GET_INFO_FROM_COMPANY] {
    sql_xquery("cb", "SELECT D.domain, C.billingMethod, C.mediaRelaySetsId FROM Companies C LEFT JOIN Domains D ON C.domainId=D.id WHERE C.id='$dlg_var(companyId)'", "ra");

    $dlg_var(cgrReqType) = '*' + $xavp(ra=>billingMethod);
    $dlg_var(companyDomain) = $xavp(ra=>domain);
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);

    return;
}

# Handle within-dialog messages
route[WITHINDLG] {
    if (!$dlg_var(confirmed) && is_method("UPDATE|INVITE")) drop;

    # REFER not allowed
    if (is_method("REFER")) {
        xerr("[$dlg_var(cidhash)] WITHINDLG: 'REFER' not supported\n");
        send_reply("405","Method Not Allowed");
        exit;
    }

    route(TRANSFORMATE_WITHINDLG);

    # Reinvite handling
    if (is_method("INVITE")) {
        #!ifdef DELAY_MEDIALIBERATION
        if ($dlg_var(initial_reinvite) == 'pending') {
            xinfo("[$dlg_var(cidhash)] WITHINDLG: Initial reinvite from call initiated by AS\n");
            $dlg_var(initial_reinvite) = 'yes';
        } else {
            $dlg_var(initial_reinvite) = 'no';
        }
        #!endif
    }

    # Fix overridden R-URI if needed
    if (!$var(is_from_inside) && $dlg_var(contact) != $null && uri != $dlg_var(contact) && $dlg_var(bounced) != '1') {
        xwarn("[$dlg_var(cidhash)] WITHINDLG: Fix overridden contact ($ru -> $dlg_var(contact))\n");
        $ru = $dlg_var(contact);
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        }
        route(RTPENGINE);
        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RTPENGINE);
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        send_reply("403","Not here");
    }
}

route[DISPATCH] {
    if ($dlg_var(type) == 'retail') {
        # No AS in retail calls, send to kamusers
        $du = "sip:users.ivozprovider.local";
        return;
    }

    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Static routing to specific AS?
    if ($dlg_var(distributeMethod) == 'static') {
        $du = "sip:" + $avp(asAddress) + ":6060";
        xinfo("[$dlg_var(cidhash)] DISPATCH: Company has static routing enabled\n");
    } else {
        if ($dlg_var(distributeMethod) == 'hash') {
            $avp(hash) = $dlg_var(companyId);
            # hash over $avp(hash)
            xinfo("[$dlg_var(cidhash)] DISPATCH: Dispatch hashing '$avp(hash)'\n");
            $var(alg) = 7;
        } else {
            # round robin dispatching on ASs (distributeMethod == 'rr')
            xinfo("[$dlg_var(cidhash)] DISPATCH: dispatch to any AS (round robin)\n");
            $var(alg) = 4;
        }

        if(!ds_select_dst("1", "$var(alg)")) {
            xerr("[$dlg_var(cidhash)] DISPATCH: No destination found\n");
            send_reply("404", "No destination");
            exit;
        } else {
            xinfo("[$dlg_var(cidhash)] DISPATCH: $avp(AVP_CNT) destination(s) found\n");
        }
    }

    t_on_failure("MANAGE_FAILURE_AS");
    xinfo("[$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du>\n");
}

route[SETUP_KAMUSERS_CALL] {
    if ($dlg_var(type) != 'retail') return;

    # Insert X-Info headers for kamusers
    insert_hf("X-Info-BrandId: $dlg_var(brandId)\r\n");
    insert_hf("X-Info-CompanyId: $dlg_var(companyId)\r\n");
    insert_hf("X-Info-Type: $dlg_var(type)\r\n");
    insert_hf("X-Info-Callee: $rU\r\n");

    # Update $ru using retail account username@domain
    sql_xquery("cb", "SELECT RA.name AS username, DS.domain AS domain FROM DDIs D INNER JOIN RetailAccounts RA ON D.retailAccountId=RA.id INNER JOIN Domains DS ON RA.domainId=DS.id WHERE DDIE164='$rU'", "ra");
    $ru = "sip:" + $xavp(ra=>username) + '@' + $xavp(ra=>domain);
}

# Relay request
route[RELAY] {
    # Route bounced calls to myself
    if ($dlg_var(bounced) == '1' && !has_totag() && $var(is_from_inside)) {
        xinfo("[$dlg_var(cidhash)] RELAY: Bounce call to myself\n");
        $du = "sip:trunks.ivozprovider.local:" + SIP_PORT;
        $rd = "trunks.ivozprovider.local";
    }

    if ($(du{uri.host}) != $null) {
        xinfo("[$dlg_var(cidhash)] RELAY: Relaying to $(du{uri.host}) (du, $dP)\n");
    } else {
        xinfo("[$dlg_var(cidhash)] RELAY: Relaying to $(ru{uri.host}) (ru)\n");
    }

    # Common for every reply
    t_on_reply("MANAGE_REPLY");

    if (!t_relay())
        sl_reply_error();

    exit;
}

route[ANTIFLOOD] {
#!ifdef WITH_ANTIFLOOD
    # Inside call
    if (src_ip == myself || $var(is_from_inside)) return;

    # Trusted sources
    if (allow_trusted($si, 'any') && $avp(trustedTag) == $null) {
        xinfo("[$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (IP added in antiflood trusted IPs)\n");
        return;
    }
    # Allowed sources by DDI provider
    $var(group) = allow_source_address_group();
    if ($var(group) != -1) {
        xinfo("[$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (allowed source for ddiProviderId '$var(group)')\n");
        return;
    }

    # Evaluate PIKE
    if($sht(ipban=>$si) != $null) {
        # ip is already blocked
        xerr("[$dlg_var(cidhash)] ANTIFLOOD: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
        exit;
    }

    if (!pike_check_req()) {
        xerr("[$dlg_var(cidhash)] ANTIFLOOD: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
        $sht(ipban=>$si) = 1;
        exit;
    }
#!endif

    return;
}

# This route sets following dlg_vars: brandId, companyId, type
route[CLASSIFY] {
    if ($var(is_from_inside)) {
        $var(header) = 'X-Info-BrandId';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(brandId) = $var(header-value);

        $var(header) = 'X-Info-CompanyId';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(companyId) = $var(header-value);

        $var(header) = 'X-Info-Type';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(type) = $var(header-value);
    } else {
        sql_xquery("cb", "SELECT C.brandId, C.id AS companyId, C.type FROM DDIs D JOIN Companies C ON D.companyId=C.id WHERE DDIE164='$rU'", "rp");
        $dlg_var(brandId) = $xavp(rp=>brandId);
        $dlg_var(companyId) = $xavp(rp=>companyId);
        $dlg_var(type) = $xavp(rp=>type);

        if ($dlg_var(type) == 'wholesale') {
            xerr("[$dlg_var(cidhash)] CLASSIFY: Wholesale inbound call, 501\n");
            send_reply("501", "Not Implemented [WI]");
            exit;
        }
    }

    # Check type has one of the supported values
    if ($dlg_var(type) != 'vpbx' && $dlg_var(type) != 'residential' && $dlg_var(type) != 'wholesale' && $dlg_var(type) != 'retail') {
        xerr("[$dlg_var(cidhash)] CLASSIFY: Unsupported type '$dlg_var(type)'\n");
        send_reply("500", "Internal Server Error [UT]");
        exit;
    }

    if ($dlg_var(log)) xlog("L_INFO", "[$dlg_var(cidhash)] CLASSIFY: '$dlg_var(type)' call (b$dlg_var(brandId):c$dlg_var(companyId))");

}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    if ($var(is_from_inside)) {
        $dlg_var(direction) = 'outbound';
    } else {
        $dlg_var(direction) = 'inbound';
    }

    $dlg_var(callid) = $ci;
    $dlg_var(callee) = $rU;
    route(GET_CALLER);
    $dlg_var(caller) = $var(number);

    if (is_present_hf("Diversion"))
        $dlg_var(diversion) = $(di{uri.user});
}

route[SAVE_CONTACT] {
    if (!is_present_hf("Contact") || $dlg_var(contact) != $null) return;

    if ($ct =~ "<.*>") {
        # Contact has < >
        $var(contact) = $(ct{s.select,0,>});
        $var(contact) = $(var(contact){s.select,1,<});
    } else {
        $var(contact) = $ct;
    }

    $dlg_var(contact) = $var(contact);

    xwarn("[$dlg_var(cidhash)] MANAGE-REPLY: Save inside contact $dlg_var(contact)");
}

# Reply generic route (all replies goes through this route)
onreply_route {
    xnotice("[$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    route(IS_FROM_INSIDE);
}

# Common for both AS and GW replies
onreply_route[MANAGE_REPLY] {
    route(TRANSFORMATE_WITHINDLG);

    # Manage RTP
    route(RTPENGINE);

    if (t_check_status("2[0-9]{2}") && $var(is_from_inside)) {
        route(SAVE_CONTACT);
    }
}

# Manage failure replies (only for failure response codes, executed after previous 2 routes)

# Failure route for initial transactions to GW
failure_route[MANAGE_FAILURE_GW] {
    if(!t_check_status("(401)|(407)")) {
        xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    }

    route(IS_FROM_INSIDE);

    if (t_is_canceled()) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: t_is_canceled, exit here\n");
        exit;
    }

    if (t_check_status("(401)|(407)") && $avp(auth_done) != '1') {
        # Get ready for SIP auth
        #   username:  $avp(auth_user) set in SELECT-NEXT-GW
        #   password:  $avp(auth_secret) from DB below
        #   realm:     take it from 401/407 leaving it empty
        $avp(auth_realm) = '';

        # $avp(auth_secret) is available?
        if (is_avp_set("$avp(auth_secret)")) {
            # Sends INVITE with AUTH (and adapts CSeq)
            uac_auth();
            $avp(auth_done) = '1'; # Set avp to avoid using invalid credentials more than once

            # Restore rU as it will be transformed again
            $rU = $avp(ruri_user_avp);

            t_on_failure("MANAGE_FAILURE_GW");
            t_on_branch("MANAGE_BRANCH_GW");
            route(RELAY);
        } else {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: No secret available for $avp(newfrom), defunct_gw and try another one\n");
            defunct_gw(36000); # No credentials available, defunct gw 4ever and trigger alarm
        }
    } else if (t_check_status("(401)|(407)") && $avp(auth_done) == '1') {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Invalid credentials already used\n");
    } else if (t_check_status("480|486")) {
        xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Forward response downstream (reply code: $T_reply_code)\n");
        exit;
    } else if (t_check_status("422")) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Session Interval Too Small, forward to AS (reply code: $T_reply_code)\n");
        exit;
    } else if (t_check_status("408")) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code: Inactivate GW\n");
        inactivate_gw(); # Inactivate GW temporally (until it answers OPTIONS)
    } else if (t_check_status("3[0-9]{2}")) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code: Not allowed from GW\n");
    }

    xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Failure using carrier '$dlg_var(carrierId)' to place a call (reply code: $T_reply_code)\n");
    if ($dlg_var(cgrid) != $null) {
        route(CGR_CALL_FAILED);
    }

    xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Try next GW\n");
    route(SELECT_NEXT_GW);
    route(RELAY);
}

# Failure route for initial transactions to AS
failure_route[MANAGE_FAILURE_AS] {
    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(IS_FROM_INSIDE);

    if (t_is_canceled()) {
        xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    # Avoid failover for static distribute method
    if ($dlg_var(distributeMethod) == 'static') exit;

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS '$avp(AVP_DST)' as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
        } else {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Branch route for transactions to GW (transformate here so that eventual failure_route gets the unmodified message)
branch_route[MANAGE_BRANCH_GW] {
    route(GET_TRANSFORMATIONS_OUT);
    route(TRANSFORMATE_OUT);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    xnotice("[$dlg_var(cidhash)] $dlg_var(direction) call confirmed for company '$dlg_var(companyId)' [$ci]\n");

    if ($dlg_var(direction) == 'outbound') {
        if ($dlg_var(cgrid) == $null) {
            xinfo("[$dlg_var(cidhash)] No cgrid, skip rating logic");
            return;
        }
        route(CGR_CALL_START);
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    # Dialog end, print stats
    xinfo("[$dlg_var(cidhash)] $dlg_var(direction) call ended for company '$dlg_var(companyId)' [$ci]\n");
    if ($dlg_var(cgrid) == $null) {
        xinfo("[$dlg_var(cidhash)] No cgrid, skip rating logic");
        return;
    }
    route(CGR_CALL_END);
}

# Executed when dialog is not established
event_route[dialog:failed] {
    xwarn("[$dlg_var(cidhash)] $dlg_var(direction) call failed for company '$dlg_var(companyId)' [$ci]\n");
}

# Executed for request generated by Kamailio
event_route[tm:local-request] {
    xnotice("Kamailio generated request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");

    # CGrateS generated BYE
    if (is_method("BYE") && $var(Reason) != 0 && $var(Reason) == '"INSUFFICIENT_CREDIT"') {
        append_hf("Hint: credit expired\r\n");
    }

    # UACREG sends REGISTER requests whose Contact domain must be adapted
    if ($rm == "REGISTER") {
        subst_hf("Contact", "/reg_contact_addr/$sndfrom(ip):$sndfrom(port)/", "a");
    }
}

onsend_route {
    if (is_method("ACK")) $dlg_var(confirmed) = '1';

    #!ifdef DELAY_MEDIALIBERATION
    if (is_request() && is_method("INVITE") && $dlg_var(initial_reinvite) == 'yes') {
        xinfo("[$dlg_var(cidhash)] Initial reinvite from call initiated by AS, delay 1 second\n");
        sleep(1);
    }
    #!endif
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        xwarn("XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    xnotice("XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");
    route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    xinfo("GENERIC_XMLRPC_COMMAND: XMLRPC generic command from allowed IP ($si), dispatch!\n");

    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[GET_CODEC_INFO] {
    if ($dlg_var(type) != "retail" && $dlg_var(type) != "wholesale") return;

    sql_query("cb", "SELECT Co.iden AS codec FROM CompaniesRelCodecs CRC JOIN Codecs Co ON Co.id=CRC.codecId JOIN Companies C ON C.id=CRC.companyId WHERE companyId='$dlg_var(companyId)'", "rb");
    $dlg_var(codecs) = "";
    if ($dbr(rb=>rows) > 0) {
        $var(i) = 0;
        while($var(i) < $dbr(rb=>rows)) {
            $dlg_var(codecs) = $dlg_var(codecs) + "transcode-" + $dbr(rb=>[$var(i),0]) + " ";
            $var(i) = $var(i) + 1;
        }
    }
    sql_result_free("rb");
}

route[RTPENGINE] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;
    if (is_method("ACK") && !has_body("application/sdp")) return;
    if ($dlg_var(bounced) == '1') return;

    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        set_rtpengine_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    if ($dlg_var(type) == "retail") {
       xinfo("[$dlg_var(cidhash)] RTPENGINE: Do not trust SDP addresses on retail calls\n");
       $var(symmetry) = 'symmetric SIP-source-address';
    } else {
       $var(symmetry) = 'asymmetric trust-address';
    }

    $var(rtpengine_opts) = 'replace-session-connection replace-origin ICE=remove RTP/AVP';

    xinfo("[$dlg_var(cidhash)] RTPENGINE: rtpengine_manage [$var(rtpengine_opts) $var(symmetry) $dlg_var(codecs)]\n");
    rtpengine_manage("$var(rtpengine_opts) $var(symmetry) $dlg_var(codecs)");

    if ($avp(recordCall) == 'yes' && $dlg_var(recordingCall) != 'yes') {
        # First 200 OK to initial INVITE
        if (is_reply() && t_check_status("2[0-9]{2}")) {
            xinfo("[$dlg_var(cidhash)] RTPENGINE: Start recording this call ('$rs $rr' for initial $rm)\n");
            start_recording();
            $dlg_var(recordingCall) = 'yes'; # Save to avoid start_recording twice if retrans
        }
    }
}

route[CONTROL_MAXCALLS] {
    if (get_profile_size("activeCallsCompany", "$dlg_var(companyId)", "$avp(activeCallsCompany)")) {
        xinfo("[$dlg_var(cidhash)] CONTROL-MAXCALLS: company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany) calls\n");
    } else {
        xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany) calls (error obtaining value)\n");
        if ($dlg_var(maxCallsCompany) > 0) {
            xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Dropping call for security\n");
            send_reply("500", "Internal Server Error [MC]");
            exit;
        }
    }

    if (get_profile_size("activeCallsBrand", "$dlg_var(brandId)", "$avp(activeCallsBrand)")) {
        xinfo("[$dlg_var(cidhash)] CONTROL-MAXCALLS: brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand) calls\n");
    } else {
        xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand) calls (error obtaining value)\n");
        if ($dlg_var(maxCallsBrand) > 0) {
            xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Dropping call for security\n");
            send_reply("500", "Internal Server Error [MC]");
            exit;
        }
    }

    if ($dlg_var(maxCallsBrand) > 0 && $avp(activeCallsBrand) >= $dlg_var(maxCallsBrand)) {
        xwarn("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Call NOT allowed for brand$dlg_var(brandId), 403 Maxcalls exceeded\n");
        send_reply("403", "Maxcalls exceeded");
        exit;
    } else if ($dlg_var(maxCallsCompany) > 0 && $avp(activeCallsCompany) >= $dlg_var(maxCallsCompany)) {
        xwarn("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Call NOT allowed for company$dlg_var(companyId), 403 Maxcalls exceeded\n");
        send_reply("403", "Maxcalls exceeded");
        exit;
    } else {
         set_dlg_profile("activeCallsCompany", "$dlg_var(companyId)");
         set_dlg_profile("activeCallsBrand", "$dlg_var(brandId)");
    }
}

#################################################
# --- Kamailio-CGRateS related route blocks --- #
#################################################

# Detect presence of at least one connection with CGRates
event_route[evapi:connection-new] {
    $sht(cgrconn=>cgr) = $evapi(srcaddr) + ":" + $evapi(srcport);
    xnotice("Connection with CGrates established ($sht(cgrconn=>cgr))!!\n");
}

event_route[evapi:connection-closed] {
    xerr("Connection with CGrates closed!!\n");
    $sht(cgrconn=>cgr) = $null;
}

# Send AUTH_REQUEST to CGRateS
route[CGRATES_AUTH_REQUEST] {
    # Auth INVITEs with CGRateS
    if $sht(cgrconn=>cgr) == $null {
        xerr("[$dlg_var(cidhash)] CGRATES-AUTH-REQUEST: Charging controller unreachable");
        send_reply("503","Charging controller unreachable");
        exit;
    }

    $dlg_var(cgrTenant) = 'b' + $dlg_var(brandId);
    $dlg_var(cgrAccount) = 'c' + $dlg_var(companyId);
    $dlg_var(cgrSubject) = 'c' + $dlg_var(companyId);
    if ($dlg_var(routingTagId) != $null) {
        $dlg_var(cgrSubject) = $dlg_var(cgrSubject) + 'rt' + $dlg_var(routingTagId);
    }
    if ($dlg_var(cgrDestination) == $null) $dlg_var(cgrDestination) = $rU;
    $dlg_var(setupTime) = $TS;

    xinfo("[$dlg_var(cidhash)] CGRATES-AUTH-REQUEST: Ask CGRates whether call is granted ($dlg_var(cgrTenant):$dlg_var(cgrSubject):$dlg_var(cgrDestination):$dlg_var(cgrReqType))");

    evapi_async_relay("{\"event\":\"CGR_AUTH_REQUEST\",
            \"callid\":\"$dlg(callid)\",
            \"from_tag\":\"$dlg(from_tag)\",
            \"tr_index\":\"$T(id_index)\",
            \"tr_label\":\"$T(id_label)\",
            \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
            \"cgr_account\":\"$dlg_var(cgrAccount)\",
            \"cgr_subject\":\"$dlg_var(cgrSubject)\",
            \"cgr_reqtype\":\"$dlg_var(cgrReqType)\",
            \"carrierReqtype\":\"*rated\",
            \"cgr_destination\":\"$dlg_var(cgrDestination)\",
            \"cgr_setuptime\":\"$dlg_var(setupTime)\"}");

    # Do not continue route script, transaction will be processed when API answers
    exit;
}

event_route[evapi:message-received] {
    json_get_field("$evapi(msg)", "Event", "$var(Event)");
    route($(var(Event){s.rm,"})); # String characters are kept by json_get_field, remove them here
    # Message received from CGrates, continue in CGR_AUTH_REPLY
}

route[CGR_AUTH_REPLY] {
    json_get_field("$evapi(msg)", "TransactionIndex", "$var(TransactionIndex)");
    json_get_field("$evapi(msg)", "TransactionLabel", "$var(TransactionLabel)");
    json_get_field("$evapi(msg)", "MaxSessionTime", "$var(MaxSessionTime)");
    json_get_field("$evapi(msg)", "Suppliers", "$var(Suppliers)");
    json_get_field("$evapi(msg)", "ResourceAllowed", "$var(CGRResourceAllowed)");
    json_get_field("$evapi(msg)", "CgrId", "$var(cgrid)");
    json_get_field("$evapi(msg)", "Error", "$var(CgrError)");
    $var(id_index) = $(var(TransactionIndex){s.int});
    $var(id_label) = $(var(TransactionLabel){s.int});
    $var(CgrMaxSessionTime) = $(var(MaxSessionTime){s.int});
    $var(CgrSuppliers) = $(var(Suppliers){s.rm,"});
    $var(CGRResourceAllowed) = $(var(CGRResourceAllowed){s.rm,"});
    $var(CgrError) = $(var(CgrError){s.rm,"});

    # API response parsed, continue processing transaction in CGRATES_AUTH_REPLY
    t_continue("$var(id_index)", "$var(id_label)", "CGRATES_AUTH_REPLY"); # Unpark the transaction
}

route[CGRATES_AUTH_REPLY] {
    route(IS_FROM_INSIDE);

    # Save cgrid in acc cdrs
    $dlg_var(cgridPersist) = $(var(cgrid){s.rm,"});
    $dlg_var(CgrMaxSessionTime) = $var(CgrMaxSessionTime);

    if ($var(CgrError) != "") {
        xerr("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: $var(CgrError)");
        $dlg_var(cgrDeclined) = "yes";
    } else if ($var(CGRResourceAllowed) == "false") {
        xerr("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Resource not allowed");
        $dlg_var(cgrDeclined) = "yes";
    } else if ($var(CgrMaxSessionTime) == 0) {
        xwarn("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Insufficient credit");
        $dlg_var(cgrDeclined) = "yes";
    } else {
        xinfo("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Max-session-time: $var(CgrMaxSessionTime)");
    }

    route(SELECT_NEXT_GW);
    route(RELAY);
}

# Inform CGRateS about CALL_START (start prepaid sessions loops)
route[CGR_CALL_START] {
    if $sht(cgrconn=>cgr) == $null {
        xerr("[$dlg_var(cidhash)] CGR-CALL-START: Charging controller unreachable");
        send_reply("503","Charging controller unreachable");
        exit;
    }

    xnotice("[$dlg_var(cidhash)] CGR-CALL-START: Warn CGRates that call is started");

    evapi_relay("{\"event\":\"CGR_CALL_START\",
               \"callid\":\"$dlg(callid)\",
               \"from_tag\":\"$dlg(from_tag)\",
               \"h_entry\":\"$dlg(h_entry)\",
               \"h_id\":\"$dlg(h_id)\",
               \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
               \"cgr_account\":\"$dlg_var(cgrAccount)\",
               \"cgr_subject\":\"$dlg_var(cgrSubject)\",
               \"cgr_destination\":\"$dlg_var(cgrDestination)\",
               \"cgr_setuptime\":\"$dlg_var(setupTime)\",
               \"cgr_reqtype\":\"$dlg_var(cgrReqType)\",
               \"cgr_answertime\":\"$TS\"}");
}

# Inform CGRateS about CALL_END (stop debit loops, perform accounting if desired in this way)
route[CGR_CALL_END] {
    if $sht(cgrconn=>cgr) == $null {
        xerr("[$dlg_var(cidhash)] CGR-CALL-END: Charging controller unreachable");
        exit;
    }

    $var(callDur) = $TS - $dlg(start_ts);
    $var(cgrCarrier) = 'cr' + $dlg_var(carrierId);

    if ($dlg_var(calculateCost) == '1') {
        $var(cgrDerivedReqType) = '*postpaid';
    } else {
        $var(cgrDerivedReqType) = '*rated';
    }

    xnotice("[$dlg_var(cidhash)] CGR-CALL-END: Warn CGRates that call has ended (duration: $var(callDur))");

    evapi_relay("{\"event\":\"CGR_CALL_END\",
        \"callid\":\"$dlg(callid)\",
        \"from_tag\":\"$dlg(from_tag)\",
        \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
        \"cgr_account\":\"$dlg_var(cgrAccount)\",
        \"cgr_subject\":\"$dlg_var(cgrSubject)\",
        \"cgr_destination\":\"$dlg_var(cgrDestination)\",
        \"cgr_answertime\":\"$dlg(start_ts)\",
        \"cgr_setuptime\":\"$dlg_var(setupTime)\",
        \"cgr_duration\":\"$var(callDur)\",
        \"cgr_reqtype\":\"$dlg_var(cgrReqType)\",
        \"carrierId\":\"$var(cgrCarrier)\",
        \"carrierReqtype\":\"$var(cgrDerivedReqType)\",
        \"cgr_disconnectcause\":\"$T_reply_code\"}");
}

# Inform CGRateS about a failed call establishment
route[CGR_CALL_FAILED] {
    if $sht(cgrconn=>cgr) == $null {
        xerr("[$dlg_var(cidhash)] CGR-CALL-FAILED: Charging controller unreachable");
        exit;
    }

    $var(cgrCarrier) = 'cr' + $dlg_var(carrierId);

    if ($dlg_var(calculateCost) == '1') {
        $var(cgrDerivedReqType) = '*postpaid';
    } else {
        $var(cgrDerivedReqType) = '*rated';
    }

    xinfo("[$dlg_var(cidhash)] CGR-CALL-FAILED: Warn CGRates that call has failed (carrierId: $dlg_var(carrierId))");
    $var(from_tag) = $dlg(from_tag) + ";failure_" + $TS;

    evapi_relay("{\"event\":\"CGR_CALL_END\",
        \"callid\":\"$dlg(callid)\",
        \"from_tag\":\"$var(from_tag)\",
        \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
        \"cgr_account\":\"$dlg_var(cgrAccount)\",
        \"cgr_subject\":\"$dlg_var(cgrSubject)\",
        \"cgr_destination\":\"$dlg_var(cgrDestination)\",
        \"cgr_answertime\":\"$dlg_var(setupTime)\",
        \"cgr_duration\":\"0\",
        \"cgr_reqtype\":\"$dlg_var(cgrReqType)\",
        \"carrierId\":\"$var(cgrCarrier)\",
        \"carrierReqtype\":\"$var(cgrDerivedReqType)\",
        \"cgr_disconnectcause\":\"$T_reply_code\"}");
}

# CGRateS request for session disconnect
route[CGR_SESSION_DISCONNECT] {
    json_get_field("$evapi(msg)", "HashEntry", "$var(HashEntry)");
    json_get_field("$evapi(msg)", "HashId", "$var(HashId)");
    json_get_field("$evapi(msg)", "Reason", "$var(Reason)");
    xwarn("CGR_SESSION_DISCONNECT: CGRates disconnects the call ($var(Reason))");
    jsonrpc_exec('{"jsonrpc":"2.0","id":1, "method":"dlg.end_dlg","params":[$(var(HashEntry){s.rm,"}),$(var(HashId){s.rm,"})]}');
    xinfo("CGR_SESSION_DISCONNECT: Response: '$jsonrpl(code) $jsonrpl(text) $jsonrpl(body)'");
}

event_route[htable:mod-init] {
    if (dns_query("users.ivozprovider.local", "kamusers")) {
        $var(usersAddress) = $dns(kamusers=>addr);
        xinfo("users.ivozprovider.local: $var(usersAddress)\n");
    } else {
        xerr("Problems resolving users.ivozprovider.local, aborting\n");
        abort();
    }
}
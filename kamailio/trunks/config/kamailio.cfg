#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define SIP_PORT 7060
#!define SIPS_PORT 7061
#!define XMLRPC_PORT 8001

# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# ACC Flags
#!define FLT_ACC 1
#!define FLT_ACCFAILED 2

# DLG_FLAG
#!define DLG_FLAG 3

# RELATED Flag (when set, aleg found for this call in this proxy)
#!define FLT_ISBLEG 4

# - options

#!define WITH_ANTIFLOOD

#!define DELAY_MEDIALIBERATION
# Note: If defined, Kamailio delays Asterisk initial media liberation for 1 second (only on outbound calls)

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

####### Global Parameters #########

listen=udp:IP:SIP_PORT
listen=tcp:IP:SIP_PORT
listen=tls:IP:SIPS_PORT
listen=tcp:IP:XMLRPC_PORT

# -- Debug level
# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# If debug level of message is lower than current debug parameter, it gets printed
# Current value: 2 (INFO and higher)
#
# This setting can me modified/seen live running:
# kamcmd-proxyusers cfg.seti core debug X
# kamcmd-proxyusers cfg.get core debug

debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes
version_table="kam_version"

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec Ivoz Provider v1.0"
user_agent_header="User-Agent: Irontec Ivoz Provider v1.0"

####### Runtime cfg values (kamcmd cfg.list) #########

# Log dialogs initiated by these SIP methods
dolog.invite    = 1 desc "If 1, log invite transactions"
dolog.register  = 1 desc "If 1, log register transactions"
dolog.publish   = 1 desc "If 1, log publish transactions"
dolog.subscribe = 1 desc "If 1, log subscribe transactions"
dolog.notify    = 1 desc "If 1, log notify transactions"
dolog.options   = 1 desc "If 1, log options transactions"
dolog.message   = 1 desc "If 1, log message transactions"
dolog.refer     = 1 desc "If 1, log refer transactions"

# Debug
dolog.xmlrpc    = 0 desc "If 1, debug XMLRPC"
dolog.printmsg_methods = 'NONE' desc "Print full SIP messages with these methods" # e.g. 'INVITE|REGISTER', 'NONE' to disable

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "mi_fifo.so"
loadmodule    "mi_rpc.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "sqlops.so"
loadmodule    "rtpproxy.so"
loadmodule    "cfg_rpc.so"
loadmodule    "dialog.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "acc.so"
loadmodule    "lcr.so"
loadmodule    "uac.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "xhttp.so"
loadmodule    "domain.so"
loadmodule    "cfgutils.so"
loadmodule    "dialplan.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "permissions.so"
loadmodule    "diversion.so"
loadmodule    "evapi.so"
loadmodule    "json.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_DSSOCKET)")
modparam("dispatcher", "attrs_avp", "$avp(DSATTRS)")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 2)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@trunks.ivozprovider.local")
modparam("dispatcher", "hash_pvar", "$avp(hash)")

# TLS
modparam("tls", "config", "/etc/kamailio/proxytrunks/tls.cfg")
modparam("tls", "tls_log", 1)

# MI_FIFO
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_proxytrunks_fifo")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxytrunks_ctl")

# RTPPROXY
modparam("rtpproxy", "db_url", DBURL)
modparam("rtpproxy", "table_name", "kam_rtpproxy")
modparam("rtpproxy", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpproxy", "nortpproxy_str", "a=sdpmangled:yes\r\n")

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# ACC
# -- transactions to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- cdr accounting to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 0)
modparam("acc", "cdrs_table", "kam_trunks_cdrs")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);peeringContractId=$dlg_var(peeringContractId);referrer=$dlg_var(referrer);direction=$dlg_var(direction);bounced=$dlg_var(bounced);cgrid=$dlg_var(cgrid)")
modparam("acc", "cdr_extra_nullable", 1)

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "activeCalls; inboundCalls; outboundCalls")
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n") # Added to requests generated locally by the module (e.g. BYE)
modparam("dialog", "track_cseq_updates", 1)

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif
modparam("htable", "htable", "cgrconn=>size=1;")

# UAC
modparam("uac", "auth_realm_avp","$avp(realm)")
modparam("uac", "auth_username_avp","$avp(provideruser)")
modparam("uac", "auth_password_avp","$avp(secret)")
modparam("uac", "restore_mode","auto")
modparam("uac", "restore_dlg", 1)
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_db_table", "kam_trunks_uacreg")
modparam("uac", "reg_contact_addr", "reg_contact_addr")
modparam("uac", "reg_timer_interval", 60)
modparam("uac", "reg_retry_interval", 300)

# LCR
modparam("lcr", "db_url", DBURL)
modparam("lcr", "lcr_gw_table","LcrGateways")
modparam("lcr", "lcr_rule_table", "LcrRules")
modparam("lcr", "lcr_rule_target_table", "LcrRuleTargets")
modparam("lcr", "gw_name_column", "gw_name")
modparam("lcr", "ip_addr_column", "ip")
modparam("lcr", "lcr_id_column", "lcr_id")
modparam("lcr", "gw_uri_avp", "$avp(gw_uri_avp)")
modparam("lcr", "ruri_user_avp", "$avp(i:500)")
modparam("lcr", "tag_avp", "$avp(lcr_tag)")
modparam("lcr", "flags_avp", "$avp(s:caller_method)")
modparam("lcr", "defunct_capability", 1)
modparam("lcr", "lcr_id_avp", "$avp(lcr_id_avp)")
modparam("lcr", "defunct_gw_avp", "$avp(defunct_gw_avp)")
modparam("lcr", "lcr_rule_hash_size", 1024)
modparam("lcr", "lcr_gw_count", 1024)
modparam("lcr", "fetch_rows", 3000)
modparam("lcr", "ping_interval", 15) # Ping every 15 seconds
modparam("lcr", "ping_inactivate_threshold", 1) # Mark as inactive at first call of inactivate_gw()
modparam("lcr", "ping_valid_reply_codes", "403,404,405,501") # Mark as active when 2XX or these reply codes
modparam("lcr", "ping_from", "sip:pinger@localhost")
modparam("lcr", "lcr_count", 1)
modparam("lcr", "dont_strip_or_prefix_flag", 1)

# TM
modparam("tm", "fr_timer", 5000)
modparam("tm", "retr_timer1", 500)

# SANITY
modparam("sanity", "autodrop", 0)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_trunks_domain")
modparam("domain", "domain_attrs_table", "kam_trunks_domain_attrs")
modparam("domain", "register_myself", 1)

# DIALPLAN
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "table_name", "kam_dialplan")
modparam("dialplan", "attrs_pvar", "$avp(s:appliedrule)")

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_trunks_address") # Not used
modparam("permissions", "trusted_table", "kam_pike_trusted") # IPs excluded from pike checking
modparam("permissions", "db_mode", 1)

####### Routing Logic ########

request_route {
    # per request initial checks
    route(REQINIT);

    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($si:$sp) [$proto]\n");

    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) xlog("L_WARN", "Received message:\n\n$mb\n");

    if (is_method("OPTIONS")) {
        if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Send 200 to '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");
        force_rport();
        send_reply("200", "I'm here!");
        exit;
    }

    route(ANTIFLOOD);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si\n");

        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RELAY);
        }

        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] In dialog request - has_to_tag\n");
        route(WITHINDLG);
    }

    ### only initial requests (no To tag)

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NOT in dialog request - not has_to_tag: Initial transaction\n");

    # Manage retransmissions
    t_check_trans();

    # Only INVITE can start a dialog
    if (!is_method("INVITE")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Remove preloaded route headers
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Remove preloaded route headers\n");
    remove_hf("Route");

    # Manage dialog
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] dialog_manage()\n");
    dlg_manage();

    # Reconfigure XLOG for second calls to dlg_manage (dlg_vars are lost). Currently only after 422.
    route(CONFIGURE_XLOG);

    # Setup accounting
    route(ACCOUNTING);

    # Add record-route to INVITE requests
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Add record-route\n");
    record_route();

    # Is a call bounced previously to AS?
    $var(header) = 'X-Info-Bounced';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) == 'yes') {
        $dlg_var(bounced) = '1';
    }


    # Easy routing:
    # (a) From ASs ----> Choose GW (except bounced calls)
    # (b) To my domains ----> Dispatch to AS
    if (ds_is_from_list("1") && $dlg_var(bounced) == $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Source: Known AS, route to corresponding GW\n");
        $dlg_var(direction) = 'outbound';

        # AS provides needed info in X-INFO header
        route(PARSE_X_HEADERS);
        route(CONTROL_EXTERNAL_MAXCALLS);
        route(PROFILE_OUTBOUND_CALL);

        #!ifdef DELAY_MEDIALIBERATION
        $dlg_var(initial_reinvite) = 'pending';
        #!endif

        # Evaluate routing logic
        route(LOAD_GWS);

        # -- is our DDI??
        $var(header) = 'X-Info-BounceMe';
        route(PARSE_OPTIONAL_X_HEADER);
        if ($var(header-value) == 'yes') {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] This is our DDI, forward to AS for new CID\n");
            insert_hf("X-Info-BounceDDI: $rU\r\n");
            $dlg_var(cgrDestination) = $rU; # Save value just in case it is needed later
            $avp(distributeMethod) = 'static'; # Bounce to same AS
            $avp(asAddress) = $si; # Bounce to same AS
            $rU = 'bounce';
            route(DISPATCH);
            $dlg_var(peeringContractId) = $avp(peeringContractId);
            $dlg_var(bounced) = '1';
        }

        # Evaluate rating logic
        if ($avp(externallyRated) == '1') {
            xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Externally rating is enabled for this PeeringContract, proceed");
            route(RELAY);
        } else {
            route(CGRATES_AUTH_REQUEST);
        }
    } else {
        if (uri==myself) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Someone talking to one of my domains, proceed\n");
            $dlg_var(direction) = 'inbound';

            # X-HEADERS are for internal use only, they shouldn't be added by trunks
            remove_hf_re("^X-");

            route(TRANSFORMATE_IN);
            route(GET_INFO_FROM_MATCHED_DDI);
            route(CONTROL_EXTERNAL_MAXCALLS);
            route(PROFILE_INBOUND_CALL);

            route(DISPATCH);
            route(RELAY);
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rd is not one of my domains, 404 Not Here\n");
            send_reply("404", "Not Here");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Main script error, should NOT arrive this point.\n");
    drop;
}

route[REQINIT] {
    # Easy dropping for scanners
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent" || search("sipvicious")) {
        xlog("L_WARN", "REQINIT: Dropping scanner request ----> $rm from $si\n");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        xlog("L_ERR", "REQINIT: Dropping malformed SIP message from $si:$sp\n");
        exit;
    }

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        xlog("L_ERR", "REQINIT: Too many hops for SIP message from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    xlog("L_INFO", "REQINIT: All checks passed, continue...\n");
}

route[LOAD_GWS] {
    $var(filter) = 'b' + $dlg_var(brandId) + 'c' + $dlg_var(companyId);
    if ($avp(fax)) {
        load_gws(1, 'fax', $var(filter));
        if ($avp(gw_uri_avp) == $null) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOAD-GWS: No fax specific route found, use general logic\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOAD-GWS: Fax specific route found\n");
        }
    }

    if ($avp(gw_uri_avp) == $null) {
        load_gws(1, $rU, $var(filter));
    }

    if ($avp(gw_uri_avp) != $null) {
        # At least one gateway loaded, continue
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOAD-GWS: Gateways loaded, proceed!\n");

        # Store original ru value to reuse in SELECT-GW invocations
        $dlg_var(ru_before_lcr) = $ru;

        route(SELECT_GW);
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOAD-GWS: No valid gateway for '$rU' for company with id '$dlg_var(companyId)'\n");
        send_reply("500", "Server Internal Error - No gateways");
        exit;
    }

    t_on_failure("MANAGE_FAILURE_GW");
    t_on_branch("MANAGE_BRANCH_GW");
}

route[SELECT_GW] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Reset du and ru to values of FIRSTGW call\n");
    $ru = $dlg_var(ru_before_lcr);
    $du = $null;

    # GW selection modifies both $ru and $du
    # -- before --
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Before: Dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Before: RURI $ru\n");

    # Evaluate gateway rules
    if (!next_gw()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: NO next GW, send 503 No gateways");
        send_reply("503", "No gateways");
        exit;
    }

    # -- after --
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: After: Dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: After: RURI $ru\n");

    # Store du and ru after choosing GW to reuse in case of 401|407 (to preserve gw prefix and suffix)
    $avp(du_after_lcr) = $du;
    $avp(ru_after_lcr) = $ru;

    # Obtain info about selected GW
    sql_xquery("cb", "SELECT PC.externallyRated, PS.auth_needed, PS.auth_user, PS.auth_password, PS.peeringContractId, PS.from_user, PS.from_domain, PS.prefix FROM PeerServers PS JOIN PeeringContracts PC ON PS.peeringContractId=PC.id WHERE PS.id=$avp(lcr_tag)", "ra");

    if ( $(xavp(ra=>peeringContractId){s.len}) ) {
        $avp(peeringContractId) = $xavp(ra=>peeringContractId);
        $avp(externallyRated) = $xavp(ra=>externallyRated);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: peeringContractId: $avp(peeringContractId)\n");
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: externallyRated: $avp(externallyRated)\n");
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Error obtaining 'peeringContractId' for peerServerId '$avp(lcr_tag)'\n");
        send_reply("500", "Server Internal Error");
        exit;
    }

    if ($xavp(ra=>auth_needed) == 'yes') {
        if ( $(xavp(ra=>auth_user){s.len}) ) {
            $avp(provideruser) = $xavp(ra=>auth_user);
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: provideruser: $avp(provideruser)\n");
        } else {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Error obtaining 'provideruser' for peerServerId '$avp(lcr_tag)'\n");
        }

        if ( $(xavp(ra=>auth_password){s.len}) ) {
            $avp(secret) = $xavp(ra=>auth_password);
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: secret: xxxxxxxxx\n");
        } else {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Error obtaining 'secret' for peerServerId '$avp(lcr_tag)'\n");
        }
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: No auth needed\n");
        $avp(provideruser) = $null;
        $avp(secret) = $null;
    }

    if ( $(xavp(ra=>from_user){s.len}) ) {
        $avp(from_user) = $xavp(ra=>from_user);
    } else {
        $avp(from_user) = $null;
    }
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: from_user: $avp(from_user)\n");

    if ( $(xavp(ra=>from_domain){s.len}) ) {
        $avp(from_domain) = $xavp(ra=>from_domain);
    } else {
        $avp(from_domain) = $null;
    }
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: from_domain: $avp(from_domain)\n");

    if ( $(xavp(ra=>prefix){s.len}) ) {
        $avp(gw_prefix) = $xavp(ra=>prefix);
    } else {
        $avp(gw_prefix) = $null;
    }
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: gw_prefix: $avp(gw_prefix)\n");

    # Reset auth flag
    $avp(auth_done) = '0';
}

route[PARSE_X_HEADERS] {
    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(xcallid) = $var(header-value);

    # -- xcallid is mandatory for every normal call.
    #    Check if X-Info-Special header is present with 'fax' value (current only exception)
    if ($(dlg_var(xcallid){s.len}) == 0) {
        $var(header) = 'X-Info-Special';
        route(PARSE_OPTIONAL_X_HEADER);
        if ($var(header-value) == 'fax') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-X-HEADERS: Special case without xcallid: fax\n");
            $avp(fax) = '1';
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-X-HEADERS: Invalid $var(header) value ($var(header-value)) for call without xcallid\n");
            send_reply("500", "x-callid is missing");
            exit;
        }
    } else {
        if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-X-HEADERS: Related leg: $dlg_var(xcallid)\n");
    }

    # Extract brandId
    $var(header) = 'X-Info-BrandId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(brandId) = $var(header-value);

    # Extract companyId
    $var(header) = 'X-Info-CompanyId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyId) = $var(header-value);

    # Extract companyName
    $var(header) = 'X-Info-CompanyName';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyName) = $var(header-value);

    # Extract companyDomain
    $var(header) = 'X-Info-CompanyDomain';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyDomain) = $var(header-value);

    # Extract MediaRelaySet (can be null and non-exist)
    $var(header) = 'X-Info-MediaRelaySet';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(mediaRelaySetsId) = $var(header-value);

    # Extract externalMaxCalls
    $var(header) = 'X-Info-MaxCalls';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(externalMaxCalls) = $var(header-value);

    # Extract Record header
    $var(header) = 'X-Info-Record';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) == 'yes') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-X-HEADERS: '$var(header)' header found, call will be recorded\n");
        $avp(recordCall) = 'yes';
    }
}

# Header might not be present and, if present, might be empty
route[PARSE_OPTIONAL_X_HEADER] {
    if (is_present_hf($var(header))) {
        if ($(hdr($var(header)){s.len})) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header): $hdr($var(header))\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header): <empty>\n");
        }
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header) not present\n");
        $var(header-value) = '';
    }
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header): $hdr($var(header))\n");
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[PROFILE_OUTBOUND_CALL] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-OUTBOUND-CALL: Type-> outbound\n");
    $dlg_var(profile) = "Outbound call";
    set_dlg_profile("outboundCalls", "$dlg_var(companyId)");
}

route[PROFILE_INBOUND_CALL] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-INBOUND-CALL: Type-> inbound\n");
    $dlg_var(profile) = "Inbound call";
    set_dlg_profile("inboundCalls", "$dlg_var(companyId)");
}

route[PRINT_STATS] {
    # Global stats
    if(get_profile_size("activeCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) active calls\n");
    }

    if(get_profile_size("inboundCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) inbound calls\n");
    }

    if(get_profile_size("outboundCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) outbound calls\n");
    }

    # Company stats
    if(get_profile_size("activeCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) active calls\n");
    }

    if(get_profile_size("inboundCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) inbound calls\n");
    }

    if(get_profile_size("outboundCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) outbound calls\n");
    }
}

route[TRANSFORMATE_IN] {
    if ($dlg_var(bounced) == '1') {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: Skipping transformations for bounced calls, AS talk E.164\n");
        return;
    }

    # Get all DDI candidates
    sql_query("cb", "SELECT P.brandId, D.DDIE164, CONCAT(P.transformationRuleSetId, 1) AS callee_in, CONCAT(P.transformationRuleSetId, 0) AS caller_in, CONCAT(P.transformationRuleSetId, 1) AS caller_out FROM DDIs D INNER JOIN PeeringContracts P ON D.peeringContractId = P.id WHERE '$rU' REGEXP CONCAT('[0-9]*', DDI) ORDER BY LENGTH(DDIE164) DESC", "ra");

    # Are there any candidates?
    if ($dbr(ra=>rows) == 0) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: $rU not recognized in any company, 404 Not Found\n");
        send_reply("404", "Not Here");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: There are $dbr(ra=>rows) DDI candidates, proceed\n");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: Initial callee -> $rU\n");

    # Evaluate all candidates ($rU after transformation must be equal to candidate, otherwise it is rejected)
    $var(i) = 0;
    while ($var(i)<$dbr(ra=>rows)) {
        $dlg_var(brandId) = $dbr(ra=>[$var(i), 0]); # If not set in CONFIGURE_XLOG, brandId is set here
        $var(candidate) = $dbr(ra=>[$var(i), 1]);
        $var(transformation) = $dbr(ra=>[$var(i), 2]);
        $var(number) = $rU;
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        if ($var(transformated) == $var(candidate)) {
            # We have a winner candidate!!
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: Callee $rU is recognized as $var(candidate)\n");
            $rU = $var(candidate);
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: Final callee -> $rU (should be E164)\n");
            $dlg_var(callee) = $rU;

            # Transformate caller with corresponding transformation
            $dlg_var(caller_in) = $dbr(ra=>[$var(i), 3]);
            $dlg_var(caller_out) = $dbr(ra=>[$var(i), 4]);
            $var(transformation) = $dlg_var(caller_in);
            route(ADAPT_CALLER);
            route(SET_CALLER); # Sets caller using $var(caller) value
            $dlg_var(caller) = $var(caller);

            # Apply the same transformation to first Diversion header
            if (is_present_hf("Diversion")) {
                $var(number) = $(di{uri.user});
                if ($var(number) != $null) {
                    $avp(reason) = @hf_value.diversion[0].param['reason'];
                    if ($avp(reason) == $null) {
                        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: No reason extracted, set 'deflection'\n");
                        $avp(reason) = 'deflection';
                    }

                    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: Initial diversion -> $var(number)\n");
                    $var(transformation) = $dlg_var(caller_in);
                    route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
                    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: Final diversion -> $var(transformated)\n");

                    remove_hf_value("Diversion[0]");
                    add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $(di{uri.host}));
                }
            }
            # Free and leave
            sql_result_free("ra");
            return;
        }
        $var(i) = $var(i) + 1;
    }
    sql_result_free("ra");

    # No candidate succeeded after applying transformations
    if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: No DDI candidate succeeded after applying transformations to $rU, 404 Not Found");
    send_reply("404", "Not Here");
    exit;
}

# Sets caller in $var(caller) seeking in PAI/RPID/From (in this order)
route[GET_CALLER] {
    # Where is my caller? PAI/RPID/From?
    if (is_present_hf("P-Asserted-Identity")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-CALLER: PAI present: $(ai{uri.user})\n");
        $var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-CALLER: RPID present: $(re{uri.user})\n");
        $var(caller) = $(re{uri.user});
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-CALLER: Nor PAI nor RPID present, only From ($fU)! :(\n");
        $var(caller) = $fU;
    }
}

# Sets caller in PAI/RPID/From using $var(caller) value
route[SET_CALLER] {
    # Set final caller in corresponding header
    if (is_present_hf("P-Asserted-Identity")) {
        remove_hf("Remote-Party-ID"); # If PAI present, RPID out
        if ($(ai{uri.user}) != $var(caller)) { # If new value differs from previous, change
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SET-CALLER: Changing PAI to $var(caller)\n");
            remove_hf("P-Asserted-Identity");
            append_hf("P-Asserted-Identity: <sip:$var(caller)@$(ai{uri.host})>\r\n");
        }
    } else if (is_present_hf("Remote-Party-ID") && $(re{uri.user}) != $var(caller)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SET-CALLER: Changing RPID to $var(caller)\n");
        remove_hf("Remote-Party-ID");
        append_hf("Remote-Party-ID: <sip:$var(caller)@$(re{uri.host})>\r\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SET-CALLER: Changing From to $var(caller)\n");
        $fU = $var(caller);
        $fn = $var(caller);
    }
}

# Sets $var(callee) and $var(caller)
route[TRANSFORMATE_OUT] {
    sql_xquery("cb", "SELECT CONCAT(transformationRuleSetId, 2) AS caller_out, CONCAT(transformationRuleSetId, 3) AS callee_out, CONCAT(transformationRuleSetId, 0) AS caller_in FROM PeeringContracts WHERE id=$avp(peeringContractId)", "ra");

    # Transformate caller_out (set result in $var(caller))
    $dlg_var(caller_out) = $xavp(ra=>caller_out);
    $dlg_var(caller_in) = $xavp(ra=>caller_in);
    $var(transformation) = $dlg_var(caller_out);
    route(ADAPT_CALLER);

    # Apply the same transformation to first Diversion header
    if (is_present_hf("Diversion")) {
        $var(number) = $(di{uri.user});
        if ($var(number) != $null) {
            $avp(reason) = @hf_value.diversion[0].param['reason'];
            if ($avp(reason) == $null) {
                if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: No reason extracted, set 'deflection'\n");
                $avp(reason) = 'deflection';
            }

            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: Initial diversion -> $var(number)\n");
            $var(transformation) = $dlg_var(caller_out);
            route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: Final diversion -> $var(transformated)\n");

            remove_hf_value("Diversion[0]");
            add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $dlg_var(companyDomain));
        }
    }

    # Transformate callee_out
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-OUT: Initial callee -> $rU\n");
    $var(transformation) = $xavp(ra=>callee_out);
    $var(number) = $rU;
    route(APPLY_TRANSFORMATION);
    $var(callee) = $var(transformated);
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-OUT: Final callee -> $var(callee)\n");
}

# Apply $var(transformation) transformations (if set) to $var(number)
# Sets result in $var(transformated)
route[APPLY_TRANSFORMATION] {
    $var(transformated) = $var(number);

    if ($var(transformation) == $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] APPLY-TRANSFORMATION: No rule applied, return\n");
        return;
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] APPLY-TRANSFORMATION: Number before transformation rule ($var(transformation)): $var(number)\n");
    $avp(appliedrule) = $null;
    dp_translate("$(var(transformation){s.int})", "$var(number)/$var(transformated)");

    # If no rule applied, re-set value
    if ($avp(appliedrule) == $null)
        $var(transformated) = $var(number);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] APPLY-TRANSFORMATION: Number after: $var(transformated) (applied rule: $avp(appliedrule))\n");
}

route[GET_INFO_FROM_MATCHED_DDI] {
    sql_xquery("cb", "SELECT d.DDIE164 AS DDI, d.billInboundCalls, d.peeringContractId, c.name AS companyName, c.id AS companyId, c.mediaRelaySetsId, c.brandId AS brandId, c.externalMaxCalls, d.routeType, d.recordCalls, c.distributeMethod, AppS.ip AS asAddress FROM DDIs d JOIN Companies c ON d.companyId=c.id LEFT JOIN ApplicationServers AppS ON AppS.id=c.applicationServerId WHERE d.DDIE164='$rU'", "ra");

    # Matched DDI
    $dlg_var(DDI) = $xavp(ra=>DDI);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: brandId: $xavp(ra=>brandId)\n");
    $dlg_var(brandId) = $xavp(ra=>brandId);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: companyId: $xavp(ra=>companyId)\n");
    $dlg_var(companyId) = $xavp(ra=>companyId);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: companyName: $xavp(ra=>companyName)\n");
    $dlg_var(companyName) = $xavp(ra=>companyName);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: externalMaxCalls: $xavp(ra=>externalMaxCalls)\n");
    $dlg_var(externalMaxCalls) = $xavp(ra=>externalMaxCalls);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: billInboundCalls: $xavp(ra=>billInboundCalls)\n");
    $dlg_var(billInboundCalls) = $xavp(ra=>billInboundCalls);

    if ($dlg_var(billInboundCalls)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: peeringContractId: $xavp(ra=>peeringContractId)\n");
        $dlg_var(peeringContractId) = $xavp(ra=>peeringContractId);
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: peeringContractId: $xavp(ra=>peeringContractId) - Not set\n");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: recordCalls: $xavp(ra=>recordCalls)\n");
    if ($xavp(ra=>recordCalls) == 'inbound' || $xavp(ra=>recordCalls) == 'all') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: Call will be recorded\n");
        $avp(recordCall) = 'yes';
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: routeType: $xavp(ra=>routeType)\n");
    $dlg_var(routeType) = $xavp(ra=>routeType);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: distributeMethod: $xavp(ra=>distributeMethod)\n");
    $avp(distributeMethod) = $xavp(ra=>distributeMethod);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: asAddress: $xavp(ra=>asAddress)\n");
    $avp(asAddress) = $xavp(ra=>asAddress);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: mediaRelaySetsId: $xavp(ra=>mediaRelaySetsId)\n");
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
}

# Handle within-dialog messages
route[WITHINDLG] {
    if (!$dlg_var(confirmed) && is_method("UPDATE|INVITE")) drop;

    # REFER not allowed
    if (is_method("REFER")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: 'REFER' not supported\n");
        send_reply("405","Method Not Allowed");
        exit;
    }

    if (is_method("UPDATE|INVITE")) route(UPDATE_CALLER);

    # Reinvite handling
    if (is_method("INVITE")) {
        # uac_replace_from does not maintain display_name in subsequent transactions
        $fn = $dlg_var(newfromdisplay);

        #!ifdef DELAY_MEDIALIBERATION
        if ($dlg_var(initial_reinvite) == 'pending') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: Initial reinvite from call initiated by AS\n");
            $dlg_var(initial_reinvite) = 'yes';
        } else {
            $dlg_var(initial_reinvite) = 'no';
        }
        #!endif
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        } else if ( is_method("ACK") ) {
            # ACK is forwarded statelessy
            route(RTPRELAY);
        }
        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        send_reply("403","Not here");
    }
    exit;
}

route[DISPATCH] {
    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Static routing to specific AS?
    if ($avp(distributeMethod) == 'static') {
        $du = "sip:" + $avp(asAddress) + ":6060";
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: Company has static routing enabled\n");
        t_on_failure("MANAGE_FAILURE");
    } else {
        if ($avp(distributeMethod) == 'hash') {
            $avp(hash) = $dlg_var(companyId);
            # hash over $avp(hash)
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: Dispatch hashing '$avp(hash)'\n");
            $var(alg) = 7;
        } else {
            # round robin dispatching on ASs (distributeMethod == 'rr')
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: dispatch to any AS (round robin)\n");
            $var(alg) = 4;
        }

        if(!ds_select_dst("1", "$var(alg)")) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: No destination found\n");
            send_reply("404", "No destination");
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: $avp(AVP_CNT) destination(s) found\n");
        }

        t_on_failure("MANAGE_FAILURE_AS");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du>\n");
    t_on_branch("MANAGE_BRANCH_AS");
}

# Relay request
route[RELAY] {
    if ($(du{uri.host}) != $null)
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Relaying to $(du{uri.host}) (du, $dP)\n");
    else
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Relaying to $(ru{uri.host}) (ru)\n");

    # Common for every reply
    t_on_reply("MANAGE_REPLY");

    if (!t_is_set("branch_route")) {
        if (!has_totag() && is_method("CANCEL")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_BRANCH for CANCEL of initial transaction\n");
        } else if (!has_totag()) {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_BRANCH, this should not happen for an initial request\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_BRANCH for non-initial transaction\n");
        }
        t_on_branch("MANAGE_BRANCH");
    }

    if (!t_is_set("failure_route")) {
        if (!has_totag() && is_method("CANCEL")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_FAILURE for CANCEL of initial transaction\n");
        } else if (!has_totag()) {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_FAILURE, this should not happen for an initial request\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_FAILURE for non-initial transaction\n");
        }
        t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay())
        sl_reply_error();

    exit;
}

route[ANTIFLOOD] {
#!ifdef WITH_ANTIFLOOD
    # flood detection from same IP and traffic ban for a while
    #
    # Excluded from pike:
    #   - my ip excluded
    #   - AS-es excluded
    #   - IPs in trusted table
    if (allow_trusted($si, 'any')) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (IP added in antiflood trusted IPs)\n");
    } else if (src_ip==myself || ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (AS or myself talking)\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: $si will be checked against antiflood\n");
        if($sht(ipban=>$si) != $null) {
            # ip is already blocked
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
#!endif

    return;
}

# Configure xlog
route[CONFIGURE_XLOG] {
    # Evaluate only once for SIP methods than can initiate transaction
    if ($dlg_var(log) == "0" || $dlg_var(log)) return;

    $dlg_var(log) = "0";

    if (is_method("INVITE") && $sel(cfg_get.dolog.invite)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REGISTER") && $sel(cfg_get.dolog.register)) {
        $dlg_var(log) = "1";
    }

    if (is_method("PUBLISH") && $sel(cfg_get.dolog.publish)) {
        $dlg_var(log) = "1";
    }

    if (is_method("SUBSCRIBE") && $sel(cfg_get.dolog.subscribe)) {
        $dlg_var(log) = "1";
    }

    if (is_method("NOTIFY") && $sel(cfg_get.dolog.notify)) {
        $dlg_var(log) = "1";
    }

    if (is_method("OPTIONS") && $sel(cfg_get.dolog.options)) {
        $dlg_var(log) = "1";
    }

    if (is_method("MESSAGE") && $sel(cfg_get.dolog.message)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REFER") && $sel(cfg_get.dolog.refer)) {
        $dlg_var(log) = "1";
    }

    # Needed variables
    if ($dlg_var(cidhash) == $null) {
        # Extract brandId (if present)
        if (is_present_hf('X-Info-BrandId')) {
            $dlg_var(brandId) = $hdr(X-Info-BrandId);
        } else {
            if (is_method("INVITE")) {
                sql_query("cb", "SELECT brandId FROM DDIs WHERE DDI='$rU' OR DDIE164='$rU'", "ra");
                if ( $dbr(ra=>rows) == 1 ) {
                    $dlg_var(brandId) = $dbr(ra=>[0,0]);
                } else {
                    if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] '$rU' not recognized easily\n");
                }
                sql_result_free("ra");
            }
        }

        # Calculate callid hash
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});
        if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calculated hash for $rm $ci\n");
    }

    return;
}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    # Where is my caller? Order: PAI, RPID, From
    if (is_present_hf("P-Asserted-Identity")) {
        $dlg_var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        $dlg_var(caller) = $(re{uri.user});
    } else {
        $dlg_var(caller) = $fU;
    }

    $dlg_var(callee) = $rU;
    $dlg_var(callid) = $ci;
    if (is_present_hf("Diversion")) {
        $dlg_var(diversion) = $(di{uri.user});

        # Extract X-Info-ForwardExt: (internal extension for outbound fw)
        $var(header) = 'X-Info-ForwardExt';
        route(PARSE_OPTIONAL_X_HEADER);
        if ($(var(header-value){s.len}) > 0 && $var(header-value) != $(di{uri.user})) {
            $dlg_var(diversion) = $dlg_var(diversion) + ' (' + $var(header-value) + ')';
        }
    }

    if (is_present_hf("Referred-by")) {
        $dlg_var(referrer) = $(hdr(Referred-by){nameaddr.uri}{uri.user});
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Call due to bxfer from $dlg_var(referrer)\n");
        remove_hf("Referred-by");
    }

}

# Reply generic route (all replies goes through this route)
onreply_route {
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ( $rm =~ $sel(cfg_get.dolog.printmsg_methods) ) xlog("L_WARN", "Received reply:\n\n$mb\n");
}

# Common for both AS and GW replies
onreply_route[MANAGE_REPLY] {

    route(UPDATE_CALLER);

    # Manage RTP
    if (t_check_status("[12][0-9]{2}")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-REPLY: Non-error reply $rs, call RTPRELAY\n");
        route(RTPRELAY);
    }
}

# Manage failure replies (only for failure response codes, executed after previous 2 routes)

# Failure route for initial transactions to GW
failure_route[MANAGE_FAILURE_GW] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: t_is_canceled, exit here\n");
        exit;
    }

    if (t_check_status("(401)|(407)") && $avp(auth_done) != '1') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code auth must be done!\n");

        # Get ready for SIP auth
        #   username:  $avp(provideruser) set in SELECT-GW
        #   password:  $avp(secret) from DB below
        #   realm:     take it from 401/407 leaving it empty
        $avp(realm) = '';

        # $avp(secret) is available?
        if (is_avp_set("$avp(secret)")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Secret loaded from AVP, sounds good\n");
            # Sends INVITE with AUTH (and adapts CSeq)
            uac_auth();
            $avp(auth_done) = '1'; # Set avp to avoid using invalid credentials more than once
            # Ensure last chosen GW du and ru are used in subsequent auth process
            $du = $avp(du_after_lcr);
            $ru = $avp(ru_after_lcr);

            t_on_failure("MANAGE_FAILURE_GW");
            t_on_branch("MANAGE_BRANCH_GW");
            route(RELAY);
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: No secret available for $avp(newfrom), defunct_gw and try another one\n");
            defunct_gw(36000); # No credentials available, defunct gw 4ever and trigger alarm
        }
    } else if (t_check_status("(401)|(407)") && $avp(auth_done) == '1') {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Invalid credentials already used\n");
    } else if (t_check_status("486")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Destiny busy (reply code: $T_reply_code)\n");
        exit;
    } else if (t_check_status("422")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Session Interval Too Small, forward to AS (reply code: $T_reply_code)\n");
        exit;
    } else if (t_check_status("408")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code: Inactivate GW\n");
        inactivate_gw(); # Inactivate GW temporally (until it answers OPTIONS)
    } else if (t_check_status("3[0-9]{2}")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code: Not allowed from GW\n");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Failure using gateway to place a call (reply code: $T_reply_code)\n");

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Try next GW\n");
    route(SELECT_GW);

    t_on_failure("MANAGE_FAILURE_GW");
    t_on_branch("MANAGE_BRANCH_GW");

    if ($avp(externallyRated) == '1') {
        xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Externally rating is enabled for this PeeringContract, proceed");
        $dlg_var(cgrid) = $null;
        route(RELAY);
    } else {
        route(CGRATES_AUTH_REQUEST);
    }
}

# Failure route for initial transactions to AS
failure_route[MANAGE_FAILURE_AS] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS '$avp(AVP_DST)' as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            t_on_branch("MANAGE_BRANCH_AS");
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Failure route for non-initial transactions
failure_route[MANAGE_FAILURE] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: t_is_canceled, exit here\n");
        exit;
    }
}

# Route for branching to GWs: Only for INVITEs and BYEs (fork-able)

# Branch route for initial transactions to GW
branch_route[MANAGE_BRANCH_GW] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: New branch [$T_branch_idx] to $ru\n");

    # Manage RTP
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Call RTPRELAY for $ci\n");
    route(RTPRELAY);

    # In initial request, adapt From, To, PAI and RPID to what selected gateway expects
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Adapt From, To, PAI and RPID to what selected gateway expects\n");

    # avp(caller_method): bitwise flag ABC (in DB integer from 0-7)
    # A: auth_username as from_user flag (4)
    # B: RPID flag (2)
    # C: PAI flag (1)
    #
    # e.g. 5: Use auth_username as from_user and use PAI header

    # Asterisk must never send PAI header when talking to proxytrunks
    if (is_present_hf("P-Asserted-Identity")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Received P-Asserted-Identity header from AS, this should NEVER happen\n");
    }

    # Asterisk should never send RPID header when talking to proxytrunks
    if (is_present_hf("Remote-Party-ID")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Received Remote-Party-ID header from AS, this should NEVER happen\n");
    }

    # Get transformed caller (From) and callee (in $var(callee) and $var(caller))
    route(TRANSFORMATE_OUT);
    $rU = $var(callee);

    # Caller after transformations
    $avp(newfromuser) = $var(caller);
    $avp(newfromdomain) = $Ri; # Use bind ip as from domain
    $avp(newfromuri) = 'sip:' + $avp(newfromuser) + '@' + $avp(newfromdomain);
    # Keep this in dlg_var as uac_replace_from does not work for display name
    $dlg_var(newfromdisplay) = '"' + $avp(newfromuser) + '"'; # "Like this" (entrecomillado)

    # Use PAI?
    if (avp_check("$avp(caller_method)", "and/i:0x01")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Set PAI to: $dlg_var(newfromdisplay) <$avp(newfromuri)>\n");
        append_hf("P-Asserted-Identity: $dlg_var(newfromdisplay) <$avp(newfromuri)>\r\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Do not use PAI\n");
    }

    # Use RPID?
    if (avp_check("$avp(caller_method)", "and/i:0x02")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Set RPID to: $dlg_var(newfromdisplay) <$avp(newfromuri)>\n");
        append_hf("Remote-Party-ID: $dlg_var(newfromdisplay) <$avp(newfromuri)>;privacy=off;screen=no\r\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Do not use RPID\n");
    }

    # Modify from_user and from_domain if necessary
    if ( $avp(from_user) != $null && $avp(from_domain) != $null ) {
        $avp(newfromuri) = "sip:" + $avp(from_user) + '@' + $avp(from_domain);
    } else if ($avp(from_user) != $null) {
        $avp(newfromuri) = "sip:" + $avp(from_user) + '@' + $avp(newfromdomain);
    } else if ($avp(from_domain) != $null) {
        $avp(newfromuri) = "sip:" + $avp(newfromuser) + '@' + $avp(from_domain);
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: New from: $dlg_var(newfromdisplay) <$avp(newfromuri)>\n");
    uac_replace_from('$dlg_var(newfromdisplay)', "$avp(newfromuri)"); # Cambio el From (se auto cambiara en la respuesta)

    # To should be equal to RURI
    $avp(newto) = $ru;
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: New to: $avp(newto)\n");
    uac_replace_to("$avp(newto)"); # Cambio el To (se auto cambiara en la respuesta)

    # Add GW prefix if necessary
    if ($avp(gw_prefix) != $null) {
        $rU = $avp(gw_prefix) + $rU;
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Add GW prefix, new ruri-user: $rU\n");
    }
}

# Branch route for initial transactions to AS
branch_route[MANAGE_BRANCH_AS] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-AS: New branch [$T_branch_idx] to $ru\n");

    # Manage RTP
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-AS: Call RTPRELAY for $ci\n");
    route(RTPRELAY);
}

# Branch route for non-initial transactions
branch_route[MANAGE_BRANCH] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH: New branch [$T_branch_idx] to $ru\n");

    # Manage RTP
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH: Call RTPRELAY for $ci\n");
    route(RTPRELAY);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] 200 OK from AS, incoming call from GW to AS $si ($ci)\n");
    } else {
        $dlg_var(peeringContractId) = $avp(peeringContractId);
        if (!$(dlg_var(peeringContractId){s.len})) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] [b$dlg_var(brandId)][$dlg_var(cidhash)] Problems obtaining peeringContractId, THIS CALL WILL NOT BE BILLED ($ci)!\n");
        }
        route(CGR_CALL_START);
    }

    # New dialog, print stats
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: $dlg_var(profile) established for '$dlg_var(companyName)' (id: $dlg_var(companyId)) [$ci]\n");
    route(PRINT_STATS);
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    # Dialog end, print stats
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: $dlg_var(profile) ended for '$dlg_var(companyName)' (id: $dlg_var(companyId)) [$ci]\n");
    route(PRINT_STATS);
    route(CGR_CALL_END);
}

# Executed for request generated by Kamailio
event_route[tm:local-request] {
    xlog("L_NOTICE","Kamailio generated request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");

    // UACREG sends REGISTER requests whose Contact domain must be addapted
    if ($rm == "REGISTER") {
        xlog("L_INFO", "UAC generated REGISTER, adapt Contact domain\n");
        subst_hf("Contact", "/reg_contact_addr/$sndfrom(ip):$sndfrom(port)/", "a");
    } else {
        route(CGR_CALL_END);
    }
}

onsend_route {
    if (is_method("ACK")) $dlg_var(confirmed) = '1';

    #!ifdef DELAY_MEDIALIBERATION
    if (is_request() && is_method("INVITE") && $dlg_var(initial_reinvite) == 'yes') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Initial reinvite from call initiated by AS, delay 1 second\n");
        sleep(1);
    }
    #!endif

    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) {
        if (is_request())
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent request:\n\n$snd(buf)\n");
        else
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent reply:\n\n$snd(buf)\n");
    }
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_WARN", "XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");
    route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "GENERIC_XMLRPC_COMMAND: XMLRPC generic command from allowed IP ($si), dispatch!\n");

    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[RTPRELAY] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;
    if (is_method("ACK") && !has_body("application/sdp")) return;

    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPRELAY: Custom rtpproxy set: $dlg_var(mediaRelaySetsId)\n");
        set_rtp_proxy_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    rtpproxy_manage("coarf");

    if (is_request() && is_method("INVITE") && !has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPRELAY: Chosen RTPproxy instance $var(RTP_INSTANCE)\n");
    }

    if ($avp(recordCall) == 'yes' && $dlg_var(recordingCall) != 'yes') {
        # First 200 OK to initial INVITE
        if (is_reply() && t_check_status("2[0-9]{2}")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPRELAY: Start recording this call ('$rs $rr' for initial $rm)\n");
            start_recording();
            $dlg_var(recordingCall) = 'yes'; # Save to avoid start_recording twice if retrans
        }
    }
}

route[CONTROL_EXTERNAL_MAXCALLS] {
    if (get_profile_size("activeCalls", "$dlg_var(companyId)", "$avp(activeCalls)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-EXTERNAL-MAXCALLS: Currently, the company $dlg_var(companyName) (companyId: $dlg_var(companyId)) has $avp(activeCalls) active external calls\n");
    }

    if ($dlg_var(externalMaxCalls) == 0) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-EXTERNAL-MAXCALLS: Maxcalls not active for company $dlg_var(companyName) (companyId: $dlg_var(companyId)), count anyway\n");
        set_dlg_profile("activeCalls", "$dlg_var(companyId)");
        return;
    }

    if ($avp(activeCalls) < $dlg_var(externalMaxCalls)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-EXTERNAL-MAXCALLS: Call allowed, increment external-call counter to company $dlg_var(companyName) (companyId: $dlg_var(companyId))\n");
        set_dlg_profile("activeCalls", "$dlg_var(companyId)");
    } else {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-EXTERNAL-MAXCALLS: Call NOT allowed, 403 Forbidden\n");
        send_reply("403","Maxcalls exceeded");
        exit;
    }
}

route[ADAPT_CALLER] {
    route(GET_CALLER); # Greps caller and sets it in $var(caller)
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-CALLER: Initial caller -> $var(caller)\n");
    $var(number) = $var(caller);
    route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
    $var(caller) = $var(transformated);
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ADAPT-CALLER: Final caller -> $var(caller)\n");
}

route[UPDATE_CALLER] {
    if (!is_present_hf("P-Asserted-Identity") && !is_present_hf("remote-party-id")) return;
    route(ADAPT_CALLER);
    route(SET_CALLER);
}


#################################################
# --- Kamailio-CGRateS related route blocks --- #
#################################################

# Detect presence of at least one connection with CGRates
event_route[evapi:connection-new] {
    $sht(cgrconn=>cgr) = $evapi(srcaddr) + ":" + $evapi(srcport);
    xlog("L_NOTICE", "Connection with CGrates established ($sht(cgrconn=>cgr))!!\n");
}

event_route[evapi:connection-closed] {
    xlog("L_ERR", "Connection with CGrates closed!!\n");
    $sht(cgrconn=>cgr) = $null;
}

# Send AUTH_REQUEST to CGRateS
route[CGRATES_AUTH_REQUEST] {
    # Auth INVITEs with CGRateS
    if $sht(cgrconn=>cgr) == $null {
        xlog("L_ERROR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGRATES-AUTH-REQUEST: Charging controller unreachable");
        sl_send_reply("503","Charging controller unreachable");
        exit;
    }

    $dlg_var(cgrTenant) = 'b' + $dlg_var(brandId);
    $dlg_var(cgrAccount) = 'c' + $dlg_var(companyId);
    if ($dlg_var(cgrDestination) == $null) $dlg_var(cgrDestination) = $rU;
    $dlg_var(setupTime) = $TS;

    xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGRATES-AUTH-REQUEST: Ask CGRates whether call is granted ($dlg_var(cgrTenant):$dlg_var(cgrAccount):$dlg_var(cgrDestination))");

    evapi_async_relay("{\"event\":\"CGR_AUTH_REQUEST\",
            \"callid\":\"$dlg(callid)\",
            \"from_tag\":\"$dlg(from_tag)\",
            \"tr_index\":\"$T(id_index)\",
            \"tr_label\":\"$T(id_label)\",
            \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
            \"cgr_account\":\"$dlg_var(cgrAccount)\",
            \"cgr_destination\":\"$dlg_var(cgrDestination)\",
            \"cgr_setuptime\":\"$dlg_var(setupTime)\"}");

    # Do not continue route script, transaction will be processed when API answers
    exit;
}

event_route[evapi:message-received] {
    json_get_field("$evapi(msg)", "Event", "$var(Event)");
    route($(var(Event){s.rm,"})); # String characters are kept by json_get_field, remove them here
    # Message received from CGrates, continue in CGR_AUTH_REPLY
}

route[CGR_AUTH_REPLY] {
    json_get_field("$evapi(msg)", "TransactionIndex", "$var(TransactionIndex)");
    json_get_field("$evapi(msg)", "TransactionLabel", "$var(TransactionLabel)");
    json_get_field("$evapi(msg)", "MaxSessionTime", "$var(MaxSessionTime)");
    json_get_field("$evapi(msg)", "Suppliers", "$var(Suppliers)");
    json_get_field("$evapi(msg)", "ResourceAllowed", "$var(CGRResourceAllowed)");
    json_get_field("$evapi(msg)", "CgrId", "$var(cgrid)");
    json_get_field("$evapi(msg)", "Error", "$var(CgrError)");
    $var(id_index) = $(var(TransactionIndex){s.int});
    $var(id_label) = $(var(TransactionLabel){s.int});
    $var(CgrMaxSessionTime) = $(var(MaxSessionTime){s.int});
    $var(CgrSuppliers) = $(var(Suppliers){s.rm,"});
    $var(CGRResourceAllowed) = $(var(CGRResourceAllowed){s.rm,"});
    $var(CgrError) = $(var(CgrError){s.rm,"});

    # API response parsed, continue processing transaction in CGRATES_AUTH_REPLY
    t_continue("$var(id_index)", "$var(id_label)", "CGRATES_AUTH_REPLY"); # Unpark the transaction
}

route[CGRATES_AUTH_REPLY] {
    # Save cgrid in acc cdrs
    $dlg_var(cgrid) = $(var(cgrid){s.rm,"});

    if ($var(CgrError) != "") {
        xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGRATES-AUTH-REPLY: $var(CgrError)");
        sl_send_reply("503", "CGR_ERROR");
        exit;
    }

    if ($var(CgrMaxSessionTime) != -1) {
        if $var(CgrMaxSessionTime) == 0 { // Not enough balance, do not allow the call to go through
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Insufficient credit");
            sl_send_reply("403","Insufficient credit");
            exit;
        } else if !dlg_set_timeout("$var(CgrMaxSessionTime)") {
            xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Max session time error");
            sl_send_reply("503","CGR_MAX_SESSION_TIME_ERROR");
            exit;
        }
    }

    if ($var(CGRResourceAllowed) == "false") {
        xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Resource not allowed");
        sl_send_reply("403","Resource not allowed");
        exit;
    }

    xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Call granted, RELAY");
    route(RELAY);
}

# Inform CGRateS about CALL_START (start prepaid sessions loops)
route[CGR_CALL_START] {
    if $sht(cgrconn=>cgr) == $null {
        xlog("L_ERROR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGR-CALL-START: Charging controller unreachable");
        sl_send_reply("503","Charging controller unreachable");
        exit;
    }

    if ($dlg_var(cgrid) == $null) {
        xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGR-CALL-START: No cgrid, skip rating logic");
        return;
    }

    xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGR-CALL-START: Warn CGRates that call is started");

    evapi_relay("{\"event\":\"CGR_CALL_START\",
               \"callid\":\"$dlg(callid)\",
               \"from_tag\":\"$dlg(from_tag)\",
               \"h_entry\":\"$dlg(h_entry)\",
               \"h_id\":\"$dlg(h_id)\",
               \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
               \"cgr_account\":\"$dlg_var(cgrAccount)\",
               \"cgr_destination\":\"$dlg_var(cgrDestination)\",
               \"cgr_setuptime\":\"$dlg_var(setupTime)\",
               \"cgr_answertime\":\"$TS\"}");
}

# Inform CGRateS about CALL_END (stop debit loops, perform accounting if desired in this way)
route[CGR_CALL_END] {
    if $sht(cgrconn=>cgr) == $null {
        xlog("L_ERROR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGR-CALL-END: Charging controller unreachable");
        exit;
    }

    if ($dlg_var(cgrid) == $null) {
        xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGR-CALL-END: No cgrid, skip rating logic");
        return;
    }

    $var(callDur) = $TS - $dlg(start_ts);
    xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CGR-CALL-END: Warn CGRates that call has ended (duration: $var(callDur))");

    evapi_relay("{\"event\":\"CGR_CALL_END\",
        \"callid\":\"$dlg(callid)\",
        \"from_tag\":\"$dlg(from_tag)\",
        \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
        \"cgr_account\":\"$dlg_var(cgrAccount)\",
        \"cgr_destination\":\"$dlg_var(cgrDestination)\",
        \"cgr_answertime\":\"$dlg(start_ts)\",
        \"cgr_setuptime\":\"$dlg_var(setupTime)\",
        \"cgr_duration\":\"$var(callDur)\",
        \"cgr_disconnectcause\":\"$T_reply_code\"}");
}


#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - ARTEMIS // Kamailio Proxy for Trunks
#        vozip+ivozprovider@irontec.com
#
#########################################################################################################

####### Defines #########

#!define SIP_PORT 5060
#!define SIPS_PORT 5061
#!define RPC_PORT 8001

# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# ACC Flags
#!define FLT_ACC 1
#!define FLT_ACCFAILED 2

# DLG_FLAG
#!define DLG_FLAG 3

# - options
#!define WITH_REALTIME

#!define DBURL "mysql://[kamailio]/ivozprovider"

# Maximum call duration: 3 hours
#!define MAX_DIALOG_TIMEOUT 10800

# CGRateS mode:
#
# (0) Ask CGRateS for acceptance for all calls. If CGRateS is down, allow only
#     within-country calls. Default mode.
#
# (1) Disable CGRateS: CGRateS won't be used for any call.
#
# To skip rater in all calls, set 1:
# kamcmd-proxytrunks cfg.set config cgrates_mode 1
#
# To go back to default mode, set 0:
# kamcmd-proxytrunks cfg.set config cgrates_mode 0
#
# To see current value:
# kamcmd-proxytrunks cfg.get config cgrates_mode

config.cgrates_mode = 0

# Enable/disable debug logs
dolog.rpc    = 0 desc "If 1, debug RPC"

####### Global Parameters #########

listen=udp:IP:SIP_PORT
listen=tcp:IP:SIP_PORT
listen=tls:IP:SIPS_PORT
listen=tcp:IP:RPC_PORT

import_file "additional_addresses.cfg"

import_file "custom_settings.cfg"

# -- Debug level
# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# If debug level of message is lower than current debug parameter, it gets printed
# Current value: 2 (INFO and higher)
#
# This setting can me modified/seen live running:
# kamcmd-proxyusers cfg.seti core debug X
# kamcmd-proxyusers cfg.get core debug

debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes
version_table="kam_version"

# This proxy implements gateway failover, increase branches max value to avoid "500 Forking capacity exceeded" errors
max_branches=25

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec IvozProvider v2.16"
user_agent_header="User-Agent: Irontec IvozProvider v2.16"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "sqlops.so"
loadmodule    "rtpengine.so"
loadmodule    "cfg_rpc.so"
loadmodule    "dialog.so"
loadmodule    "dmq.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "acc.so"
loadmodule    "lcr.so"
loadmodule    "uac.so"
loadmodule    "xmlops.so"
loadmodule    "domain.so"
loadmodule    "cfgutils.so"
loadmodule    "dialplan.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "permissions.so"
loadmodule    "diversion.so"
loadmodule    "evapi.so"
loadmodule    "json.so"
loadmodule    "jansson.so"
loadmodule    "xhttp.so"
loadmodule    "jsonrpcs.so"
loadmodule    "http_client.so"
loadmodule    "ipops.so"

#!ifdef WITH_REALTIME
loadmodule    "ndb_redis.so"
#!endif

#!ifdef WITH_REALTIME
# REDIS
modparam("ndb_redis", "server", "name=realtime;sentinel_group=mymaster;sentinel_master=1;sentinel=data.ivozprovider.local:26379")
modparam("ndb_redis", "init_without_redis", 1)
#!endif

# DMQ
modparam("dmq", "server_address", "sip:trunks.ivozprovider.local:5060")
modparam("dmq", "notification_address", "sip:users.ivozprovider.local:5060")
modparam("dmq", "ping_interval", 3600)

# JSONRPC-S
modparam("jsonrpcs", "fifo_name", "/tmp/kamailio_proxytrunks_fifo")

# HTTP_CLIENT
modparam("http_client", "httpcon", "cgrates=>http://trunks.ivozprovider.local:2080")
modparam("http_client", "connection_timeout", 2)

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_DSSOCKET)")
modparam("dispatcher", "attrs_avp", "$avp(DSATTRS)")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 2)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@trunks.ivozprovider.local")
modparam("dispatcher", "hash_pvar", "$avp(hash)")

# TLS
modparam("tls", "config", "/etc/kamailio/proxytrunks/tls.cfg")
modparam("tls", "tls_log", 1)

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxytrunks_ctl")

# RTPENGINE
modparam("rtpengine", "db_url", DBURL)
modparam("rtpengine", "table_name", "kam_rtpengine")
modparam("rtpengine", "setid_avp", "$avp(setid)")
modparam("rtpengine", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpengine", "setid_default", 0)

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://[kamailio]/ivozprovider")

# ACC
# -- transactions to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "report_cancels", 1)
modparam("acc", "report_ack", 1)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs; callid=$ci; cidhash=$dlg_var(cidhash)")

# -- cdr accounting to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 0)
modparam("acc", "cdrs_table", "kam_trunks_cdrs")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);carrierId=$dlg_var(carrierId);direction=$dlg_var(direction);bounced=$dlg_var(bounced);cgrid=$dlg_var(cgrid);retailAccountId=$dlg_var(retailAccountId);residentialDeviceId=$dlg_var(residentialDeviceId);parsed=$dlg_var(parsed);userId=$dlg_var(userId);friendId=$dlg_var(friendId);faxId=$dlg_var(faxId);ddiId=$dlg_var(ddiId);ddiProviderId=$dlg_var(ddiProviderId)")
modparam("acc", "cdr_extra_nullable", 1)

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "activeCallsCompany; activeCallsBrand; inboundCallsCompany; inboundCallsBrand; outboundCallsCompany; outboundCallsBrand")
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "track_cseq_updates", 1)
modparam("dialog", "detect_spirals", 0)
modparam("dialog", "default_timeout", MAX_DIALOG_TIMEOUT)

# HTABLE
modparam("htable", "htable", "cgrconn=>size=1;")
modparam("htable", "htable", "dmq=>size=8;autoexpire=10800;dmqreplicate=1;")
modparam("htable", "enable_dmq", 1)

# UAC
modparam("uac", "auth_realm_avp","$avp(auth_realm)")
modparam("uac", "auth_username_avp","$avp(auth_user)")
modparam("uac", "auth_password_avp","$avp(auth_secret)")
modparam("uac", "restore_mode","auto")
modparam("uac", "restore_dlg", 1)
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_db_table", "kam_trunks_uacreg")
modparam("uac", "reg_contact_addr", "reg_contact_addr")
modparam("uac", "reg_timer_interval", 60)
modparam("uac", "reg_retry_interval", 300)

# LCR
modparam("lcr", "db_url", DBURL)
modparam("lcr", "lcr_gw_table","kam_trunks_lcr_gateways")
modparam("lcr", "lcr_rule_table", "kam_trunks_lcr_rules")
modparam("lcr", "lcr_rule_target_table", "kam_trunks_lcr_rule_targets")
modparam("lcr", "gw_name_column", "gw_name")
modparam("lcr", "ip_addr_column", "ip")
modparam("lcr", "lcr_id_column", "lcr_id")
modparam("lcr", "gw_uri_avp", "$avp(gw_uri_avp)")
modparam("lcr", "ruri_user_avp", "$avp(ruri_user_avp)")
modparam("lcr", "flags_avp", "$avp(s:carrierServerId)")
modparam("lcr", "flags_column", "carrierServerId")
modparam("lcr", "defunct_capability", 1)
modparam("lcr", "lcr_id_avp", "$avp(lcr_id_avp)")
modparam("lcr", "defunct_gw_avp", "$avp(defunct_gw_avp)")
modparam("lcr", "lcr_rule_hash_size", 1024)
modparam("lcr", "lcr_gw_count", 1024)
modparam("lcr", "fetch_rows", 3000)
modparam("lcr", "ping_interval", 15) # Ping every 15 seconds
modparam("lcr", "ping_inactivate_threshold", 1) # Mark as inactive at first call of inactivate_gw()
modparam("lcr", "ping_valid_reply_codes", "403,404,405,501") # Mark as active when 2XX or these reply codes
modparam("lcr", "ping_from", "sip:lcr@trunks.ivozprovider.local")
modparam("lcr", "lcr_count", 1)
modparam("lcr", "dont_strip_or_prefix_flag", 1)
modparam("lcr", "rule_id_avp", "$avp(lcr_rule_id)")
modparam("lcr", "priority_ordering", 1)

# TM
modparam("tm", "fr_timer", 5000)
modparam("tm", "retr_timer1", 500)
modparam("tm", "auto_inv_100_reason", "Trying")

# SANITY
modparam("sanity", "autodrop", 0)

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_trunks_domain")
modparam("domain", "domain_attrs_table", "kam_trunks_domain_attrs")
modparam("domain", "register_myself", 1)

# DIALPLAN
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "table_name", "kam_dialplan")
modparam("dialplan", "attrs_pvar", "$avp(s:appliedrule)")

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_trunks_address") # Allowed addresses per DDI provider
modparam("permissions", "trusted_table", "kam_trusted") # Not used but necessary

# JSONRPCS
modparam("jsonrpcs", "transport", 1)

####### Routing Logic ########

request_route {
    route(REQINIT);

    route(IS_FROM_INSIDE);

    # Calculate cidhash if not set
    route(CIDHASH);

    if (is_method("KDMQ") && $var(is_from_inside)) {
        dmq_handle_message();
        exit;
    }

    if (is_method("OPTIONS")) {
        force_rport();
        send_reply("200", "I'm here!");
        exit;
    }

    xnotice("[$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($proto:$si:$sp) [$ci]\n");

    if (!$var(is_from_inside) && !has_totag() && !allow_source_address_group()) {
        xwarn("[$dlg_var(cidhash)] Inbound initial request from $si, not recognized as a valid DDI Provider, 403 Forbidden\n");
        send_reply("403", "Forbidden");
        exit;
    }

    # CANCEL processing
    if (is_method("CANCEL")) {
        xinfo("[$dlg_var(cidhash)] ----> $rm from $si\n");
        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RTPENGINE);
            route(RELAY);
        }

        xerr("[$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # Manage retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    ### only initial requests (no To tag)

    # Only INVITE can start a dialog
    if (!is_method("INVITE")) {
        xwarn("[$dlg_var(cidhash)] $rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Remove preloaded route headers
    remove_hf("Route");

    # Manage dialog
    if (!is_known_dlg() || src_ip == myself) {
        dlg_manage();
    }

    # Calculate cidhash if not set
    route(CIDHASH);

    # Transformate numbers for calls from ddiProviders
    if (!$var(is_from_inside)) {
        route(GET_TRANSFORMATIONS_IN);
        route(TRANSFORMATE_IN);
    }

    # Inspect new request
    route(CLASSIFY);

    # Setup accounting
    route(ACCOUNTING);

    # Add record-route to INVITE requests
    record_route();

    # Handle skip media-relay scenarios
    route(SKIPMEDIARELAY);

    # Easy routing
    if ($var(is_from_inside) == 1) { # kamusers or AS calls
        # IvozProvider calling, route to corresponding GW
        route(PARSE_X_HEADERS);
        route(GET_INFO_FROM_COMPANY);
        route(CONTROL_MAXCALLS);
        route(SAVE_CONTACT);

        # Check if this call is to one of our DDIs
        route(CHECK_BOUNCE);

        # Call RTPENGINE before branching (avoids call in failure routes)
        route(RTPENGINE);

        # Evaluate routing logic
        route(LOAD_GWS);

        # Check if special number
        route(CHECK_SPECIAL);

        # Check if this call requires rater acceptance
        route(CHECK_RATER);

        if ($var(needsRater) == 1) {
            route(CGRATES_AUTH_REQUEST);

            # From now on, only executed if CGRateS is DOWN
            route(IS_WITHIN_COUNTRY);

            if ($var(is_within_country)) {
                xwarn("[$dlg_var(cidhash)] Allow within country call despite CGRateS being down");
            } else {
                xerr("[$dlg_var(cidhash)] Drop call as CGRateS is down");
                send_reply("503","Charging controller unreachable");
                exit;
            }
        }

        route(SELECT_NEXT_GW);
    } else { # carriers or bounced calls from myself
        if (uri == myself) {
            # Someone calling to my domain, dispatch to next hop
            remove_hf_re("^X-"); # Remove X-HEADERS from carriers
            route(GET_INFO_FROM_MATCHED_DDI);
            route(CONTROL_MAXCALLS);
            #!ifdef WITH_MULTISOCKET
            # force_send_socket to main address
            $fs = "udp:" + $var(trunksAddress) + ":5060";
            #!endif
            route(DISPATCH);
            route(RTPENGINE);
        } else {
            xerr("[$dlg_var(cidhash)] $rd is not one of my domains, 404 Not Here\n");
            send_reply("404", "Not Here");
            exit;
        }
    }

    route(RELAY);
}

route[SKIPMEDIARELAY] {
    if (ds_is_from_list("1")) {
        # AS
        xdbg("[$dlg_var(cidhash)] From AS, force media handling\n");
    } else if ($si == $var(usersAddress) && $sp == "5060") {
        # USERS
        xdbg("[$dlg_var(cidhash)] From Users, skip media handling\n");
        $dlg_var(skipMediaRelay) = 'yes';
    } else if (src_ip == myself) {
        # TRUNKS
        xdbg("[$dlg_var(cidhash)] From Trunks, skip media handling\n");
        $dlg_var(skipMediaRelay) = 'yes';
    } else {
        # CARRIER
        if ($dlg_var(type) == 'retail') {
            xdbg("[$dlg_var(cidhash)] From Carrier to retail, skip media handling\n");
            $dlg_var(skipMediaRelay) = 'yes';
        } else {
            xdbg("[$dlg_var(cidhash)] From Carrier to non-retail, force media handling\n");
        }
    }
}

# This route sets $var(is_from_inside)
route[IS_FROM_INSIDE] {

# 4 possible sources:
#   - is_from_as = ds_is_from_list("1");
#   - is_from_users = ($si == $var(usersAddress) && $sp == "5060");
#   - is_from_trunks = (src_ip == myself && !is_from_users);
#   - is_from_carriers = none of above

    if (ds_is_from_list("1") || ($si == $var(usersAddress) && $sp == "5060")) {
        $var(is_from_inside) = 1; # as / users
    } else if (src_ip == myself) {
        $var(is_from_inside) = 2; # trunks
    } else {
        $var(is_from_inside) = 0; # carrier
    }
}

# Sets dlg_var(cidhash)
route[CIDHASH] {
    if ($dlg_var(cidhash) == $null)
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});
}

route[CHECK_BOUNCE] {
    #!ifdef WITHOUT_BOUNCER
        return;
    #!endif

    $xavp(ra) = $null;
    sql_xquery("cb", "SELECT C.type FROM DDIs D INNER JOIN Companies C ON C.id=D.companyId WHERE D.DDIE164='$rU'", "ra");
    if ($xavp(ra=>type) != $null) {
        xinfo("[$dlg_var(cidhash)] CHECK-BOUNCE: Call is to one of my DDIs\n");
        $dlg_var(bounced) = '1';
    }

}

route[REQINIT] {
    # Easy dropping for scanners
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent|pplsip" || search("sipvicious")) {
        xwarn("REQINIT: Dropping scanner request ----> $rm from $si\n");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        xerr("REQINIT: Dropping malformed SIP message from $si:$sp\n");
        exit;
    }

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        xerr("REQINIT: Too many hops for SIP message from $si:$sp\n");
        send_reply("483","Too Many Hops");
        exit;
    }
}

route[LOAD_GWS] {
    $var(filter) = 'b' + $dlg_var(brandId) + 'c' + $dlg_var(companyId);
    if ($avp(fax)) {
        load_gws(1, 'fax', $var(filter));
        if ($avp(gw_uri_avp) != $null) {
            xwarn("[$dlg_var(cidhash)] LOAD-GWS: Fax specific route found\n");
        }
    }

    if ($avp(gw_uri_avp) == $null) {
        $var(prefix) = $dlg_var(routingTag) + $rU;
        load_gws(1, $var(prefix), $var(filter));
    }

    if ($avp(gw_uri_avp) != $null) {
        # At least one gateway loaded, continue

        # Print GWs added by Kamailio lcr module
        xinfo("[$dlg_var(cidhash)] LOAD-GWS: Carriers added by Kamailio lcr module\n");
        route(PRINT_GWS);

        # Lookup for dummy GWs and replace them with CGRateS LCR gateways
        $var(i) = 0;
        $var(lastPrio) = 0;
        while(is_avp_set("$(avp(gw_uri_avp)[$var(i)])")) {
            $var(rule_id) = $(avp(gw_uri_avp)[$var(i)]{s.select,-1,|});
            $var(gw_hostname) = $(avp(gw_uri_avp)[$var(i)]{s.select,6,|});

            sql_xquery("cb", "SELECT O.routingMode, O.stopper, O.priority FROM kam_trunks_lcr_rules K JOIN OutgoingRouting O ON O.id=K.outgoingRoutingId WHERE K.id=$var(rule_id)", "rr");

            if ($var(lastPrio) == 0 && $xavp(rr=>stopper)) {
                # First stopper rule found
                if ($xavp(rr=>stopper)) {
                     $var(lastPrio) = $xavp(rr=>priority);
                     xinfo("[$dlg_var(cidhash)] LOAD-GWS: Stopper rule [$var(i)] found, skip rules with priority higher than $var(lastPrio)");
                }
            } else if ($var(lastPrio) > 0){
                if ($xavp(rr=>priority) > $var(lastPrio)) {
                    xinfo("[$dlg_var(cidhash)] LOAD-GWS: Skip route [$var(i)] and remaining ones as higher priority found");
                    break;
                } else {
                    xinfo("[$dlg_var(cidhash)] LOAD-GWS: Adding route [$var(i)] as has same prio than stopper rule");
                }
            }

            if ($var(gw_hostname) == "dummy.ivozprovider.local") {
                if ($xavp(rr=>routingMode) == 'block') {
                    xinfo("[$dlg_var(cidhash)] LOAD-GWS: Blocking route [$var(i)] found, drop call");
                    send_reply("403","Forbidden");
                    exit;
                } else {
                    # routing_mode == 'lcr'
                    xinfo("[$dlg_var(cidhash)] LOAD-GWS: LCR route [$var(i)] found, replace it with LCR gateways");
                    route(ADD_LCR_CARRIERS);
                }
            } else {
                $avp(new_gw_uri_avp) = $(avp(gw_uri_avp)[$var(i)]);
            }
            $var(i) = $var(i) + 1;
        }

        $(avp(gw_uri_avp)[*]) = $null;
        avp_copy("$avp(new_gw_uri_avp)", "$avp(gw_uri_avp)/gd");

        # Print final GWs (static + dynamic)
        xinfo("[$dlg_var(cidhash)] LOAD-GWS: Final carriers (static + dynamic rules)\n");
        route(PRINT_GWS);
    } else {
        xerr("[$dlg_var(cidhash)] LOAD-GWS: No valid gateway for '$rU' for company '$dlg_var(companyId)'\n");
        send_reply("500", "Server Internal Error - No gateways");
        exit;
    }
}

route[PRINT_GWS] {
    $var(i) = 0;

    while(is_avp_set("$(avp(gw_uri_avp)[$var(i)])")) {
        $var(rule_id) = $(avp(gw_uri_avp)[$var(i)]{s.select,-1,|});

        # Get matching prefix
        sql_xquery("cb", "SELECT prefix FROM kam_trunks_lcr_rules WHERE id=$var(rule_id)", "rl");
        $var(matchingPrefix) = $xavp(rl=>prefix);

        # Retrieve info from matched outgoing route
        sql_xquery("cb", "SELECT O.id, O.type, O.routingPatternId, O.routingPatternGroupId, O.routingMode, O.priority, O.weight, O.companyId, O.stopper FROM kam_trunks_lcr_rules K JOIN OutgoingRouting O ON O.id=K.outgoingRoutingId WHERE K.id=$var(rule_id)", "rs");

        # -- carrier
        $var(carrierServerId) = $(avp(gw_uri_avp)[$var(i)]{s.select,-2,|});
        if ($var(carrierServerId) != 0) {
            sql_xquery("cb", "SELECT C.name FROM CarrierServers CS JOIN Carriers C ON C.id=CS.carrierId WHERE CS.id=$var(carrierServerId)", "rt");
            $var(destination) = $xavp(rt=>name);
        } else {
            # lcr/block
            $var(destination) = $xavp(rs=>routingMode);
        }

        # -- company / global routes
        if ($xavp(rs=>companyId) == $null) {
            $var(scope) = "Apply to all companies";
        } else {
            $var(scope) = "Apply to company " + $xavp(rs=>companyId);
        }

        # -- pattern / group / fax routes
        if ($xavp(rs=>type) == "pattern") {
            sql_xquery("cb", "SELECT name_en FROM RoutingPatterns WHERE id=$xavp(rs=>routingPatternId)", "rp");
            $var(prefix) = "Pattern " + $xavp(rp=>name_en) + " (prefix: " + $var(matchingPrefix) + ")";
        } else if ($xavp(rs=>type) == "group") {
            sql_xquery("cb", "SELECT name FROM RoutingPatternGroups WHERE id=$xavp(rs=>routingPatternGroupId)", "rp");
            $var(prefix) = "Group " + $xavp(rp=>name) + " (prefix: " + $var(matchingPrefix) + ")";
        } else {
            # fax
            $var(prefix) = $xavp(rs=>type);
        }

        # Print route summary
        xinfo("[$dlg_var(cidhash)] LOAD-GWS: [$var(i)] $var(scope) - $var(prefix) - $var(destination) (p:$xavp(rs=>priority) w:$xavp(rs=>weight) s:$xavp(rs=>stopper)) [$xavp(rs=>id)]\n");

        $var(i) = $var(i) + 1;
    }
}

route[CHECK_SPECIAL] {
    $var(specialNumber) = 0;
    $var(noRater) = 0;

    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isBrandSpecial FROM SpecialNumbers WHERE numberE164='$rU' AND disableCDR='1' AND brandId='$dlg_var(brandId)'", "ra");

    if ($xavp(ra=>isBrandSpecial) == '1') {
        xwarn("[$dlg_var(cidhash)] CHECK-SPECIAL: Calling to a brand special number '$rU'\n");
        $var(specialNumber) = 1;
    }

    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isGlobalSpecial FROM SpecialNumbers WHERE numberE164='$rU' AND disableCDR='1' AND brandId IS NULL", "rb");
    if ($xavp(rb=>isGlobalSpecial) == '1') {
        xwarn("[$dlg_var(cidhash)] CHECK-SPECIAL: Calling to a global special number '$rU'\n");
        $var(specialNumber) = 1;
    }

    if ($var(specialNumber)) {
        $dlg_var(parsed) = '1'; # Skip this call in CDRs
        $var(noRater) = 1; # Skip rater for this call
        $dlg_var(noRecording) = '1'; # Skip recording for this call
    }
}

route[CHECK_RATER] {
    $var(needsRater) = 0;

    if ($sel(cfg_get.config.cgrates_mode) == 1) {
        xwarn("[$dlg_var(cidhash)] CHECK-RATER: Skip rater for all calls (cgrates_mode: 1)");
        return;
    }

    if ($var(noRater)) {
        xwarn("[$dlg_var(cidhash)] CHECK-RATER: Skip rater for call to '$rU'");
        return;
    }

    # Loop over $avp(gw_uri_avp): if non-externally-rating GW found, set $var(needsRater) to 1 and leave
    $var(m) = 0;
    while(is_avp_set("$(avp(gw_uri_avp)[$var(m)])")) {
        $var(carrierServerId) = $(avp(gw_uri_avp)[$var(m)]{s.select,10,|});

        sql_xquery("cb", "SELECT C.externallyRated FROM CarrierServers CS JOIN Carriers C ON CS.carrierId=C.id WHERE CS.id=$var(carrierServerId)", "ra");

        if ($xavp(ra=>externallyRated) != '1') {
            $var(needsRater) = 1;
            break;
        }

        $var(m) = $var(m) + 1;
    }

    if (!$var(needsRater)) {
        xinfo("[$dlg_var(cidhash)] CHECK-RATER: Rater won't be used for this call");
    }
}

# This route calls ADD_LCR_CARRIER for each Carrier in $avp(carriers)
route[ADD_LCR_CARRIERS] {
    # Prepare CGRateS request
    $var(cgrTenant) = 'b' + $dlg_var(brandId);
    $var(cgrAccount) = 'c' + $dlg_var(companyId);
    $var(cgrDestination) = $rU;

    if ($dlg_var(routingTagId) != $null) {
        $var(cgrSubject) = $dlg_var(routingTag);
    } else {
        $var(cgrSubject) = "";
    }

    sql_xquery("cb", "SELECT outgoingRoutingId FROM kam_trunks_lcr_rules WHERE id='$var(rule_id)'", "ra");
    $var(cgrCategory) = "or" + $xavp(ra=>outgoingRoutingId);

    xinfo("[$dlg_var(cidhash)] GET-LCR-CARRIERS: Ask CGRateS for LCR carriers ($var(cgrTenant):$var(cgrAccount):$var(cgrSubject):$var(cgrDestination):$var(cgrCategory))");

    # Ask CGRateS for LCR carriers
    $var(rc) = http_connect("cgrates", "/jsonrpc", "application/json", "{\"method\":\"ApierV1.GetLcr\",\"params\":[{\"Tenant\":\"$var(cgrTenant)\",\"Category\":\"$var(cgrCategory)\",\"Account\":\"$var(cgrAccount)\",\"Subject\":\"$var(cgrSubject)\",\"Destination\":\"$var(cgrDestination)\",\"IgnoreErrors\":true}],\"id\":1}", "$avp(response)");
    xinfo("[$dlg_var(cidhash)] GET-LCR-CARRIERS: API-server HTTP connection result code: $var(rc)\n");
    xinfo("[$dlg_var(cidhash)] GET-LCR-CARRIERS: API-server HTTP connection response: $avp(response)\n");

    $var(errorField) = '';
    json_get_field("$avp(response)", "error", "$var(errorField)");
    if ($var(rc) != "200" || $var(errorField) != '') {
        xerr("[$dlg_var(cidhash)] GET-LCR-CARRIERS: Error non-empty or non-200 retcode");
        return;
    }

    # Is there any carrier?
    jansson_get("result.Suppliers", $avp(response), "$var(Suppliers)");
    if ($var(Suppliers) == 0) {
        xwarn("[$dlg_var(cidhash)] GET-LCR-CARRIERS: No carrier in '$var(cgrCategory)' is able to rate '$var(cgrDestination)'");
        return;
    }

    # Yes, iterate
    $var(count) = 0;
    jansson_array_size("result.Suppliers", $avp(response), "$var(size)");
    while($var(count) < $var(size)) {
        jansson_get("result.Suppliers[$var(count)].Supplier", $avp(response), "$var(carrier)");
        xinfo("[$dlg_var(cidhash)] GET-LCR-CARRIERS: Add carrier $var(carrier)");

        $var(carrierId) = $(var(carrier){s.numeric});
        route(ADD_LCR_CARRIER);

        $var(count) = $var(count) + 1;
    }
}

# This route calls ADD_LCR_CARRIERSERVER for each carrierServer in $var(carrierId)
route[ADD_LCR_CARRIER] {
    sql_query("cb", "SELECT id FROM CarrierServers WHERE carrierId=$var(carrierId)", "ra");

    if ($dbr(ra=>rows) == 0) {
        xwarn("[$dlg_var(cidhash)] ADD-LCR-CARRIERS: No CarrierServers found for carrierId '$var(carrierId)'\n");
    }

    $var(k) = 0;
    while ($var(k)<$dbr(ra=>rows)) {
        $var(carrierServerId) = $dbr(ra=>[$var(k), 0]);
        route(ADD_LCR_CARRIERSERVER);
        $var(k) = $var(k) + 1;
    }

    sql_result_free("ra");
}

# This route adds one entry to $avp(new_gw_uri_avp) for CarrierServer in $var(carrierServerId)
route[ADD_LCR_CARRIERSERVER]{
    sql_xquery("cb", "SELECT uri_scheme, IFNULL(ip, '') AS ip, IFNULL(hostname, '') AS hostname, port, transport FROM kam_trunks_lcr_gateways WHERE carrierServerId=$var(carrierServerId)", "ra");

    if ($xavp(ra=>scheme) == '2') {
        $var(scheme) = 'sips:';
    } else {
        $var(scheme) = 'sip:';
    }

    if ($xavp(ra=>transport) == '2') {
        $var(transport) = ';transport=tcp';
    } else if ($xavp(ra=>transport) == '3') {
        $var(transport) = ';transport=tls';
    } else {
        $var(transport) = ';transport=udp';
    }

    avp_printf("$avp(avp_new_entry)", "0|$var(scheme)|0|||$xavp(ra=>ip)|$xavp(ra=>hostname)|$xavp(ra=>port)||$var(transport)|$var(carrierServerId)|$var(rule_id)");
    xinfo("[$dlg_var(cidhash)] ADD-LCR-CARRIERSERVER: New entry in gw_uri_avp for CarrierServer [$var(carrierServerId)]: '$avp(avp_new_entry)'");

    $avp(new_gw_uri_avp) = $avp(avp_new_entry);
}

route[SELECT_NEXT_GW] {
    # Save route stopper condition to avoid gateway inactivation
    if ($(avp(gw_uri_avp)[0]) != $null) {
        $var(rule_id) = $(avp(gw_uri_avp)[0]{s.select,-1,|});
        sql_xquery("cb", "SELECT O.stopper FROM kam_trunks_lcr_rules K JOIN OutgoingRouting O ON O.id=K.outgoingRoutingId WHERE K.id=$var(rule_id)", "OutgoingRouting");
    }

    # Evaluate gateway rules
    if (!next_gw()) {
        xerr("[$dlg_var(cidhash)] SELECT-NEXT-GW: NO next GW, send 503 No gateways");
        send_reply("503", "No gateways");
        exit;
    }

    # GW selection may modify both $ru and $du
    xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: New dest-URI $du - New RURI $ru\n");

    # Skip GW if has an unresolvable domain
    if(!is_ip("$nh(d)")) {
        if (!dns_query("$nh(d)", "nextgwaddr")) {
            xwarn("[$dlg_var(cidhash)] SELECT-NEXT-GW: Not resolvable domain '$nh(d)', skip GW");
            route(SELECT_NEXT_GW);
        } else {
            xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: Resolvable domain '$nh(d)' ($dns(nextgwaddr=>addr)) in GW, proceed");
        }
    }

    # Obtain info about selected GW
    sql_xquery("cb", "SELECT C.externallyRated, C.calculateCost, CS.sendPAI, CS.sendRPID, CS.authNeeded, CS.authUser, CS.authPassword, CS.carrierId, CS.fromUser, CS.fromDomain, PT.ip FROM CarrierServers CS JOIN Carriers C ON CS.carrierId=C.id LEFT JOIN ProxyTrunks PT ON PT.id=C.proxyTrunkId WHERE CS.id=$avp(carrierServerId)", "ra");

    if ( $(xavp(ra=>carrierId){s.len}) ) {
        $dlg_var(carrierId) = $xavp(ra=>carrierId);
        $dlg_var(carrierServerId) = $avp(carrierServerId);
        $dlg_var(calculateCost) = $xavp(ra=>calculateCost);
        xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: carrierId: $dlg_var(carrierId) (externallyRated: $xavp(ra=>externallyRated))\n");
    } else {
        xerr("[$dlg_var(cidhash)] SELECT-NEXT-GW: Error obtaining 'carrierId' for carrierServerId '$avp(carrierServerId)'\n");
        send_reply("500", "Server Internal Error");
        exit;
    }

    if ($xavp(ra=>externallyRated) == '1' || $sel(cfg_get.config.cgrates_mode) == 1 || $sht(cgrconn=>cgr) == $null) {
        # 3 exceptional cases:
        # - Externally rated GW
        # - CGRateS is disabled with cgrates_mode
        # - CGRateS is down and call is national
        $dlg_var(cgrid) = $null;
        dlg_set_timeout(MAX_DIALOG_TIMEOUT);
    } else {
        # CGRateS GW
        if ($dlg_var(cgrDeclined) == 'yes') {
            # CGRateS already asked and declined
            route(SELECT_NEXT_GW);
        } else {
            # CGRateS already asked and approved
            $dlg_var(cgrid) = $dlg_var(cgridPersist);
            if ($dlg_var(CgrMaxSessionTime) > 0) {
                dlg_set_timeout($dlg_var(CgrMaxSessionTime));
            }
        }
    }

    if ($xavp(ra=>authNeeded) == 'yes') {
        if ( $(xavp(ra=>authUser){s.len}) ) {
            $avp(auth_user) = $xavp(ra=>authUser);
        } else {
            xwarn("[$dlg_var(cidhash)] SELECT-NEXT-GW: Error obtaining 'provideruser' for carrierServerId '$avp(carrierServerId)'\n");
        }

        if ( $(xavp(ra=>authPassword){s.len}) ) {
            $avp(auth_secret) = $xavp(ra=>authPassword);
        } else {
            xwarn("[$dlg_var(cidhash)] SELECT-NEXT-GW: Error obtaining 'secret' for carrierServerId '$avp(carrierServerId)'\n");
        }
    } else {
        $avp(auth_user) = $null;
        $avp(auth_secret) = $null;
    }

    if ( $(xavp(ra=>fromUser){s.len}) ) {
        $avp(from_user) = $xavp(ra=>fromUser);
    } else {
        $avp(from_user) = $null;
    }

    if ( $(xavp(ra=>fromDomain){s.len}) ) {
        $avp(from_domain) = $xavp(ra=>fromDomain);
    } else {
        $avp(from_domain) = $null;
    }

    $avp(send_pai) = $xavp(ra=>sendPAI);
    $avp(send_rpid) = $xavp(ra=>sendRPID);

    #!ifdef WITH_MULTISOCKET
    if ($xavp(ra=>ip) != $null) {
        $avp(forceIP) = $xavp(ra=>ip);
    } else {
        $avp(forceIP) = $var(trunksAddress);
    }
    # force_send_socket to $avp(forceIP)
    $fs = "udp:" + $avp(forceIP) + ":5060";
    #!endif

    # Reset auth flag
    $avp(auth_done) = '0';

    # Obtain info about selected route (prefix and clid)
    sql_xquery("cb", "SELECT O.prefix, O.forceClid, CONCAT(C.countryCode, O.clid) AS finalClid FROM kam_trunks_lcr_rules KTLR JOIN OutgoingRouting O ON O.id=KTLR.outgoingRoutingId LEFT JOIN Countries C ON C.id=O.clidCountryId WHERE KTLR.id=$avp(lcr_rule_id)", "rb");
    if ( $(xavp(rb=>prefix){s.len})) {
        $dlg_var(route_prefix) = $xavp(rb=>prefix);
        xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: Route prefix: $dlg_var(route_prefix)");
    } else {
        $dlg_var(route_prefix) = $null;
    }

    if ($xavp(rb=>forceClid) == '1') {
        $dlg_var(route_clid) = $xavp(rb=>finalClid);
        xinfo("[$dlg_var(cidhash)] SELECT-NEXT-GW: Route clid: $dlg_var(route_clid)");
    } else {
        $dlg_var(route_clid) = $null;
    }

    # Set failure and branch route
    t_on_failure("MANAGE_FAILURE_GW");
    t_on_branch("MANAGE_BRANCH_GW");
}

route[PARSE_X_HEADERS] {
    # Extract routing tag
    if (is_present_hf("X-Info-RoutingTag")) {
        $dlg_var(routingTag) = $hdr(X-Info-RoutingTag);
        xinfo("[$dlg_var(cidhash)] PARSE-X-HEADERS: 'X-Info-RoutingTag' header found: $dlg_var(routingTag)\n");
    }

    # Extract routing tag Id
    if (is_present_hf("X-Info-RoutingTagId")) {
        $dlg_var(routingTagId) = $hdr(X-Info-RoutingTagId);
        xinfo("[$dlg_var(cidhash)] PARSE-X-HEADERS: 'X-Info-RoutingTagId' header found: $dlg_var(routingTagId)\n");
    }

    # Extract Record header
    if (is_present_hf("X-Info-Record") && $hdr(X-Info-Record) == 'yes') {
        xinfo("[$dlg_var(cidhash)] PARSE-X-HEADERS: 'X-Info-Record' header found (value: yes), call will be recorded\n");
        $avp(recordCall) = 'yes';
    }

    # Extract RetailAccountId for cdr entry
    if (is_present_hf("X-Info-RetailAccountId")) {
        $dlg_var(retailAccountId) = $hdr(X-Info-RetailAccountId);
        xinfo("[$dlg_var(cidhash)] PARSE-X-HEADERS: 'X-Info-RetailAccountId' header found: $dlg_var(retailAccountId)\n");
    }

    # Extract ResidentialDeviceId for cdr entry
    if (is_present_hf("X-Info-ResidentialDeviceId")) {
        $dlg_var(residentialDeviceId) = $hdr(X-Info-ResidentialDeviceId);
        xinfo("[$dlg_var(cidhash)] PARSE-X-HEADERS: 'X-Info-ResidentialDeviceId' header found: $dlg_var(residentialDeviceId)\n");
    }

    # Extract UserId for cdr entry
    if (is_present_hf("X-Info-UserId")) {
        $dlg_var(userId) = $hdr(X-Info-UserId);
        xinfo("[$dlg_var(cidhash)] PARSE-X-HEADERS: 'X-Info-UserId' header found: $dlg_var(userId)\n");
    }

    # Extract FriendId for cdr entry
    if (is_present_hf("X-Info-FriendId")) {
        $dlg_var(friendId) = $hdr(X-Info-FriendId);
        xinfo("[$dlg_var(cidhash)] PARSE-X-HEADERS: 'X-Info-FriendId' header found: $dlg_var(friendId)\n");
    }

    # Extract FaxId for cdr entry
    if (is_present_hf("X-Info-FaxId")) {
        $dlg_var(faxId) = $hdr(X-Info-FaxId);
        xinfo("[$dlg_var(cidhash)] PARSE-X-HEADERS: 'X-Info-FaxId' header found: $dlg_var(faxId)\n");
    }

    # Extract xcallid
    if (is_present_hf("X-Call-Id")) {
        $dlg_var(xcallid) = $hdr(X-Call-Id);
        xnotice("[$dlg_var(cidhash)] PARSE-X-HEADERS: Related leg: $dlg_var(xcallid)\n");
    }

    if ($dlg_var(type) == 'wholesale') return;

    # Extract ddiId for cdr entry
    $var(header) = 'X-Info-DdiId';
    route(PARSE_MANDATORY_X_HEADER);
    xinfo("[$dlg_var(cidhash)] PARSE-X-HEADERS: '$var(header)' header found: $var(header-value)\n");
    $dlg_var(ddiId) = $var(header-value);

    # Extract X-Info-Special header
    if (is_present_hf("X-Info-Special") && $hdr(X-Info-Special) == 'fax') {
        xinfo("[$dlg_var(cidhash)] PARSE-X-HEADERS: 'X-Info-Special' header found (value: fax)\n");
        $avp(fax) = '1';
    }

    # Remove all X headers
    remove_hf_re("^X-");
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if ($(hdr($var(header)){s.len})) {
        $var(header-value) = $hdr($var(header));
    } else {
        xerr("[$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: '$var(header)' not present or not valid, aborting\n");
        send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[TRANSFORMATE_WITHINDLG] {
    if (!is_method("INVITE|UPDATE")) return;
    if (!is_present_hf("P-Asserted-Identity") && !is_present_hf("remote-party-id")) return;

    if ($var(is_from_inside)) {
        route(TRANSFORMATE_OUT);
    } else {
        route(TRANSFORMATE_IN);
    }
}

# Get incoming tranformations (sets tr_* dlg_vars)
route[GET_TRANSFORMATIONS_IN] {
    # Get DDI Providers by DDI and their transformation rules
    sql_query("cb", "SELECT brandId, CONCAT(DP.transformationRuleSetId, 1) AS callee_in, CONCAT(DP.transformationRuleSetId, 0) AS caller_in, CONCAT(DP.transformationRuleSetId, 2) AS caller_out, CONCAT(DP.transformationRuleSetId, 3) AS callee_out, DP.id AS ddiProviderId FROM DDIProviderAddresses DPA INNER JOIN DDIProviders DP ON DPA.ddiProviderId=DP.id JOIN ProxyTrunks PT ON PT.id=DP.proxyTrunkId WHERE DPA.ip='$si' AND PT.ip='$Ri' ORDER BY DP.id ASC", "ra");

    # Found?
    if ($dbr(ra=>rows) == 0) {
        xwarn("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: $si not recognized as a valid DDI Provider, 403 Forbidden\n");
        send_reply("403", "Forbidden");
        exit;
    }

    # Iterate through all matching DDI Providers
    $var(i) = 0;
    $var(found) = 0;
    while ($var(i)<$dbr(ra=>rows)) {
        # Save transformations for further application
        $dlg_var(tr_callee_in) = $dbr(ra=>[$var(i), 1]);
        $dlg_var(tr_caller_in) = $dbr(ra=>[$var(i), 2]);
        $dlg_var(tr_caller_out) = $dbr(ra=>[$var(i), 3]);
        $dlg_var(tr_callee_out) = $dbr(ra=>[$var(i), 4]);
        $dlg_var(ddiProviderId) = $dbr(ra=>[$var(i), 5]);

        # Apply transformations to $rU
        $var(transformation) = $dlg_var(tr_callee_in);
        $var(number) = $rU;
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)

        # Search for DDI in brand
        sql_query("cb", "SELECT companyId, id, ddiProviderId FROM DDIs WHERE DDIE164='$var(transformated)' AND brandId='$dbr(ra=>[$var(i), 0])'", "rb");

        # Found?
        if ($dbr(rb=>rows) > 0) {
            xinfo("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: DDI $rU recognized as $var(transformated) (b$dbr(ra=>[$var(i), 0])c$dbr(rb=>[0, 0])dp$dlg_var(ddiProviderId)), proceed\n");
            $var(found) = 1;
            $dlg_var(ddiId) = $dbr(rb=>[0, 1]);
            if ($dbr(rb=>[0, 2]) != $null && $dbr(rb=>[0, 2]) != $dlg_var(ddiProviderId)) {
                # Matched DDI is linked to a ddiProvider different from the one that matched, override $dlg_var(ddiProviderId) only if source address matches
                $xavp(rc) = $null;
                sql_xquery("cb", "SELECT COUNT(*) AS matchesSrcAddr FROM DDIProviders DP JOIN DDIProviderAddresses DPA ON DPA.ddiProviderId=DP.id WHERE DP.id=$dbr(rb=>[0, 2]) AND DPA.ip='$si'", "rc");
                if ($xavp(rc=>matchesSrcAddr) > 0) {
                    $dlg_var(ddiProviderId) = $dbr(rb=>[0, 2]);
                    xinfo("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: DDI is linked to a ddiProvider that matches source address, update ddiProviderId to $dlg_var(ddiProviderId)\n");
                }
            }
            break;
        }

        # Try next DDI Provider
        $var(i) = $var(i) + 1;
    }

    sql_result_free("ra");
    sql_result_free("rb");

    if ($var(found) == 0) {
        # No candidate succeeded after applying transformations
        xwarn("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: DDI '$rU' not recognized, 404 Not Found");
        send_reply("404", "Not Here");
        exit;
    }
}

# This route apply transformations to rU, PAI and Diversion to E.164
route[TRANSFORMATE_IN] {
    if ($dlg_var(tr_caller_in) != $null) {
        route(GET_CALLER); # Greps caller and sets it in $var(number)
        $var(transformation) = $dlg_var(tr_caller_in);
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        route(SET_CALLER); # Sets caller using $var(transformated) value
        $dlg_var(callerE164) = $var(transformated); # Save for CDR
    }

    if (has_totag()) return; # in-dialog messages only need pai/rpid mangling

    if ($dlg_var(tr_callee_in) != $null) {
        $var(transformation) = $dlg_var(tr_callee_in);
        $var(number) = $rU;
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        $rU = $var(transformated);
    }

    if ($dlg_var(tr_caller_in) != $null) {
        # Apply the same transformation to first Diversion header
        if (is_present_hf("Diversion")) {
            $var(number) = $(di{uri.user});
            if ($var(number) != $null) {
                $avp(reason) = @hf_value.diversion[0].param['reason'];
                if ($avp(reason) == $null) {
                    xinfo("[$dlg_var(cidhash)] TRANSFORMATE-IN: No reason extracted, set 'deflection'\n");
                    $avp(reason) = 'deflection';
                }

                $var(transformation) = $dlg_var(tr_caller_in);
                route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)

                remove_hf_value("Diversion[0]");
                add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $(di{uri.host}));
                $dlg_var(diversion) = $var(transformated); # Save for CDR
            }
        }
    }
}

# Sets caller in $var(number) seeking in PAI/RPID/From (in this order)
route[GET_CALLER] {
    # Where is my caller? PAI/RPID/From?
    if (is_present_hf("P-Asserted-Identity")) {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: PAI present: $(ai{uri.user})\n");
        $var(number) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: RPID present: $(re{uri.user})\n");
        $var(number) = $(re{uri.user});
    } else {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: Nor PAI nor RPID present, only From ($fU)! :(\n");
        $var(number) = $fU;
    }
}

# Sets caller in PAI/RPID/From using $var(transformated) value
route[SET_CALLER] {
    # Initial requests
    if (!has_totag()) {
        if ($var(is_from_inside) == 1) {
            # Initial request to GW need special caller mangling

            # Set caller for carrier
            $var(newfromdomain) = $Ri; # Use bind ip as from domain
            $var(newfromuri) = 'sip:' + $var(transformated) + '@' + $var(newfromdomain);

            # Use PAI?
            remove_hf("P-Asserted-Identity");
            if ($avp(send_pai)) {
                xinfo("[$dlg_var(cidhash)] SET-CALLER: Set PAI to: $var(newfromuri)\n");
                append_hf("P-Asserted-Identity: <$var(newfromuri)>\r\n");
            }

            # Use RPID?
            remove_hf("Remote-Party-ID");
            if ($avp(send_rpid)) {
                xinfo("[$dlg_var(cidhash)] SET-CALLER: Set RPID to: $var(newfromuri)\n");
                append_hf("Remote-Party-ID: <$var(newfromuri)>;privacy=off;screen=no\r\n");
            }

            # Set GW from_user and from_domain if necessary
            if ($avp(from_user) != $null) $var(transformated) = $avp(from_user);
            if ($avp(from_domain) != $null) $var(newfromdomain) = $avp(from_domain);
            $var(newfromuri) = "sip:" + $var(transformated) + '@' + $var(newfromdomain);
            xinfo("[$dlg_var(cidhash)] SET-CALLER: New from: $var(newfromuri)\n");
            uac_replace_from("", "$var(newfromuri)"); # Change From header for GW
        } else {
            # Initial request from GW
            if ($fU != $var(transformated)) {
                $var(newfromuri) = 'sip:' + $var(transformated) + '@' + $fd;
                uac_replace_from("", "$var(newfromuri)"); # Change From header for GW
            }
        }
    }

    # All in-dialog requests + all requests from GWs
    if (($var(is_from_inside) != 1) || has_totag()) {
        if (is_present_hf("P-Asserted-Identity")) {
            if ($(ai{uri.user}) != $var(transformated)) { # If new value differs from previous, change
                remove_hf("P-Asserted-Identity");
                append_hf("P-Asserted-Identity: <sip:$var(transformated)@$(ai{uri.host})>\r\n");
            }
        }

        if (is_present_hf("Remote-Party-ID")) {
            if ($(re{uri.user}) != $var(transformated)) { # If new value differs from previous, change
                remove_hf("Remote-Party-ID");
                append_hf("Remote-Party-ID: <sip:$var(transformated)@$(re{uri.host})>\r\n");
            }
        }
    }
}

route[GET_TRANSFORMATIONS_OUT] {
    if ($dlg_var(bounced) == '1') return; # Skip transformation in bounced calls

    sql_xquery("cb", "SELECT CONCAT(transformationRuleSetId, 0) AS caller_in, CONCAT(transformationRuleSetId, 1) AS callee_in, CONCAT(transformationRuleSetId, 2) AS caller_out, CONCAT(transformationRuleSetId, 3) AS callee_out FROM Carriers WHERE id=$dlg_var(carrierId)", "ra");

    $dlg_var(tr_caller_in) = $xavp(ra=>caller_in);
    $dlg_var(tr_callee_in) = $xavp(ra=>callee_in);
    $dlg_var(tr_caller_out) = $xavp(ra=>caller_out);
    $dlg_var(tr_callee_out) = $xavp(ra=>callee_out);

    return;
}

# Transformate all numbers to GW format
route[TRANSFORMATE_OUT] {
    if ($dlg_var(bounced) == '1') return; # Skip transformation in bounced calls

    if ($dlg_var(route_clid) == $null) {
        route(GET_CALLER); # Greps caller and sets it in $var(number)
    } else {
        xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: Route force clid '$dlg_var(route_clid)'");
        $var(number) = $dlg_var(route_clid);
    }
    $var(transformation) = $dlg_var(tr_caller_out);
    route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
    route(SET_CALLER);

    # in-dialog messages only need pai/rpid mangling
    if (has_totag()) return;

    # Transformate callee_out
    $var(transformation) = $dlg_var(tr_callee_out);
    $var(number) = $rU;
    route(APPLY_TRANSFORMATION);
    $rU = $var(transformated);
    if ($dlg_var(route_prefix) != $null) {
        $rU = $dlg_var(route_prefix) + $rU;
        xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: Add route prefix '$dlg_var(route_prefix)', new to: $ru");
    }
    uac_replace_to("$ru");

    # Transformate first Diversion header
    if (is_present_hf("Diversion")) {
        $var(number) = $(di{uri.user});
        if ($var(number) != $null) {
            $avp(reason) = @hf_value.diversion[0].param['reason'];
            if ($avp(reason) == $null) {
                xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: No reason extracted, set 'deflection'\n");
                $avp(reason) = 'deflection';
            }

            $var(transformation) = $xavp(ra=>caller_out);
            route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)

            remove_hf_value("Diversion[0]");
            if ($dlg_var(companyDomain) != $null) {
                add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $dlg_var(companyDomain));
            } else {
                add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $(di{uri.host}));
            }
        }
    }
}

# Apply $var(transformation) transformations (if set) to $var(number)
# Sets result in $var(transformated)
route[APPLY_TRANSFORMATION] {
    $var(transformated) = $var(number);
    $avp(appliedrule) = $null;

    dp_translate("$(var(transformation){s.int})", "$var(number)/$var(transformated)");

    # If no rule applied, re-set value
    if ($avp(appliedrule) == $null)
        $var(transformated) = $var(number);

    xinfo("[$dlg_var(cidhash)] APPLY-TRANSFORMATION: '$var(number)' -> '$var(transformated)' (applied rule: '$avp(appliedrule)')\n");
}

route[GET_INFO_FROM_MATCHED_DDI] {
    sql_xquery("cb", "SELECT c.mediaRelaySetsId, c.maxCalls AS maxCallsCompany, b.maxCalls AS maxCallsBrand, d.recordCalls, c.distributeMethod, AppS.ip AS asAddress, d.routeType, d.residentialDeviceId, d.retailAccountId, d.faxId FROM DDIs d JOIN Companies c ON d.companyId=c.id LEFT JOIN ApplicationServers AppS ON AppS.id=c.applicationServerId JOIN Brands b ON c.brandId=b.id WHERE d.DDIE164='$rU'", "ra");

    # Matched DDI
    $dlg_var(maxCallsCompany) = $xavp(ra=>maxCallsCompany);
    $dlg_var(maxCallsBrand) = $xavp(ra=>maxCallsBrand);

    # Recording settings
    if ($xavp(ra=>recordCalls) == 'inbound' || $xavp(ra=>recordCalls) == 'all') {
        $avp(recordCall) = 'yes';
    }

    # Distribute method
    $dlg_var(distributeMethod) = $xavp(ra=>distributeMethod);
    $avp(asAddress) = $xavp(ra=>asAddress);

    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);

    # Save endpointId for CDR accounting
    if ($xavp(ra=>routeType) == 'retail') {
        if ($xavp(ra=>retailAccountId) != $null) {
            $dlg_var(retailAccountId) = $xavp(ra=>retailAccountId);
        } else {
            xwarn("[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: $rU is not routed to any retail account\n");
            send_reply("404", "Not Here");
            exit;
        }
    } else if ($xavp(ra=>routeType) == 'residential') {
        if ($xavp(ra=>residentialDeviceId) != $null) {
            $dlg_var(residentialDeviceId) = $xavp(ra=>residentialDeviceId);
        } else {
            xwarn("[$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: $rU is not routed to any residential device\n");
            send_reply("404", "Not Here");
            exit;
        }
    } else if ($xavp(ra=>routeType) == 'fax') {
        $dlg_var(faxId) = $xavp(ra=>faxId);
    }
}

route[GET_INFO_FROM_COMPANY] {
    sql_xquery("cb", "SELECT D.domain, C.billingMethod, C.mediaRelaySetsId, C.maxCalls AS maxCallsCompany, B.maxCalls AS maxCallsBrand FROM Companies C LEFT JOIN Domains D ON C.domainId=D.id JOIN Brands B ON C.brandId=B.id WHERE C.id='$dlg_var(companyId)'", "ra");

    $dlg_var(cgrReqType) = '*' + $xavp(ra=>billingMethod);
    $dlg_var(companyDomain) = $xavp(ra=>domain);
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
    $dlg_var(maxCallsCompany) = $xavp(ra=>maxCallsCompany);
    $dlg_var(maxCallsBrand) = $xavp(ra=>maxCallsBrand);

    return;
}

# Handle within-dialog messages
route[WITHINDLG] {
    if (!$dlg_var(confirmed) && is_method("UPDATE|INVITE")) drop;

    # REFER not allowed
    if (is_method("REFER")) {
        xerr("[$dlg_var(cidhash)] WITHINDLG: 'REFER' not supported\n");
        send_reply("405","Method Not Allowed");
        exit;
    }

    route(TRANSFORMATE_WITHINDLG);

    # Fix overridden R-URI if needed
    if (!$var(is_from_inside) && $dlg_var(contact) != $null && uri != $dlg_var(contact)) {
        xwarn("[$dlg_var(cidhash)] WITHINDLG: Fix overridden contact ($ru -> $dlg_var(contact))\n");
        $ru = $dlg_var(contact);
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        }
        route(RTPENGINE);
        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RTPENGINE);
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        send_reply("403","Not here");
    }
}

route[DISPATCH] {
    if ($dlg_var(type) == 'retail') {
        # Route to KamUsers
        xinfo("[$dlg_var(cidhash)] DISPATCH: Calling to retail account, route to KamUsers\n");
        route(SETUP_KAMUSERS_CALL);
        return;
    }

    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Static routing to specific AS?
    if ($dlg_var(distributeMethod) == 'static') {
        $du = "sip:" + $avp(asAddress) + ":6060";
        xinfo("[$dlg_var(cidhash)] DISPATCH: Company has static routing enabled\n");
    } else {
        if ($dlg_var(distributeMethod) == 'hash') {
            $avp(hash) = $dlg_var(companyId);
            # hash over $avp(hash)
            xinfo("[$dlg_var(cidhash)] DISPATCH: Dispatch hashing '$avp(hash)'\n");
            $var(alg) = 7;
        } else {
            # round robin dispatching on ASs (distributeMethod == 'rr')
            xinfo("[$dlg_var(cidhash)] DISPATCH: dispatch to any AS (round robin)\n");
            $var(alg) = 4;
        }

        if(!ds_select_dst("1", "$var(alg)")) {
            xerr("[$dlg_var(cidhash)] DISPATCH: No destination found\n");
            send_reply("404", "No destination");
            exit;
        } else {
            xinfo("[$dlg_var(cidhash)] DISPATCH: $avp(AVP_CNT) destination(s) found\n");
        }
    }

    t_on_failure("MANAGE_FAILURE_AS");
    xinfo("[$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du>\n");
}

route[SETUP_KAMUSERS_CALL] {
    # No AS in retail calls, send to kamusers
    $du = "sip:users.ivozprovider.local";

    # Insert X-Info headers for kamusers
    insert_hf("X-Info-BrandId: $dlg_var(brandId)\r\n");
    insert_hf("X-Info-CompanyId: $dlg_var(companyId)\r\n");
    insert_hf("X-Info-Type: $dlg_var(type)\r\n");
    insert_hf("X-Info-Callee: $rU\r\n");

    # Check DDI is routed to a retail account
    $xavp(ra) = $null;
    sql_xquery("cb", "SELECT RA.name AS username, DS.domain AS domain FROM DDIs D INNER JOIN RetailAccounts RA ON D.retailAccountId=RA.id INNER JOIN Domains DS ON RA.domainId=DS.id WHERE DDIE164='$rU'", "ra");

    # Update $ru using retail account username@domain
    $ru = "sip:" + $xavp(ra=>username) + '@' + $xavp(ra=>domain);

    # Make To header equal to R-URI
    uac_replace_to("$ru");
}

# Relay request
route[RELAY] {
    # Route bounced calls to myself
    if ($dlg_var(bounced) == '1' && !has_totag()) {
        xinfo("[$dlg_var(cidhash)] RELAY: Bounce call to myself\n");
        $du = "sip:trunks.ivozprovider.local:" + SIP_PORT;
        $rd = "trunks.ivozprovider.local";
        $dlg_var(carrierId) = $null;
        $dlg_var(calculateCost) = "0";
    }

    if ($(du{uri.host}) != $null) {
        xinfo("[$dlg_var(cidhash)] RELAY: Relaying to $(du{uri.host}) (du, $dP)\n");
    } else {
        xinfo("[$dlg_var(cidhash)] RELAY: Relaying to $(ru{uri.host}) (ru)\n");
    }

    # Common for every reply
    t_on_reply("MANAGE_REPLY");

    #!ifdef WITH_REALTIME
    if (is_request() && is_method("INVITE") && !has_totag()) {
        $var(rtEvent) = "Trying";
        route(REALTIME);
    }
    #!endif

    if (!t_relay())
        sl_reply_error();

    exit;
}

# This route sets following dlg_vars: brandId, companyId, type
route[CLASSIFY] {
    if ($var(is_from_inside) == 1) {
        $var(header) = 'X-Info-BrandId';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(brandId) = $var(header-value);

        $var(header) = 'X-Info-CompanyId';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(companyId) = $var(header-value);

        $var(header) = 'X-Info-Type';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(type) = $var(header-value);

        # Add to profiles
        set_dlg_profile("outboundCallsCompany", "$dlg_var(companyId)");
        set_dlg_profile("outboundCallsBrand", "$dlg_var(brandId)");
    } else {
        sql_xquery("cb", "SELECT C.brandId, C.id AS companyId, C.type FROM DDIs D JOIN Companies C ON D.companyId=C.id WHERE DDIE164='$rU'", "rp");
        $dlg_var(brandId) = $xavp(rp=>brandId);
        $dlg_var(companyId) = $xavp(rp=>companyId);
        $dlg_var(type) = $xavp(rp=>type);

        if ($dlg_var(type) == 'wholesale') {
            xerr("[$dlg_var(cidhash)] CLASSIFY: Wholesale inbound call, 501\n");
            send_reply("501", "Not Implemented [WI]");
            exit;
        }

        # Add to profiles
        set_dlg_profile("inboundCallsCompany", "$dlg_var(companyId)");
        set_dlg_profile("inboundCallsBrand", "$dlg_var(brandId)");
    }

    # Check type has one of the supported values
    if ($dlg_var(type) != 'vpbx' && $dlg_var(type) != 'residential' && $dlg_var(type) != 'wholesale' && $dlg_var(type) != 'retail') {
        xerr("[$dlg_var(cidhash)] CLASSIFY: Unsupported type '$dlg_var(type)'\n");
        send_reply("500", "Internal Server Error [UT]");
        exit;
    }

    # Set parsed default value
    $dlg_var(parsed) = '0';

    xinfo("[$dlg_var(cidhash)] CLASSIFY: '$dlg_var(type)' call (b$dlg_var(brandId):c$dlg_var(companyId))");

}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    route(GET_CALLER);
    $dlg_var(caller) = $var(number);

    if ($var(is_from_inside) == 1) {
        $dlg_var(direction) = 'outbound';

        if (is_present_hf("Diversion"))
            $dlg_var(diversion) = $(di{uri.user});
    } else {
        $dlg_var(direction) = 'inbound';
        if ($dlg_var(callerE164) != $null) {
            $dlg_var(caller) = $dlg_var(callerE164);
        }
    }

    $dlg_var(callid) = $ci;
    $dlg_var(callee) = $rU;
}

route[SAVE_CONTACT] {
    if (!is_present_hf("Contact") || $dlg_var(contact) != $null) return;

    if ($ct =~ "<.*>") {
        # Contact has < >
        $var(contact) = $(ct{s.select,0,>});
        $var(contact) = $(var(contact){s.select,1,<});
    } else {
        $var(contact) = $ct;
    }

    # Save inside contact in $dlg_var(contact)
    $dlg_var(contact) = $var(contact);
}

# This route sets $avp(carrier) and $avp(carrierServer) of given $avp(gateway)
route[GET_INFO_FROM_GATEWAY] {
    $xavp(gw) = $null;
    sql_xquery("cb", "SELECT CS.carrierId, CS.id AS carrierServerId FROM kam_trunks_lcr_gateways KTLG JOIN CarrierServers CS ON CS.id=KTLG.carrierServerId WHERE KTLG.id=$avp(gateway)", "gw");
    $avp(carrier) = $xavp(gw=>carrierId);
    $avp(carrierServer) = $xavp(gw=>carrierServerId);
}

#!ifdef WITH_REALTIME
route[REALTIME] {
    # Avoid going backwards or repeating state (Trying > Proceeding > Early > Confirmed > Terminated)
    if ($dlg_var(lastCallState) != $null) {
        switch ($var(rtEvent)) {
            case "Trying":
                return;
            case "Proceeding":
                if ($(dlg_var(lastCallState){s.int}) >= 1) return;
                $dlg_var(lastCallState) = "1";
                break;
            case "Early":
                if ($(dlg_var(lastCallState){s.int}) >= 2) return;
                $dlg_var(lastCallState) = "2";
                break;
            case "Confirmed":
                if ($(dlg_var(lastCallState){s.int}) >= 3) return;
                $dlg_var(lastCallState) = "3";
                break;
            case "Terminated":
                if ($(dlg_var(lastCallState){s.int}) >= 4) return;
                $dlg_var(lastCallState) = "4";
                break;
        };
    }

    # Reset JSON value
    $var(rtValue) = 0;

    # Common fields
    jansson_set("string", "Event", "$var(rtEvent)", "$var(rtValue)");
    jansson_set("integer", "Time", "$TS", "$var(rtValue)");
    jansson_set("string", "Call-ID", "$dlg_var(callid)", "$var(rtValue)");

    if ($var(rtEvent) == 'Trying') {
        route(RT_NEWCALL);
        $dlg_var(lastCallState) = "0";
    }

    # Publish to redis
    if ($dlg_var(rtChannel) != $null) {
        jansson_set("string", "ID", "$dlg_var(rtId)", "$var(rtValue)");
        if (redis_cmd("realtime", "PUBLISH %s %s", "$dlg_var(rtChannel)", "$var(rtValue)", "r")) {
            xinfo("[$dlg_var(cidhash)] REALTIME: $dlg_var(rtChannel) -> $var(rtValue)");
        } else {
            xwarn("[$dlg_var(cidhash)] REALTIME: $dlg_var(rtChannel) -> $var(rtValue)");
        }
    }
}

route[RT_NEWCALL] {
    # Set brand, company and direction
    sql_xquery("cb", "SELECT C.name AS companyName, B.name AS brandName FROM Companies C JOIN Brands B ON B.id=C.brandId WHERE C.id='$dlg_var(companyId)'", "names");
    jansson_set("string", "Brand", "$xavp(names=>brandName)", "$var(rtValue)");
    jansson_set("string", "Company", "$xavp(names=>companyName)", "$var(rtValue)");
    jansson_set("string", "Direction", "$dlg_var(direction)", "$var(rtValue)");

    # Set rtChannel and carrier / ddiProvider
    if($dlg_var(direction) == 'outbound') {
        if ($dlg_var(carrierId) != $null) {
            sql_xquery("cb", "SELECT name FROM Carriers WHERE id=$dlg_var(carrierId)", "cs");
            $dlg_var(rtChannel) = 'trunks' + ':b' + $dlg_var(brandId) + ':c' + $dlg_var(companyId) + ':cr' + $dlg_var(carrierId) + ':' + $ci;
            jansson_set("string", "Carrier", "$xavp(cs=>name)", "$var(rtValue)");
        } else {
            $dlg_var(rtChannel) = 'trunks' + ':b' + $dlg_var(brandId) + ':c' + $dlg_var(companyId) + ':cr0:' + $ci;
            jansson_set("string", "Carrier", "", "$var(rtValue)");
        }
    } else {
        if ($dlg_var(ddiProviderId) != $null) {
            sql_xquery("cb", "SELECT name FROM DDIProviders WHERE id=$dlg_var(ddiProviderId)", "dp");
            $dlg_var(rtChannel) = 'trunks' + ':b' + $dlg_var(brandId) + ':c' + $dlg_var(companyId) + ':dp' + $dlg_var(ddiProviderId) + ':' + $ci;
            jansson_set("string", "DdiProvider", "$xavp(dp=>name)", "$var(rtValue)");
        } else {
            $dlg_var(rtChannel) = 'trunks' + ':b' + $dlg_var(brandId) + ':c' + $dlg_var(companyId) + ':dp0:' + $ci;
            jansson_set("string", "DdiProvider", "", "$var(rtValue)");
        }
    }

    # Set caller and callee
    jansson_set("string", "Caller", "$dlg_var(caller)", "$var(rtValue)");
    jansson_set("string", "Callee", "$dlg_var(callee)", "$var(rtValue)");

    # Calculate session-id
    $dlg_var(rtId) = $(dlg_var(rtChannel){s.md5}{s.substr,0,8});
}
#!endif

# Reply generic route (all replies goes through this route)
onreply_route {
    xnotice("[$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    route(IS_FROM_INSIDE);
}

onreply_route[LCR_PING] {
    if (t_check_status("403,404,405,501") || t_check_status("2[0-9]{2}")) {
        xinfo("Activating carrier server $avp(carrierServer) (carrier: $avp(carrier))");
    } else {
        xwarn("Not activating carrier server $avp(carrierServer) (carrier: $avp(carrier)) as not valid response received");
    }
}

# Common for both AS and GW replies
onreply_route[MANAGE_REPLY] {
    route(TRANSFORMATE_WITHINDLG);

    # Manage RTP
    route(RTPENGINE);

    if (t_check_status("2[0-9]{2}") && ($var(is_from_inside) == 1)) {
        route(SAVE_CONTACT);
    }

    #!ifdef WITH_REALTIME
    if (is_method("INVITE") && t_check_status("1[0-9]{2}")) {
        if (has_totag()) {
            $var(rtEvent) = "Early";
        } else {
            $var(rtEvent) = "Proceeding";
        }
        route(REALTIME);
    }
    #!endif
}

# Manage failure replies (only for failure response codes, executed after previous 2 routes)

# Failure route for initial transactions to GW
failure_route[MANAGE_FAILURE_GW] {
    if(!t_check_status("(401)|(407)")) {
        xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    }

    route(IS_FROM_INSIDE);

    if (t_is_canceled()) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: t_is_canceled, exit here\n");
        exit;
    }

    if (t_check_status("(401)|(407)") && $avp(auth_done) != '1') {
        # Get ready for SIP auth
        #   username:  $avp(auth_user) set in SELECT-NEXT-GW
        #   password:  $avp(auth_secret) from DB below
        #   realm:     take it from 401/407 leaving it empty
        $avp(auth_realm) = '';

        # $avp(auth_secret) is available?
        if (is_avp_set("$avp(auth_secret)")) {
            # Sends INVITE with AUTH (and adapts CSeq)
            uac_auth();
            $avp(auth_done) = '1'; # Set avp to avoid using invalid credentials more than once

            # Restore rU as it will be transformed again
            $rU = $avp(ruri_user_avp);

            #!ifdef WITH_MULTISOCKET
            $fs = "udp:" + $avp(forceIP) + ":5060"; # Reset force_socket again
            #!endif

            t_on_failure("MANAGE_FAILURE_GW");
            t_on_branch("MANAGE_BRANCH_GW");
            route(RELAY);
        } else {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: No secret available for $avp(newfrom), try another gw\n");
        }
    } else if (t_check_status("(401)|(407)") && $avp(auth_done) == '1') {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Invalid credentials already used\n");
    } else if (t_check_status("480|486")) {
        xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Forward response downstream (reply code: $T_reply_code)\n");
        exit;
    } else if (t_check_status("422")) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Session Interval Too Small, forward to AS (reply code: $T_reply_code)\n");
        exit;
    } else if (t_check_status("408") && t_branch_timeout() && !$xavp(OutgoingRouting=>stopper)) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code: Inactivate carrier server $dlg_var(carrierServerId) (carrier: $dlg_var(carrierId)) (no reply received)\n");
        inactivate_gw(); # Inactivate GW temporally (until it answers OPTIONS)
    } else if (t_check_status("3[0-9]{2}")) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code: Not allowed from GW\n");
    }

    xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Failure using carrier '$dlg_var(carrierId)' to place a call (reply code: $T_reply_code)\n");

    xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Try next GW\n");
    #!ifdef WITH_REALTIME
    $var(rtEvent) = 'Terminated';
    route(REALTIME);
    #!endif
    route(SELECT_NEXT_GW);
    route(RELAY);
}

# Failure route for initial transactions to AS
failure_route[MANAGE_FAILURE_AS] {
    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(IS_FROM_INSIDE);

    if (t_is_canceled()) {
        xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    # Avoid failover for static distribute method
    if ($dlg_var(distributeMethod) == 'static') exit;

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS '$avp(AVP_DST)' as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
        } else {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Branch route for transactions to GW (transformate here so that eventual failure_route gets the unmodified message)
branch_route[MANAGE_BRANCH_GW] {
    route(GET_TRANSFORMATIONS_OUT);
    route(TRANSFORMATE_OUT);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    #!ifdef WITH_REALTIME
    $var(rtEvent) = 'Confirmed';
    route(REALTIME);
    #!endif

    if ($dlg_var(direction) == 'outbound') {
        if ($dlg_var(cgrid) == $null) {
            xinfo("[$dlg_var(cidhash)] No cgrid, skip rating logic");
            return;
        }
        route(CGR_CALL_START);
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    if ($dlg_var(direction) == 'inbound') {
        if ($sht(dmq=>$ci::user) != $null) {
            $dlg_var(userId) = $sht(dmq=>$ci::user);
            xinfo("[$dlg_var(cidhash)] Received via DMQ: userId => $dlg_var(userId)");
        }

        if ($sht(dmq=>$ci::friend) != $null) {
            $dlg_var(friendId) = $sht(dmq=>$ci::friend);
            xinfo("[$dlg_var(cidhash)] Received via DMQ: friendId => $dlg_var(friendId)");
        }
    }

    #!ifdef WITH_REALTIME
    $var(rtEvent) = 'Terminated';
    route(REALTIME);
    #!endif

    if ($dlg_var(cgrid) == $null) {
        xinfo("[$dlg_var(cidhash)] No cgrid, skip rating logic");
        return;
    }
    route(CGR_CALL_END);
}

# Executed when dialog is not established
event_route[dialog:failed] {
    #!ifdef WITH_REALTIME
    $var(rtEvent) = 'Terminated';
    route(REALTIME);
    #!endif
}

# Executed for request generated by Kamailio
event_route[tm:local-request] {
    xnotice("Kamailio generated request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");

    # OPTIONS (ping inactive carrier server)
    if (is_method("OPTIONS") && $fU == 'lcr') {
        $avp(gateway) = $hdr(X-Info-Gateway);
        route(GET_INFO_FROM_GATEWAY);
        remove_hf('X-Info-Gateway');

        xinfo("Ping inactive carrier server $avp(carrierServer) (carrier: $avp(carrier))");
        t_on_reply("LCR_PING");
    }

    # BYE (CGRateS sent CGR_SESSION_DISCONNECT or dlg_timeout)
    if (is_method("BYE")) {
        append_hf("Hint: credit expired\r\n");

        if ($(ru{uri.host}) == $(dlg_var(contact){uri.host})) {
            # Kamailio generated BYE to non-carrier side needs contact fixing
            $ru = $dlg_var(contact);
        }
    }

    # UACREG sends REGISTER requests whose Contact domain must be adapted
    if (is_method("REGISTER")) {
        #!ifdef WITH_MULTISOCKET
        $var(tmp1) = $(ct{s.rm,<}); # Remove initial < from Contact header
        $var(tmp2) = $(var(tmp1){s.rm,>}); # Remove final > from Contact header
        $var(contactUsername) = $(var(tmp2){uri.user}); # Extract contact Username

        sql_xquery("cb", "SELECT PT.ip FROM kam_trunks_uacreg KTU JOIN DDIProviderRegistrations DPR ON DPR.id=KTU.ddiProviderRegistrationId JOIN DDIProviders DP ON DP.id=DPR.ddiProviderId LEFT JOIN ProxyTrunks PT ON PT.id=DP.proxyTrunkId WHERE KTU.l_uuid='$var(contactUsername)'", "uacreg");
        if ($xavp(uacreg=>ip) != $null) {
            $var(forceIP) = $xavp(uacreg=>ip);
        } else {
            $var(forceIP) = $var(trunksAddress);
        }
        # force_send_socket to $var(forceIP) for outgoing local-request $rm to '$fu'
        $fs = "udp:" + $var(forceIP) + ":5060";
        subst_hf("Contact", "/reg_contact_addr/$var(forceIP):5060/", "a");
        #!else
        subst_hf("Contact", "/reg_contact_addr/$sndfrom(ip):$sndfrom(port)/", "a");
        #!endif
    }
}

onsend_route {
    if (is_method("ACK")) $dlg_var(confirmed) = '1';
}

route[RTPENGINE] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;
    if (is_method("ACK") && !has_body("application/sdp")) return;
    if ($dlg_var(skipMediaRelay) == 'yes') return;

    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        set_rtpengine_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    $var(rtpengine_opts) = 'replace-session-connection replace-origin ICE=remove RTP/AVP asymmetric trust-address';

    xinfo("[$dlg_var(cidhash)] RTPENGINE: rtpengine_manage [$var(rtpengine_opts)]\n");
    rtpengine_manage("$var(rtpengine_opts)");

    route(RECORD);
}

route[RECORD] {
    if ($dlg_var(noRecording)) return;
    if ($dlg_var(recordingCall) == 'yes') return;
    if ($avp(recordCall) != 'yes') return;

    # First 200 OK to initial INVITE
    if (is_reply() && t_check_status("2[0-9]{2}")) {
        xinfo("[$dlg_var(cidhash)] RTPENGINE: Start recording this call ('$rs $rr' for initial $rm)\n");
        start_recording();
        $dlg_var(recordingCall) = 'yes'; # Save to avoid start_recording twice if retrans
    }
}

route[CONTROL_MAXCALLS] {
    if (!get_profile_size("activeCallsCompany", "$dlg_var(companyId)", "$avp(activeCallsCompany)")) {
        xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany) calls (error obtaining value)\n");
        if ($dlg_var(maxCallsCompany) > 0) {
            xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Dropping call for security\n");
            send_reply("500", "Internal Server Error [MC]");
            exit;
        }
    }

    if (!get_profile_size("activeCallsBrand", "$dlg_var(brandId)", "$avp(activeCallsBrand)")) {
        xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand) calls (error obtaining value)\n");
        if ($dlg_var(maxCallsBrand) > 0) {
            xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Dropping call for security\n");
            send_reply("500", "Internal Server Error [MC]");
            exit;
        }
    }

    $var(maxcalls_exceeded) = 0;
    if ($dlg_var(maxCallsBrand) > 0 && $avp(activeCallsBrand) >= $dlg_var(maxCallsBrand)) {
        xwarn("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Call NOT allowed for brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand)\n");
        $var(maxcalls_exceeded) = 1;
    } else if ($dlg_var(maxCallsCompany) > 0 && $avp(activeCallsCompany) >= $dlg_var(maxCallsCompany)) {
        xwarn("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Call NOT allowed for company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany)\n");
        $var(maxcalls_exceeded) = 1;
    } else {
        xinfo("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Call ALLOWED for brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand) - company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany)\n");
        set_dlg_profile("activeCallsCompany", "$dlg_var(companyId)");
        set_dlg_profile("activeCallsBrand", "$dlg_var(brandId)");
    }

    if ($var(maxcalls_exceeded)) {
        if ($var(is_from_inside)) {
            send_reply("403", "Maxcalls exceeded");
        } else {
            send_reply("486", "Busy");
        }

        exit;
    }
}

# This route sets $var(is_within_country) to 1 for within country calls
route[IS_WITHIN_COUNTRY] {
    $var(is_within_country) = 0;

    sql_query("cb", "SELECT countryCode FROM Companies C JOIN Countries CS ON C.countryId=CS.id WHERE C.id=$dlg_var(companyId)", "ra");

    if ($dbr(ra=>rows) > 0) {
        $var(countryCode) = $dbr(ra=>[0, 0]);
        if ($(rU{s.substr,0,$(var(countryCode){s.len})}) == $var(countryCode)) {
            xinfo("[$dlg_var(cidhash)] IS-WITHIN-COUNTRY: '$rU' matches company's country code ($var(countryCode))\n");
            $var(is_within_country) = 1;
        } else {
            xinfo("[$dlg_var(cidhash)] IS-WITHIN-COUNTRY: '$rU' DOES NOT match company's country code ($var(countryCode))\n");
        }
    } else {
        xinfo("[$dlg_var(cidhash)] IS-WITHIN-COUNTRY: company$dlg_var(companyId) without country code\n");
    }

    sql_result_free("ra");
}

#################################################
# --- Kamailio-CGRateS related route blocks --- #
#################################################

# Detect presence of at least one connection with CGRates
event_route[evapi:connection-new] {
    $sht(cgrconn=>cgr) = $evapi(srcaddr) + ":" + $evapi(srcport);
    xnotice("Connection with CGrates established ($sht(cgrconn=>cgr))!!\n");
}

event_route[evapi:connection-closed] {
    xerr("Connection with CGrates closed!!\n");
    $sht(cgrconn=>cgr) = $null;
}

# Send AUTH_REQUEST to CGRateS
route[CGRATES_AUTH_REQUEST] {
    # Auth INVITEs with CGRateS
    if $sht(cgrconn=>cgr) == $null {
        xerr("[$dlg_var(cidhash)] CGRATES-AUTH-REQUEST: Charging controller unreachable");
        return;
    }

    $dlg_var(cgrTenant) = 'b' + $dlg_var(brandId);
    $dlg_var(cgrAccount) = 'c' + $dlg_var(companyId);
    $dlg_var(cgrSubject) = 'c' + $dlg_var(companyId);
    if ($dlg_var(routingTagId) != $null) {
        $dlg_var(cgrSubject) = $dlg_var(cgrSubject) + 'rt' + $dlg_var(routingTagId);
    }
    if ($dlg_var(cgrDestination) == $null) $dlg_var(cgrDestination) = $rU;
    $dlg_var(setupTime) = $TS;

    xinfo("[$dlg_var(cidhash)] CGRATES-AUTH-REQUEST: Ask CGRates whether call is granted ($dlg_var(cgrTenant):$dlg_var(cgrSubject):$dlg_var(cgrDestination):$dlg_var(cgrReqType))");

    evapi_async_relay("{\"event\":\"CGR_AUTH_REQUEST\",
            \"callid\":\"$dlg(callid)\",
            \"from_tag\":\"$dlg(from_tag)\",
            \"tr_index\":\"$T(id_index)\",
            \"tr_label\":\"$T(id_label)\",
            \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
            \"cgr_account\":\"$dlg_var(cgrAccount)\",
            \"cgr_subject\":\"$dlg_var(cgrSubject)\",
            \"cgr_reqtype\":\"$dlg_var(cgrReqType)\",
            \"cgr_destination\":\"$dlg_var(cgrDestination)\",
            \"cgr_setuptime\":\"$dlg_var(setupTime)\"}");

    # Do not continue route script, transaction will be processed when API answers
    exit;
}

event_route[evapi:message-received] {
    json_get_field("$evapi(msg)", "Event", "$var(Event)");
    route($(var(Event){s.rm,"})); # String characters are kept by json_get_field, remove them here
    # Message received from CGrates, continue in CGR_AUTH_REPLY
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp == RPC_PORT) {
        if ($sel(cfg_get.dolog.rpc)) xinfo("HTTP request from $si:$sp on $Rp, dispatch $hu command\n");

        if ($hu == "/endCompanyCalls") {
            route(END_COMPANY_CALLS);
        } else {
            jsonrpc_dispatch();
        }
    } else {
        xwarn("HTTP(S) request received on $Rp, port not allowed\n");
        xhttp_reply("403", "Forbidden", "", "");
    }

    exit;
}

route[END_COMPANY_CALLS] {
    sql_query("cb", "SELECT brandId, id FROM Companies", "ra");
    $var(k) = 0;
    while ($var(k) < $dbr(ra=>rows)) {
        $var(brandId) = $dbr(ra=>[$var(k), 0]);
        $var(companyId) = $dbr(ra=>[$var(k), 1]);
        $var(regexp) = "ID\":\"b" + $var(brandId) + ':c' + $var(companyId) + '"';
        if ($mb =~ $var(regexp)) {
            jsonrpc_exec('{"jsonrpc": "2.0", "method": "dlg.profile_end", "params": ["activeCallsCompany", $var(companyId)], "id": 1}');
            xinfo("jsonrpc response code: $jsonrpl(code) - the body is: $jsonrpl(body)\n");
            break;
        }

        $var(k) = $var(k) + 1;
    }

    sql_result_free("ra");

    xhttp_reply("200", "OK", "text/html", "<html><body>Dialogs of company $var(companyId) ended</body></html>");
}

route[CGR_AUTH_REPLY] {
    json_get_field("$evapi(msg)", "TransactionIndex", "$var(TransactionIndex)");
    json_get_field("$evapi(msg)", "TransactionLabel", "$var(TransactionLabel)");
    json_get_field("$evapi(msg)", "MaxSessionTime", "$var(MaxSessionTime)");
    json_get_field("$evapi(msg)", "Suppliers", "$var(Suppliers)");
    json_get_field("$evapi(msg)", "ResourceAllowed", "$var(CGRResourceAllowed)");
    json_get_field("$evapi(msg)", "CgrId", "$var(cgrid)");
    json_get_field("$evapi(msg)", "Error", "$var(CgrError)");
    $var(id_index) = $(var(TransactionIndex){s.int});
    $var(id_label) = $(var(TransactionLabel){s.int});
    $var(CgrMaxSessionTime) = $(var(MaxSessionTime){s.int});
    $var(CgrSuppliers) = $(var(Suppliers){s.rm,"});
    $var(CGRResourceAllowed) = $(var(CGRResourceAllowed){s.rm,"});
    $var(CgrError) = $(var(CgrError){s.rm,"});

    # API response parsed, continue processing transaction in CGRATES_AUTH_REPLY
    t_continue("$var(id_index)", "$var(id_label)", "CGRATES_AUTH_REPLY"); # Unpark the transaction
}

route[CGRATES_AUTH_REPLY] {
    route(IS_FROM_INSIDE);

    # Save cgrid in acc cdrs
    $dlg_var(cgridPersist) = $(var(cgrid){s.rm,"});
    $dlg_var(CgrMaxSessionTime) = $var(CgrMaxSessionTime);

    if ($var(CgrError) != "") {
        xerr("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: $var(CgrError)");
        $dlg_var(cgrDeclined) = "yes";
    } else if ($var(CGRResourceAllowed) == "false") {
        xerr("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Resource not allowed");
        $dlg_var(cgrDeclined) = "yes";
    } else if ($var(CgrMaxSessionTime) == 0) {
        xwarn("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Insufficient credit");
        $dlg_var(cgrDeclined) = "yes";
    } else {
        xinfo("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Max-session-time: $var(CgrMaxSessionTime)");
    }

    route(SELECT_NEXT_GW);
    route(RELAY);
}

# Inform CGRateS about CALL_START (start prepaid sessions loops)
route[CGR_CALL_START] {
    if $sht(cgrconn=>cgr) == $null {
        xerr("[$dlg_var(cidhash)] CGR-CALL-START: Charging controller unreachable");
        return;
    }

    xnotice("[$dlg_var(cidhash)] CGR-CALL-START: Warn CGRates that call is started");

    evapi_relay("{\"event\":\"CGR_CALL_START\",
               \"callid\":\"$dlg(callid)\",
               \"from_tag\":\"$dlg(from_tag)\",
               \"h_entry\":\"$dlg(h_entry)\",
               \"h_id\":\"$dlg(h_id)\",
               \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
               \"cgr_account\":\"$dlg_var(cgrAccount)\",
               \"cgr_subject\":\"$dlg_var(cgrSubject)\",
               \"cgr_destination\":\"$dlg_var(cgrDestination)\",
               \"cgr_setuptime\":\"$dlg_var(setupTime)\",
               \"cgr_reqtype\":\"$dlg_var(cgrReqType)\",
               \"cgr_answertime\":\"$TS\"}");
}

# Inform CGRateS about CALL_END (stop debit loops, perform accounting if desired in this way)
route[CGR_CALL_END] {
    if $sht(cgrconn=>cgr) == $null {
        xerr("[$dlg_var(cidhash)] CGR-CALL-END: Charging controller unreachable");
        return;
    }

    $var(callDur) = $TS - $dlg(start_ts);
    $var(cgrCarrier) = 'cr' + $dlg_var(carrierId);

    xnotice("[$dlg_var(cidhash)] CGR-CALL-END: Warn CGRates that call has ended (duration: $var(callDur))");

    evapi_relay("{\"event\":\"CGR_CALL_END\",
        \"callid\":\"$dlg(callid)\",
        \"from_tag\":\"$dlg(from_tag)\",
        \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
        \"cgr_account\":\"$dlg_var(cgrAccount)\",
        \"cgr_subject\":\"$dlg_var(cgrSubject)\",
        \"cgr_destination\":\"$dlg_var(cgrDestination)\",
        \"cgr_answertime\":\"$dlg(start_ts)\",
        \"cgr_setuptime\":\"$dlg_var(setupTime)\",
        \"cgr_duration\":\"$var(callDur)\",
        \"cgr_reqtype\":\"$dlg_var(cgrReqType)\",
        \"carrierId\":\"$var(cgrCarrier)\",
        \"calculateCost\":\"$dlg_var(calculateCost)\",
        \"cgr_disconnectcause\":\"$T_reply_code\"}");
}

# CGRateS request for session disconnect
route[CGR_SESSION_DISCONNECT] {
    json_get_field("$evapi(msg)", "HashEntry", "$var(HashEntry)");
    json_get_field("$evapi(msg)", "HashId", "$var(HashId)");
    json_get_field("$evapi(msg)", "Reason", "$var(Reason)");
    xwarn("CGR_SESSION_DISCONNECT: CGRates disconnects the call ($var(Reason))");
    jsonrpc_exec('{"jsonrpc":"2.0","id":1, "method":"dlg.end_dlg","params":[$(var(HashEntry){s.rm,"}),$(var(HashId){s.rm,"})]}');
    xinfo("CGR_SESSION_DISCONNECT: Response: '$jsonrpl(code) $jsonrpl(text) $jsonrpl(body)'");
}

event_route[htable:mod-init] {
    if (dns_query("users.ivozprovider.local", "kamusers")) {
        $var(usersAddress) = $dns(kamusers=>addr);
        xinfo("users.ivozprovider.local: $var(usersAddress)\n");
    } else {
        xerr("Problems resolving users.ivozprovider.local, aborting\n");
        abort();
    }

    #!ifdef WITH_MULTISOCKET
        xinfo("Multi-socket ENABLED");
        if (dns_query("trunks.ivozprovider.local", "kamtrunks")) {
            $var(trunksAddress) = $dns(kamtrunks=>addr);
            xinfo("trunks.ivozprovider.local: $var(trunksAddress)\n");
        } else {
            xerr("Problems resolving trunks.ivozprovider.local, aborting\n");
            abort();
        }
    #!else
        xinfo("Multi-socket NOT ENABLED");
    #!endif

    #!ifdef WITHOUT_BOUNCER
        xinfo("External call bouncing NOT ENABLED");
    #!else
        xinfo("External call bouncing ENABLED");
    #!endif
}

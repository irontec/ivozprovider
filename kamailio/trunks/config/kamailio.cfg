#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define SIP_PORT 5060
#!define SIPS_PORT 5061
#!define XMLRPC_PORT 8001

# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# ACC Flags
#!define FLT_ACC 1
#!define FLT_ACCFAILED 2

# DLG_FLAG
#!define DLG_FLAG 3

# - options
#!define WITH_ANTIFLOOD

#!define DELAY_MEDIALIBERATION
# Note: If defined, Kamailio delays Asterisk initial media liberation for 1 second (only on outbound calls)

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

####### Global Parameters #########

listen=udp:IP:SIP_PORT
listen=tcp:IP:SIP_PORT
listen=tls:IP:SIPS_PORT
listen=tcp:IP:XMLRPC_PORT

# -- Debug level
# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# If debug level of message is lower than current debug parameter, it gets printed
# Current value: 2 (INFO and higher)
#
# This setting can me modified/seen live running:
# kamcmd-proxyusers cfg.seti core debug X
# kamcmd-proxyusers cfg.get core debug

debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes
version_table="kam_version"

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec IvozProvider v2.4"
user_agent_header="User-Agent: Irontec IvozProvider v2.1"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "sqlops.so"
loadmodule    "rtpengine.so"
loadmodule    "cfg_rpc.so"
loadmodule    "dialog.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "acc.so"
loadmodule    "lcr.so"
loadmodule    "uac.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "domain.so"
loadmodule    "cfgutils.so"
loadmodule    "dialplan.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "permissions.so"
loadmodule    "diversion.so"
loadmodule    "evapi.so"
loadmodule    "json.so"
loadmodule    "jsonrpcs.so"
loadmodule    "ipops.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# JSONRPC-S
modparam("jsonrpcs", "fifo_name", "/tmp/kamailio_proxytrunks_fifo")

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_DSSOCKET)")
modparam("dispatcher", "attrs_avp", "$avp(DSATTRS)")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 2)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@trunks.ivozprovider.local")
modparam("dispatcher", "hash_pvar", "$avp(hash)")

# TLS
modparam("tls", "config", "/etc/kamailio/proxytrunks/tls.cfg")
modparam("tls", "tls_log", 1)

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxytrunks_ctl")

# RTPENGINE
modparam("rtpengine", "db_url", DBURL)
modparam("rtpengine", "table_name", "kam_rtpengine")
modparam("rtpengine", "setid_avp", "$avp(setid)")
modparam("rtpengine", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpengine", "setid_default", 0)

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# ACC
# -- transactions to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- cdr accounting to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 0)
modparam("acc", "cdrs_table", "kam_trunks_cdrs")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);peeringContractId=$dlg_var(peeringContractId);referrer=$dlg_var(referrer);direction=$dlg_var(direction);bounced=$dlg_var(bounced);cgrid=$dlg_var(cgrid)")
modparam("acc", "cdr_extra_nullable", 1)

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "activeCallsCompany; activeCallsBrand")
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "track_cseq_updates", 1)
modparam("dialog", "detect_spirals", 0)

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif
modparam("htable", "htable", "cgrconn=>size=1;")

# UAC
modparam("uac", "auth_realm_avp","$avp(realm)")
modparam("uac", "auth_username_avp","$avp(provideruser)")
modparam("uac", "auth_password_avp","$avp(secret)")
modparam("uac", "restore_mode","auto")
modparam("uac", "restore_dlg", 1)
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_db_table", "kam_trunks_uacreg")
modparam("uac", "reg_contact_addr", "reg_contact_addr")
modparam("uac", "reg_timer_interval", 60)
modparam("uac", "reg_retry_interval", 300)

# LCR
modparam("lcr", "db_url", DBURL)
modparam("lcr", "lcr_gw_table","kam_trunks_lcr_gateways")
modparam("lcr", "lcr_rule_table", "kam_trunks_lcr_rules")
modparam("lcr", "lcr_rule_target_table", "kam_trunks_lcr_rule_targets")
modparam("lcr", "gw_name_column", "gw_name")
modparam("lcr", "ip_addr_column", "ip")
modparam("lcr", "lcr_id_column", "lcr_id")
modparam("lcr", "gw_uri_avp", "$avp(gw_uri_avp)")
modparam("lcr", "ruri_user_avp", "$avp(i:500)")
modparam("lcr", "flags_avp", "$avp(s:peerServerId)")
modparam("lcr", "flags_column", "peerServerId")
modparam("lcr", "defunct_capability", 1)
modparam("lcr", "lcr_id_avp", "$avp(lcr_id_avp)")
modparam("lcr", "defunct_gw_avp", "$avp(defunct_gw_avp)")
modparam("lcr", "lcr_rule_hash_size", 1024)
modparam("lcr", "lcr_gw_count", 1024)
modparam("lcr", "fetch_rows", 3000)
modparam("lcr", "ping_interval", 15) # Ping every 15 seconds
modparam("lcr", "ping_inactivate_threshold", 1) # Mark as inactive at first call of inactivate_gw()
modparam("lcr", "ping_valid_reply_codes", "403,404,405,501") # Mark as active when 2XX or these reply codes
modparam("lcr", "ping_from", "sip:pinger@localhost")
modparam("lcr", "lcr_count", 1)
modparam("lcr", "dont_strip_or_prefix_flag", 1)

# TM
modparam("tm", "fr_timer", 5000)
modparam("tm", "retr_timer1", 500)

# SANITY
modparam("sanity", "autodrop", 0)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_trunks_domain")
modparam("domain", "domain_attrs_table", "kam_trunks_domain_attrs")
modparam("domain", "register_myself", 1)

# DIALPLAN
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "table_name", "kam_dialplan")
modparam("dialplan", "attrs_pvar", "$avp(s:appliedrule)")

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_trunks_address") # Not used
modparam("permissions", "trusted_table", "kam_trusted") # IPs excluded from pike checking and wholesale IPs
modparam("permissions", "db_mode", 1)
modparam("permissions", "peer_tag_avp", "$avp(trustedTag)")

####### Routing Logic ########

request_route {
    route(REQINIT);

    route(IS_FROM_INSIDE);

    # Calculate cidhash if not set
    if ($dlg_var(cidhash) == $null)
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});

    if (is_method("OPTIONS")) {
        force_rport();
        send_reply("200", "I'm here!");
        exit;
    }

    xnotice("[$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($proto:$si:$sp) [$ci]\n");

    route(ANTIFLOOD);

    # CANCEL processing
    if (is_method("CANCEL")) {
        xinfo("[$dlg_var(cidhash)] ----> $rm from $si\n");
        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RELAY);
        }

        xerr("[$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # Manage retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    ### only initial requests (no To tag)

    # Only INVITE can start a dialog
    if (!is_method("INVITE")) {
        xwarn("[$dlg_var(cidhash)] $rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Remove preloaded route headers
    remove_hf("Route");

    # Manage dialog
    dlg_manage();

    # Calculate cidhash if not set
    if ($dlg_var(cidhash) == $null)
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});

    # Transformate numbers for calls from carriers
    if (!$var(is_from_inside)) {
        route(GET_TRANSFORMATIONS_IN);
        route(TRANSFORMATE_IN);
    }

    # Inspect new request
    route(CLASSIFY);

    # Setup accounting
    route(ACCOUNTING);

    # Add record-route to INVITE requests
    record_route();

    # Easy routing
    # (a) From inside world
    # (b) From outside world
    if ($var(is_from_inside)) {
        xinfo("[$dlg_var(cidhash)] IvozProvider calling, route to corresponding GW\n");

        route(PARSE_X_HEADERS);
        route(GET_INFO_FROM_COMPANY);

        #!ifdef DELAY_MEDIALIBERATION
        $dlg_var(initial_reinvite) = 'pending';
        #!endif

        # Evaluate routing logic
        route(LOAD_GWS);

        # -- is our DDI??
        route(BOUNCE);

        # Evaluate rating logic
        if ($avp(externallyRated) == '1') {
            xinfo("[$dlg_var(cidhash)] Externally rating is enabled for this PeeringContract, proceed");
            route(RELAY);
        } else {
            route(CGRATES_AUTH_REQUEST);
        }
    } else {
        if (uri == myself) {
            xinfo("[$dlg_var(cidhash)] Someone calling to my domain, dispatch to next hop\n");
            remove_hf_re("^X-"); # Remove X-HEADERS from carriers
            route(GET_INFO_FROM_MATCHED_DDI);
            route(CONTROL_MAXCALLS);
            route(DISPATCH);
            route(RELAY);
        } else {
            xerr("[$dlg_var(cidhash)] $rd is not one of my domains, 404 Not Here\n");
            send_reply("404", "Not Here");
            exit;
        }
    }

    xerr("[$dlg_var(cidhash)] Main script error, should NOT arrive this point.\n");
    drop;
}

# This route sets $var(is_from_inside): 1 / 0
#   - 1: request/response comes from the inside
#   - 0: request/response comes from the outside world
route[IS_FROM_INSIDE] {
    if (ds_is_from_list("1") || $si == $var(usersAddress)) {
        $var(is_from_inside) = 1;
    } else {
        $var(is_from_inside) = 0;
    }
}

route[BOUNCE] {
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS isMine FROM DDIs WHERE DDIE164='$rU'", "ra");
    if ($xavp(ra=>isMine) == '1') {
        xinfo("[$dlg_var(cidhash)] BOUNCE: Bounce call to myself\n");
        $du = "sip:trunks.ivozprovider.local:" + SIP_PORT;
        $rd = "trunks.ivozprovider.local";
        $dlg_var(peeringContractId) = $avp(peeringContractId);
        $dlg_var(bounced) = '1';
    }
}

route[REQINIT] {
    # Easy dropping for scanners
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent" || search("sipvicious")) {
        xwarn("REQINIT: Dropping scanner request ----> $rm from $si\n");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        xerr("REQINIT: Dropping malformed SIP message from $si:$sp\n");
        exit;
    }

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        xerr("REQINIT: Too many hops for SIP message from $si:$sp\n");
        send_reply("483","Too Many Hops");
        exit;
    }
}

route[LOAD_GWS] {
    $var(filter) = 'b' + $dlg_var(brandId) + 'c' + $dlg_var(companyId);
    if ($avp(fax)) {
        load_gws(1, 'fax', $var(filter));
        if ($avp(gw_uri_avp) != $null) {
            xwarn("[$dlg_var(cidhash)] LOAD-GWS: Fax specific route found\n");
        }
    }

    if ($avp(gw_uri_avp) == $null) {
        $var(prefix) = $dlg_var(routingTag) + $rU;
        load_gws(1, $var(prefix), $var(filter));
    }

    if ($avp(gw_uri_avp) != $null) {
        # At least one gateway loaded, continue

        # Store original ru value to reuse in SELECT-GW invocations
        $dlg_var(ru_before_lcr) = $ru;

        route(SELECT_GW);
    } else {
        xerr("[$dlg_var(cidhash)] LOAD-GWS: No valid gateway for '$rU' for company '$dlg_var(companyId)'\n");
        send_reply("500", "Server Internal Error - No gateways");
        exit;
    }
}

route[SELECT_GW] {
    $ru = $dlg_var(ru_before_lcr); # Restore initial value for subsequent calls
    $du = $null;

    # Evaluate gateway rules
    if (!next_gw()) {
        xerr("[$dlg_var(cidhash)] SELECT-GW: NO next GW, send 503 No gateways");
        send_reply("503", "No gateways");
        exit;
    }

    # GW selection may modify both $ru and $du
    xinfo("[$dlg_var(cidhash)] SELECT-GW: New dest-URI $du\n");
    xinfo("[$dlg_var(cidhash)] SELECT-GW: New RURI $ru\n");

    # Skip GW if has an unresolvable domain
    if(!is_ip("$nh(d)")) {
        if (!dns_query("$nh(d)", "nextgwaddr")) {
            xwarn("[$dlg_var(cidhash)] SELECT-GW: Not resolvable domain '$nh(d)', skip GW");
            route(SELECT_GW);
        } else {
            xinfo("[$dlg_var(cidhash)] SELECT-GW: Resolvable domain '$nh(d)' ($dns(nextgwaddr=>addr)) in GW, proceed");
        }
    }

    # Obtain info about selected GW
    sql_xquery("cb", "SELECT PC.externallyRated, PS.sendPAI, PS.sendRPID, PS.auth_needed, PS.auth_user, PS.auth_password, PS.peeringContractId, PS.from_user, PS.from_domain FROM PeerServers PS JOIN PeeringContracts PC ON PS.peeringContractId=PC.id WHERE PS.id=$avp(peerServerId)", "ra");

    if ( $(xavp(ra=>peeringContractId){s.len}) ) {
        $avp(peeringContractId) = $xavp(ra=>peeringContractId);
        $avp(externallyRated) = $xavp(ra=>externallyRated);
        xinfo("[$dlg_var(cidhash)] SELECT-GW: peeringContractId: $avp(peeringContractId)\n");
    } else {
        xerr("[$dlg_var(cidhash)] SELECT-GW: Error obtaining 'peeringContractId' for peerServerId '$avp(peerServerId)'\n");
        send_reply("500", "Server Internal Error");
        exit;
    }

    if ($xavp(ra=>auth_needed) == 'yes') {
        if ( $(xavp(ra=>auth_user){s.len}) ) {
            $avp(provideruser) = $xavp(ra=>auth_user);
        } else {
            xwarn("[$dlg_var(cidhash)] SELECT-GW: Error obtaining 'provideruser' for peerServerId '$avp(peerServerId)'\n");
        }

        if ( $(xavp(ra=>auth_password){s.len}) ) {
            $avp(secret) = $xavp(ra=>auth_password);
        } else {
            xwarn("[$dlg_var(cidhash)] SELECT-GW: Error obtaining 'secret' for peerServerId '$avp(peerServerId)'\n");
        }
    } else {
        $avp(provideruser) = $null;
        $avp(secret) = $null;
    }

    if ( $(xavp(ra=>from_user){s.len}) ) {
        $avp(from_user) = $xavp(ra=>from_user);
    } else {
        $avp(from_user) = $null;
    }

    if ( $(xavp(ra=>from_domain){s.len}) ) {
        $avp(from_domain) = $xavp(ra=>from_domain);
    } else {
        $avp(from_domain) = $null;
    }

    $avp(send_pai) = $xavp(ra=>sendPAI);
    $avp(send_rpid) = $xavp(ra=>sendRPID);

    # Reset auth flag
    $avp(auth_done) = '0';

    t_on_failure("MANAGE_FAILURE_GW");
    t_on_branch("MANAGE_BRANCH_GW");
}

route[PARSE_X_HEADERS] {
    # Extract routing tag
    $var(header) = 'X-Info-RoutingTag';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') {
        xinfo("[$dlg_var(cidhash)] X-HEADERS-OTHER: '$var(header)' header found: $var(header-value)\n");
        $dlg_var(routingTag) = $var(header-value);
    }

    if ($dlg_var(type) == 'wholesale') return;

    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(xcallid) = $var(header-value);

    # -- xcallid is mandatory for every normal call.
    #    Check if X-Info-Special header is present with 'fax' value (current only exception)
    if ($(dlg_var(xcallid){s.len}) == 0) {
        $var(header) = 'X-Info-Special';
        route(PARSE_OPTIONAL_X_HEADER);
        if ($var(header-value) == 'fax') {
            xinfo("[$dlg_var(cidhash)] X-HEADERS-OTHER: Special case without xcallid: fax\n");
            $avp(fax) = '1';
        } else {
            xerr("[$dlg_var(cidhash)] X-HEADERS-OTHER: Invalid $var(header) value ($var(header-value)) for call without xcallid\n");
            send_reply("500", "x-callid is missing");
            exit;
        }
    } else {
        xnotice("[$dlg_var(cidhash)] X-HEADERS-OTHER: Related leg: $dlg_var(xcallid)\n");
    }

    # Extract Record header
    $var(header) = 'X-Info-Record';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) == 'yes') {
        xinfo("[$dlg_var(cidhash)] X-HEADERS-OTHER: '$var(header)' header found, call will be recorded\n");
        $avp(recordCall) = 'yes';
    }
}

# Header might not be present and, if present, might be empty
route[PARSE_OPTIONAL_X_HEADER] {
    if (is_present_hf($var(header))) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        $var(header-value) = '';
    }
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        xerr("[$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[TRANSFORMATE_WITHINDLG] {
    if (!is_method("INVITE|UPDATE")) return;
    if (!is_present_hf("P-Asserted-Identity") && !is_present_hf("remote-party-id")) return;

    if ($var(is_from_inside)) {
        route(TRANSFORMATE_OUT);
    } else {
        route(TRANSFORMATE_IN);
    }
}

# Get incoming tranformations (sets tr_* dlg_vars)
route[GET_TRANSFORMATIONS_IN] {
    if (src_ip == myself) return; # Bounced calls already in E.164

    # Get all DDI candidates
    sql_query("cb", "SELECT D.DDIE164, CONCAT(P.transformationRuleSetId, 1) AS callee_in, CONCAT(P.transformationRuleSetId, 0) AS caller_in, CONCAT(P.transformationRuleSetId, 2) AS caller_out, CONCAT(P.transformationRuleSetId, 3) AS callee_out FROM DDIs D INNER JOIN PeeringContracts P ON D.peeringContractId = P.id WHERE '$rU' REGEXP CONCAT('[0-9]*', DDI) ORDER BY LENGTH(DDIE164) DESC", "ra");

    # Are there any candidates?
    if ($dbr(ra=>rows) == 0) {
        xwarn("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: $rU not recognized in any company, 404 Not Found\n");
        send_reply("404", "Not Here");
        exit;
    } else {
        xinfo("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: There are $dbr(ra=>rows) DDI candidates, proceed\n");
    }

    # Evaluate all candidates ($rU after transformation must be equal to candidate, otherwise it is rejected)
    $var(i) = 0;
    while ($var(i)<$dbr(ra=>rows)) {
        $var(candidate) = $dbr(ra=>[$var(i), 0]);
        $var(transformation) = $dbr(ra=>[$var(i), 1]);
        $var(number) = $rU;
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        if ($var(transformated) == $var(candidate)) {
            # We have a winner candidate!!
            xinfo("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: Callee $rU is recognized as $var(candidate) (should be E164)\n");

            # Save transformations for further application
            $dlg_var(tr_callee_in) = $dbr(ra=>[$var(i), 1]);
            $dlg_var(tr_caller_in) = $dbr(ra=>[$var(i), 2]);
            $dlg_var(tr_caller_out) = $dbr(ra=>[$var(i), 3]);
            $dlg_var(tr_callee_out) = $dbr(ra=>[$var(i), 4]);

            # Free and leave
            sql_result_free("ra");
            return;
        }
        $var(i) = $var(i) + 1;
    }

    sql_result_free("ra");

    # No candidate succeeded after applying transformations
    xwarn("[$dlg_var(cidhash)] GET-TRANSFORMATIONS-IN: No DDI candidate succeeded after applying transformations to $rU, 404 Not Found");
    send_reply("404", "Not Here");
    exit;
}

# This route apply transformations to rU, PAI and Diversion to E.164
route[TRANSFORMATE_IN] {
    if ($dlg_var(tr_caller_in) != $null) {
        route(GET_CALLER); # Greps caller and sets it in $var(number)
        $var(transformation) = $dlg_var(tr_caller_in);
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        route(SET_CALLER); # Sets caller using $var(transformated) value
    }

    if (has_totag()) return; # in-dialog messages only need pai/rpid mangling

    if ($dlg_var(tr_callee_in) != $null) {
        $var(transformation) = $dlg_var(tr_callee_in);
        $var(number) = $rU;
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        $rU = $var(transformated);
    }

    if ($dlg_var(tr_caller_in) != $null) {
        # Apply the same transformation to first Diversion header
        if (is_present_hf("Diversion")) {
            $var(number) = $(di{uri.user});
            if ($var(number) != $null) {
                $avp(reason) = @hf_value.diversion[0].param['reason'];
                if ($avp(reason) == $null) {
                    xinfo("[$dlg_var(cidhash)] TRANSFORMATE-IN: No reason extracted, set 'deflection'\n");
                    $avp(reason) = 'deflection';
                }

                xinfo("[$dlg_var(cidhash)] TRANSFORMATE-IN: Initial diversion -> $var(number)\n");
                $var(transformation) = $dlg_var(tr_caller_in);
                route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)

                remove_hf_value("Diversion[0]");
                add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $(di{uri.host}));
            }
        }
    }
}

# Sets caller in $var(number) seeking in PAI/RPID/From (in this order)
route[GET_CALLER] {
    # Where is my caller? PAI/RPID/From?
    if (is_present_hf("P-Asserted-Identity")) {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: PAI present: $(ai{uri.user})\n");
        $var(number) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: RPID present: $(re{uri.user})\n");
        $var(number) = $(re{uri.user});
    } else {
        xinfo("[$dlg_var(cidhash)] GET-CALLER: Nor PAI nor RPID present, only From ($fU)! :(\n");
        $var(number) = $fU;
    }
}

# Sets caller in PAI/RPID/From using $var(transformated) value
route[SET_CALLER] {
    # Initial requests
    if (!has_totag()) {
        if ($var(is_from_inside)) {
            # Initial request to GW need special caller mangling

            # Set caller for carrier
            $var(newfromuser) = $var(transformated);
            $var(newfromdomain) = $Ri; # Use bind ip as from domain
            $var(newfromuri) = 'sip:' + $var(newfromuser) + '@' + $var(newfromdomain);

            # Keep this in dlg_var as uac_replace_from does not work for display name
            $dlg_var(newfromdisplay) = '"' + $var(newfromuser) + '"';

            # Use PAI?
            remove_hf("P-Asserted-Identity");
            if ($avp(send_pai)) {
                xinfo("[$dlg_var(cidhash)] SET-CALLER: Set PAI to: $dlg_var(newfromdisplay) <$var(newfromuri)>\n");
                append_hf("P-Asserted-Identity: $dlg_var(newfromdisplay) <$var(newfromuri)>\r\n");
            }

            # Use RPID?
            remove_hf("Remote-Party-ID");
            if ($avp(send_rpid)) {
                xinfo("[$dlg_var(cidhash)] SET-CALLER: Set RPID to: $dlg_var(newfromdisplay) <$var(newfromuri)>\n");
                append_hf("Remote-Party-ID: $dlg_var(newfromdisplay) <$var(newfromuri)>;privacy=off;screen=no\r\n");
            }

            # Set GW from_user and from_domain if necessary
            if ($avp(from_user) != $null) $var(newfromuser) = $avp(from_user);
            if ($avp(from_domain) != $null) $var(newfromdomain) = $avp(from_domain);
            $var(newfromuri) = "sip:" + $var(newfromuser) + '@' + $var(newfromdomain);
            xinfo("[$dlg_var(cidhash)] SET-CALLER: New from: $dlg_var(newfromdisplay) <$var(newfromuri)>\n");
            uac_replace_from('$dlg_var(newfromdisplay)', "$var(newfromuri)"); # Change From header for GW
        } else {
            # Initial request from GW
            if ($fU != $var(transformated)) {
                $var(newfromuri) = 'sip:' + $var(transformated) + '@' + $fd;
                uac_replace_from('$var(transformated)', "$var(newfromuri)"); # Change From header for GW
            }
        }
    }

    # Common for initial requests from GW and all in-dialog requests
    if (!$var(is_from_inside) || has_totag()) {
        if (is_present_hf("P-Asserted-Identity")) {
            if ($(ai{uri.user}) != $var(transformated)) { # If new value differs from previous, change
                remove_hf("P-Asserted-Identity");
                append_hf("P-Asserted-Identity: <sip:$var(transformated)@$(ai{uri.host})>\r\n");
            }
        }

        if (is_present_hf("Remote-Party-ID")) {
            if ($(re{uri.user}) != $var(transformated)) { # If new value differs from previous, change
                remove_hf("Remote-Party-ID");
                append_hf("Remote-Party-ID: <sip:$var(transformated)@$(re{uri.host})>\r\n");
            }
        }
    }
}

route[GET_TRANSFORMATIONS_OUT] {
    sql_xquery("cb", "SELECT CONCAT(transformationRuleSetId, 0) AS caller_in, CONCAT(transformationRuleSetId, 1) AS callee_in, CONCAT(transformationRuleSetId, 2) AS caller_out, CONCAT(transformationRuleSetId, 3) AS callee_out FROM PeeringContracts WHERE id=$avp(peeringContractId)", "ra");

    $dlg_var(tr_caller_in) = $xavp(ra=>caller_in);
    $dlg_var(tr_callee_in) = $xavp(ra=>callee_in);
    $dlg_var(tr_caller_out) = $xavp(ra=>caller_out);
    $dlg_var(tr_callee_out) = $xavp(ra=>callee_out);

    return;
}

# Transformate all numbers to GW format
route[TRANSFORMATE_OUT] {
    if ($dlg_var(bounced) == '1') return; # Skip transformation in bounced calls

    if ($dlg_var(tr_caller_out) != $null) {
        route(GET_CALLER); # Greps caller and sets it in $var(number)
        $var(transformation) = $dlg_var(tr_caller_out);
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        route(SET_CALLER);
    }

    # in-dialog messages only need pai/rpid mangling
    if (has_totag()) return;

    # Transformate callee_out
    xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: Initial callee -> $rU\n");
    $var(transformation) = $dlg_var(tr_callee_out);
    $var(number) = $rU;
    route(APPLY_TRANSFORMATION);
    $rU = $var(transformated);
    xinfo("[$dlg_var(cidhash)] MANAGE-BRANCH-GW: New to: $ru\n");
    uac_replace_to("$ru");

    # Transformate first Diversion header
    if (is_present_hf("Diversion")) {
        $var(number) = $(di{uri.user});
        if ($var(number) != $null) {
            $avp(reason) = @hf_value.diversion[0].param['reason'];
            if ($avp(reason) == $null) {
                xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: No reason extracted, set 'deflection'\n");
                $avp(reason) = 'deflection';
            }

            xinfo("[$dlg_var(cidhash)] TRANSFORMATE-OUT: Initial diversion -> $var(number)\n");
            $var(transformation) = $xavp(ra=>caller_out);
            route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)

            remove_hf_value("Diversion[0]");
            add_diversion("$avp(reason)", 'sip:' + $var(transformated) + '@' + $dlg_var(companyDomain));
        }
    }
}

# Apply $var(transformation) transformations (if set) to $var(number)
# Sets result in $var(transformated)
route[APPLY_TRANSFORMATION] {
    $var(transformated) = $var(number);
    $avp(appliedrule) = $null;

    dp_translate("$(var(transformation){s.int})", "$var(number)/$var(transformated)");

    # If no rule applied, re-set value
    if ($avp(appliedrule) == $null)
        $var(transformated) = $var(number);

    xinfo("[$dlg_var(cidhash)] APPLY-TRANSFORMATION: Number after: $var(transformated) (applied rule: '$avp(appliedrule)')\n");
}

route[GET_INFO_FROM_MATCHED_DDI] {
    sql_xquery("cb", "SELECT c.mediaRelaySetsId, c.maxCalls AS maxCallsCompany, b.maxCalls AS maxCallsBrand, d.recordCalls, c.distributeMethod, AppS.ip AS asAddress FROM DDIs d JOIN Companies c ON d.companyId=c.id LEFT JOIN ApplicationServers AppS ON AppS.id=c.applicationServerId JOIN Brands b ON c.brandId=b.id WHERE d.DDIE164='$rU'", "ra");

    # Matched DDI
    $dlg_var(maxCallsCompany) = $xavp(ra=>maxCallsCompany);
    $dlg_var(maxCallsBrand) = $xavp(ra=>maxCallsBrand);

    # Recording settings
    if ($xavp(ra=>recordCalls) == 'inbound' || $xavp(ra=>recordCalls) == 'all') {
        $avp(recordCall) = 'yes';
    }

    # Distribute method
    $avp(distributeMethod) = $xavp(ra=>distributeMethod);
    $avp(asAddress) = $xavp(ra=>asAddress);

    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
}

route[GET_INFO_FROM_COMPANY] {
    sql_xquery("cb", "SELECT D.domain, C.billingMethod, C.mediaRelaySetsId FROM Companies C LEFT JOIN Domains D ON C.domainId=D.id WHERE C.id='$dlg_var(companyId)'", "ra");

    $dlg_var(cgrReqType) = '*' + $xavp(ra=>billingMethod);

    if ($dlg_var(type) != 'wholesale') {
        $dlg_var(companyDomain) = $xavp(ra=>domain);
        $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
    }

    return;
}

# Handle within-dialog messages
route[WITHINDLG] {
    if (!$dlg_var(confirmed) && is_method("UPDATE|INVITE")) drop;

    # REFER not allowed
    if (is_method("REFER")) {
        xerr("[$dlg_var(cidhash)] WITHINDLG: 'REFER' not supported\n");
        send_reply("405","Method Not Allowed");
        exit;
    }

    route(TRANSFORMATE_WITHINDLG);

    # Reinvite handling
    if (is_method("INVITE")) {
        # uac_replace_from does not maintain display_name in subsequent transactions
        #$fn = $dlg_var(newfromdisplay);

        #!ifdef DELAY_MEDIALIBERATION
        if ($dlg_var(initial_reinvite) == 'pending') {
            xinfo("[$dlg_var(cidhash)] WITHINDLG: Initial reinvite from call initiated by AS\n");
            $dlg_var(initial_reinvite) = 'yes';
        } else {
            $dlg_var(initial_reinvite) = 'no';
        }
        #!endif
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        } else if ( is_method("ACK") ) {
            # ACK is forwarded statelessy
            route(RTPENGINE);
        }
        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        send_reply("403","Not here");
    }
}

route[DISPATCH] {
    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Static routing to specific AS?
    if ($avp(distributeMethod) == 'static') {
        $du = "sip:" + $avp(asAddress) + ":6060";
        xinfo("[$dlg_var(cidhash)] DISPATCH: Company has static routing enabled\n");
        t_on_failure("MANAGE_FAILURE");
    } else {
        if ($avp(distributeMethod) == 'hash') {
            $avp(hash) = $dlg_var(companyId);
            # hash over $avp(hash)
            xinfo("[$dlg_var(cidhash)] DISPATCH: Dispatch hashing '$avp(hash)'\n");
            $var(alg) = 7;
        } else {
            # round robin dispatching on ASs (distributeMethod == 'rr')
            xinfo("[$dlg_var(cidhash)] DISPATCH: dispatch to any AS (round robin)\n");
            $var(alg) = 4;
        }

        if(!ds_select_dst("1", "$var(alg)")) {
            xerr("[$dlg_var(cidhash)] DISPATCH: No destination found\n");
            send_reply("404", "No destination");
            exit;
        } else {
            xinfo("[$dlg_var(cidhash)] DISPATCH: $avp(AVP_CNT) destination(s) found\n");
        }

        t_on_failure("MANAGE_FAILURE_AS");
    }

    xinfo("[$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du>\n");
}

# Relay request
route[RELAY] {
    if ($(du{uri.host}) != $null) {
        xinfo("[$dlg_var(cidhash)] RELAY: Relaying to $(du{uri.host}) (du, $dP)\n");
    } else {
        xinfo("[$dlg_var(cidhash)] RELAY: Relaying to $(ru{uri.host}) (ru)\n");
    }

    # Common for every reply
    t_on_reply("MANAGE_REPLY");

    if (!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    if (!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");

    if (!t_relay())
        sl_reply_error();

    exit;
}

route[ANTIFLOOD] {
#!ifdef WITH_ANTIFLOOD
    # Inside call
    if (src_ip == myself || $var(is_from_inside)) return;

    # Trusted sources
    if (allow_trusted($si, 'any') && $avp(trustedTag) == $null) {
        xinfo("[$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (IP added in antiflood trusted IPs)\n");
        return;
    }

    # Evaluate PIKE
    if($sht(ipban=>$si) != $null) {
        # ip is already blocked
        xerr("[$dlg_var(cidhash)] ANTIFLOOD: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
        exit;
    }

    if (!pike_check_req()) {
        xerr("[$dlg_var(cidhash)] ANTIFLOOD: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
        $sht(ipban=>$si) = 1;
        exit;
    }
#!endif

    return;
}

# This route sets following dlg_vars: brandId, companyId, type
route[CLASSIFY] {
    if ($var(is_from_inside)) {
        $var(header) = 'X-Info-BrandId';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(brandId) = $var(header-value);

        $var(header) = 'X-Info-CompanyId';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(companyId) = $var(header-value);

        $var(header) = 'X-Info-Type';
        route(PARSE_MANDATORY_X_HEADER);
        $dlg_var(type) = $var(header-value);
    } else {
        sql_xquery("cb", "SELECT C.brandId, C.id AS companyId, C.type FROM DDIs D JOIN Companies C ON D.companyId=C.id WHERE DDIE164='$rU'", "rp");
        $dlg_var(brandId) = $xavp(rp=>brandId);
        $dlg_var(companyId) = $xavp(rp=>companyId);
        $dlg_var(type) = $xavp(rp=>type);

        if ($dlg_var(type) == 'wholesale') {
            xerr("[$dlg_var(cidhash)] CLASSIFY: Wholesale inbound call, 501\n");
            send_reply("501", "Not Implemented [WI]");
            exit;
        }
    }

    # Check type has one of the supported values
    if ($dlg_var(type) != 'vpbx' && $dlg_var(type) != 'residential' && $dlg_var(type) != 'wholesale') {
        xerr("[$dlg_var(cidhash)] CLASSIFY: Unsupported type '$dlg_var(type)'\n");
        send_reply("500", "Internal Server Error [UT]");
        exit;
    }
}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    if ($var(is_from_inside)) {
        $dlg_var(direction) = 'outbound';
    } else {
        $dlg_var(direction) = 'inbound';
    }

    $dlg_var(callid) = $ci;
    $dlg_var(callee) = $rU;
    route(GET_CALLER);
    $dlg_var(caller) = $var(number);

    if (is_present_hf("Diversion"))
        $dlg_var(diversion) = $(di{uri.user});
}

# Reply generic route (all replies goes through this route)
onreply_route {
    xnotice("[$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    route(IS_FROM_INSIDE);
}

# Common for both AS and GW replies
onreply_route[MANAGE_REPLY] {
    route(TRANSFORMATE_WITHINDLG);

    # Manage RTP
    if (t_check_status("[12][0-9]{2}")) {
        xinfo("[$dlg_var(cidhash)] MANAGE-REPLY: Non-error reply $rs, call RTPRELAY\n");
        route(RTPENGINE);
    }
}

# Manage failure replies (only for failure response codes, executed after previous 2 routes)

# Failure route for initial transactions to GW
failure_route[MANAGE_FAILURE_GW] {
    if(!t_check_status("(401)|(407)")) {
        xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    }

    route(IS_FROM_INSIDE);

    if (t_is_canceled()) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: t_is_canceled, exit here\n");
        exit;
    }

    if (t_check_status("(401)|(407)") && $avp(auth_done) != '1') {
        # Get ready for SIP auth
        #   username:  $avp(provideruser) set in SELECT-GW
        #   password:  $avp(secret) from DB below
        #   realm:     take it from 401/407 leaving it empty
        $avp(realm) = '';

        # $avp(secret) is available?
        if (is_avp_set("$avp(secret)")) {
            # Sends INVITE with AUTH (and adapts CSeq)
            uac_auth();
            $avp(auth_done) = '1'; # Set avp to avoid using invalid credentials more than once

            t_on_failure("MANAGE_FAILURE_GW");
            t_on_branch("MANAGE_BRANCH_GW");
            route(RELAY);
        } else {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: No secret available for $avp(newfrom), defunct_gw and try another one\n");
            defunct_gw(36000); # No credentials available, defunct gw 4ever and trigger alarm
        }
    } else if (t_check_status("(401)|(407)") && $avp(auth_done) == '1') {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Invalid credentials already used\n");
    } else if (t_check_status("486")) {
        xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Destiny busy (reply code: $T_reply_code)\n");
        exit;
    } else if (t_check_status("422")) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Session Interval Too Small, forward to AS (reply code: $T_reply_code)\n");
        exit;
    } else if (t_check_status("408")) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code: Inactivate GW\n");
        inactivate_gw(); # Inactivate GW temporally (until it answers OPTIONS)
    } else if (t_check_status("3[0-9]{2}")) {
        xwarn("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code: Not allowed from GW\n");
    }

    xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Failure using gateway to place a call (reply code: $T_reply_code)\n");

    xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Try next GW\n");
    route(SELECT_GW);

    if ($avp(externallyRated) == '1') {
        xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-GW: Externally rating is enabled for this PeeringContract, proceed");
        $dlg_var(cgrid) = $null;
        route(RELAY);
    } else {
        route(CGRATES_AUTH_REQUEST);
    }
}

# Failure route for initial transactions to AS
failure_route[MANAGE_FAILURE_AS] {
    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(IS_FROM_INSIDE);

    if (t_is_canceled()) {
        xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS '$avp(AVP_DST)' as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            xinfo("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
            exit;
        } else {
            xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Failure route for non-initial transactions
failure_route[MANAGE_FAILURE] {
    xerr("[$dlg_var(cidhash)] MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(IS_FROM_INSIDE);

    if (t_is_canceled()) {
        xerr("[$dlg_var(cidhash)] MANAGE-FAILURE: t_is_canceled, exit here\n");
        exit;
    }
}

# Branch route for transactions to GW
branch_route[MANAGE_BRANCH_GW] {
    route(IS_FROM_INSIDE);
    route(RTPENGINE);
    route(GET_TRANSFORMATIONS_OUT);
    route(TRANSFORMATE_OUT);
}

# Branch route for transactions platform
branch_route[MANAGE_BRANCH] {
    route(IS_FROM_INSIDE);
    route(RTPENGINE);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    xnotice("[$dlg_var(cidhash)] $dlg_var(direction) call confirmed for company '$dlg_var(companyId)' [$ci]\n");

    if ($dlg_var(direction) == 'outbound') {
        $dlg_var(peeringContractId) = $avp(peeringContractId);
        if ($dlg_var(cgrid) == $null) {
            xinfo("[$dlg_var(cidhash)] No cgrid, skip rating logic");
            return;
        }
        route(CGR_CALL_START);
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    # Dialog end, print stats
    xinfo("[$dlg_var(cidhash)] $dlg_var(direction) call ended for company '$dlg_var(companyId)' [$ci]\n");
    if ($dlg_var(cgrid) == $null) {
        xinfo("[$dlg_var(cidhash)] No cgrid, skip rating logic");
        return;
    }
    route(CGR_CALL_END);
}

# Executed for request generated by Kamailio
event_route[tm:local-request] {
    xnotice("Kamailio generated request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");

    # CGrateS generated BYE
    if (is_method("BYE") && $var(Reason) != 0 && $var(Reason) == '"INSUFFICIENT_CREDIT"') {
        append_hf("Hint: credit expired\r\n");
    }

    # UACREG sends REGISTER requests whose Contact domain must be adapted
    if ($rm == "REGISTER") {
        subst_hf("Contact", "/reg_contact_addr/$sndfrom(ip):$sndfrom(port)/", "a");
    }
}

onsend_route {
    if (is_method("ACK")) $dlg_var(confirmed) = '1';

    #!ifdef DELAY_MEDIALIBERATION
    if (is_request() && is_method("INVITE") && $dlg_var(initial_reinvite) == 'yes') {
        xinfo("[$dlg_var(cidhash)] Initial reinvite from call initiated by AS, delay 1 second\n");
        sleep(1);
    }
    #!endif
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        xwarn("XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    xnotice("XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");
    route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    xinfo("GENERIC_XMLRPC_COMMAND: XMLRPC generic command from allowed IP ($si), dispatch!\n");

    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[RTPENGINE] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;
    if (is_method("ACK") && !has_body("application/sdp")) return;
    if ($dlg_var(type) == 'wholesale') return;
    if ($dlg_var(bounced) == '1') return;

    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        set_rtpengine_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    $var(rtpengine_opts) = 'replace-session-connection replace-origin asymmetric trust-address ICE=remove RTP/AVP';

    xinfo("[$dlg_var(cidhash)] RTPENGINE: rtpengine_manage [$var(rtpengine_opts)]\n");
    rtpengine_manage("$var(rtpengine_opts)");

    if ($avp(recordCall) == 'yes' && $dlg_var(recordingCall) != 'yes') {
        # First 200 OK to initial INVITE
        if (is_reply() && t_check_status("2[0-9]{2}")) {
            xinfo("[$dlg_var(cidhash)] RTPENGINE: Start recording this call ('$rs $rr' for initial $rm)\n");
            start_recording();
            $dlg_var(recordingCall) = 'yes'; # Save to avoid start_recording twice if retrans
        }
    }
}

route[CONTROL_MAXCALLS] {
    if (get_profile_size("activeCallsCompany", "$dlg_var(companyId)", "$avp(activeCallsCompany)")) {
        xinfo("[$dlg_var(cidhash)] CONTROL-MAXCALLS: company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany) calls\n");
    } else {
        xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany) calls (error obtaining value)\n");
        if ($dlg_var(maxCallsCompany) > 0) {
            xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Dropping call for security\n");
            send_reply("500", "Internal Server Error [MC]");
            exit;
        }
    }

    if (get_profile_size("activeCallsBrand", "$dlg_var(brandId)", "$avp(activeCallsBrand)")) {
        xinfo("[$dlg_var(cidhash)] CONTROL-MAXCALLS: brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand) calls\n");
    } else {
        xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand) calls (error obtaining value)\n");
        if ($dlg_var(maxCallsBrand) > 0) {
            xerr("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Dropping call for security\n");
            send_reply("500", "Internal Server Error [MC]");
            exit;
        }
    }

    if ($dlg_var(maxCallsBrand) > 0 && $avp(activeCallsBrand) >= $dlg_var(maxCallsBrand)) {
        xwarn("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Call NOT allowed for brand$dlg_var(brandId), 403 Maxcalls exceeded\n");
        send_reply("403", "Maxcalls exceeded");
        exit;
    } else if ($dlg_var(maxCallsCompany) > 0 && $avp(activeCallsCompany) >= $dlg_var(maxCallsCompany)) {
        xwarn("[$dlg_var(cidhash)] CONTROL-MAXCALLS: Call NOT allowed for company$dlg_var(companyId), 403 Maxcalls exceeded\n");
        send_reply("403", "Maxcalls exceeded");
        exit;
    } else {
         set_dlg_profile("activeCallsCompany", "$dlg_var(companyId)");
         set_dlg_profile("activeCallsBrand", "$dlg_var(brandId)");
    }
}

#################################################
# --- Kamailio-CGRateS related route blocks --- #
#################################################

# Detect presence of at least one connection with CGRates
event_route[evapi:connection-new] {
    $sht(cgrconn=>cgr) = $evapi(srcaddr) + ":" + $evapi(srcport);
    xnotice("Connection with CGrates established ($sht(cgrconn=>cgr))!!\n");
}

event_route[evapi:connection-closed] {
    xerr("Connection with CGrates closed!!\n");
    $sht(cgrconn=>cgr) = $null;
}

# Send AUTH_REQUEST to CGRateS
route[CGRATES_AUTH_REQUEST] {
    # Auth INVITEs with CGRateS
    if $sht(cgrconn=>cgr) == $null {
        xerr("[$dlg_var(cidhash)] CGRATES-AUTH-REQUEST: Charging controller unreachable");
        send_reply("503","Charging controller unreachable");
        exit;
    }

    $dlg_var(cgrTenant) = 'b' + $dlg_var(brandId);
    $dlg_var(cgrAccount) = 'c' + $dlg_var(companyId);
    if ($dlg_var(cgrDestination) == $null) $dlg_var(cgrDestination) = $rU;
    $dlg_var(setupTime) = $TS;

    xinfo("[$dlg_var(cidhash)] CGRATES-AUTH-REQUEST: Ask CGRates whether call is granted ($dlg_var(cgrTenant):$dlg_var(cgrAccount):$dlg_var(cgrDestination):$dlg_var(cgrReqType))");

    evapi_async_relay("{\"event\":\"CGR_AUTH_REQUEST\",
            \"callid\":\"$dlg(callid)\",
            \"from_tag\":\"$dlg(from_tag)\",
            \"tr_index\":\"$T(id_index)\",
            \"tr_label\":\"$T(id_label)\",
            \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
            \"cgr_account\":\"$dlg_var(cgrAccount)\",
            \"cgr_reqtype\":\"$dlg_var(cgrReqType)\",
            \"cgr_destination\":\"$dlg_var(cgrDestination)\",
            \"cgr_setuptime\":\"$dlg_var(setupTime)\"}");

    # Do not continue route script, transaction will be processed when API answers
    exit;
}

event_route[evapi:message-received] {
    json_get_field("$evapi(msg)", "Event", "$var(Event)");
    route($(var(Event){s.rm,"})); # String characters are kept by json_get_field, remove them here
    # Message received from CGrates, continue in CGR_AUTH_REPLY
}

route[CGR_AUTH_REPLY] {
    json_get_field("$evapi(msg)", "TransactionIndex", "$var(TransactionIndex)");
    json_get_field("$evapi(msg)", "TransactionLabel", "$var(TransactionLabel)");
    json_get_field("$evapi(msg)", "MaxSessionTime", "$var(MaxSessionTime)");
    json_get_field("$evapi(msg)", "Suppliers", "$var(Suppliers)");
    json_get_field("$evapi(msg)", "ResourceAllowed", "$var(CGRResourceAllowed)");
    json_get_field("$evapi(msg)", "CgrId", "$var(cgrid)");
    json_get_field("$evapi(msg)", "Error", "$var(CgrError)");
    $var(id_index) = $(var(TransactionIndex){s.int});
    $var(id_label) = $(var(TransactionLabel){s.int});
    $var(CgrMaxSessionTime) = $(var(MaxSessionTime){s.int});
    $var(CgrSuppliers) = $(var(Suppliers){s.rm,"});
    $var(CGRResourceAllowed) = $(var(CGRResourceAllowed){s.rm,"});
    $var(CgrError) = $(var(CgrError){s.rm,"});

    # API response parsed, continue processing transaction in CGRATES_AUTH_REPLY
    t_continue("$var(id_index)", "$var(id_label)", "CGRATES_AUTH_REPLY"); # Unpark the transaction
}

route[CGRATES_AUTH_REPLY] {
    # Save cgrid in acc cdrs
    $dlg_var(cgrid) = $(var(cgrid){s.rm,"});

    if ($var(CgrError) != "") {
        xerr("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: $var(CgrError)");
        send_reply("503", "CGR_ERROR");
        exit;
    }

   if ($var(CgrMaxSessionTime) != -1) {
       if $var(CgrMaxSessionTime) == 0 {
           # Not enough balance, do not allow the call to go through
           xwarn("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Insufficient credit");
           send_reply("403","Insufficient credit");
           exit;
       } else if !dlg_set_timeout("$var(CgrMaxSessionTime)") {
           xerr("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Max session time error");
           send_reply("503","CGR_MAX_SESSION_TIME_ERROR");
           exit;
       } else {
           xinfo("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Max-session-time: $var(CgrMaxSessionTime)");
       }
   }

    if ($var(CGRResourceAllowed) == "false") {
        xerr("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Resource not allowed");
        send_reply("403","Resource not allowed");
        exit;
    }

    xinfo("[$dlg_var(cidhash)] CGRATES-AUTH-REPLY: Call granted, RELAY");
    route(RELAY);
}

# Inform CGRateS about CALL_START (start prepaid sessions loops)
route[CGR_CALL_START] {
    if $sht(cgrconn=>cgr) == $null {
        xerr("[$dlg_var(cidhash)] CGR-CALL-START: Charging controller unreachable");
        send_reply("503","Charging controller unreachable");
        exit;
    }

    xnotice("[$dlg_var(cidhash)] CGR-CALL-START: Warn CGRates that call is started");

    evapi_relay("{\"event\":\"CGR_CALL_START\",
               \"callid\":\"$dlg(callid)\",
               \"from_tag\":\"$dlg(from_tag)\",
               \"h_entry\":\"$dlg(h_entry)\",
               \"h_id\":\"$dlg(h_id)\",
               \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
               \"cgr_account\":\"$dlg_var(cgrAccount)\",
               \"cgr_destination\":\"$dlg_var(cgrDestination)\",
               \"cgr_setuptime\":\"$dlg_var(setupTime)\",
               \"cgr_reqtype\":\"$dlg_var(cgrReqType)\",
               \"cgr_answertime\":\"$TS\"}");
}

# Inform CGRateS about CALL_END (stop debit loops, perform accounting if desired in this way)
route[CGR_CALL_END] {
    if $sht(cgrconn=>cgr) == $null {
        xerr("[$dlg_var(cidhash)] CGR-CALL-END: Charging controller unreachable");
        exit;
    }

    $var(callDur) = $TS - $dlg(start_ts);
    xnotice("[$dlg_var(cidhash)] CGR-CALL-END: Warn CGRates that call has ended (duration: $var(callDur))");

    evapi_relay("{\"event\":\"CGR_CALL_END\",
        \"callid\":\"$dlg(callid)\",
        \"from_tag\":\"$dlg(from_tag)\",
        \"cgr_tenant\":\"$dlg_var(cgrTenant)\",
        \"cgr_account\":\"$dlg_var(cgrAccount)\",
        \"cgr_destination\":\"$dlg_var(cgrDestination)\",
        \"cgr_answertime\":\"$dlg(start_ts)\",
        \"cgr_setuptime\":\"$dlg_var(setupTime)\",
        \"cgr_duration\":\"$var(callDur)\",
        \"cgr_reqtype\":\"$dlg_var(cgrReqType)\",
        \"cgr_disconnectcause\":\"$T_reply_code\"}");
}

# CGRateS request for session disconnect
route[CGR_SESSION_DISCONNECT] {
    json_get_field("$evapi(msg)", "HashEntry", "$var(HashEntry)");
    json_get_field("$evapi(msg)", "HashId", "$var(HashId)");
    json_get_field("$evapi(msg)", "Reason", "$var(Reason)");
    xwarn("CGR_SESSION_DISCONNECT: CGRates disconnects the call ($var(Reason))");
    jsonrpc_exec('{"jsonrpc":"2.0","id":1, "method":"dlg.end_dlg","params":[$(var(HashEntry){s.rm,"}),$(var(HashId){s.rm,"})]}');
    xinfo("CGR_SESSION_DISCONNECT: Response: '$jsonrpl(code) $jsonrpl(text) $jsonrpl(body)'");
}

event_route[htable:mod-init] {
    if (dns_query("users.ivozprovider.local", "kamusers")) {
        $var(usersAddress) = $dns(kamusers=>addr);
        xinfo("users.ivozprovider.local: $var(usersAddress)\n");
    } else {
        xerr("Problems resolving users.ivozprovider.local, aborting\n");
        abort();
    }
}